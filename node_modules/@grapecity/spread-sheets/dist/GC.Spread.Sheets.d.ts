declare module GC{
    module Spread{
        module CalcEngine{
            /**
             * Represents the expression type
             * @enum {number}
             */
            export enum ExpressionType{
                /**
                 * Specifies the unknow type
                 */
                unknow= 0,
                /**
                 * Specifies the reference type
                 */
                reference= 1,
                /**
                 * Specifies the number type
                 */
                number= 2,
                /**
                 * Specifies the string type
                 */
                string= 3,
                /**
                 * Specifies the boolean type
                 */
                boolean= 4,
                /**
                 * Specifies the error type
                 */
                error= 5,
                /**
                 * Specifies the array type
                 */
                array= 6,
                /**
                 * Specifies the function type
                 */
                function= 7,
                /**
                 * Specifies the name type
                 */
                name= 8,
                /**
                 * Specifies the operator type
                 */
                operator= 9,
                /**
                 * Specifies the parenthesses type
                 */
                parentheses= 10,
                /**
                 * Specifies the missing argument type
                 */
                missingArgument= 11,
                /**
                 * Specifies the expand type
                 */
                expand= 12,
                /**
                 * Specifies the struct reference type
                 */
                structReference= 13
            }


            export class AsyncEvaluateContext{
                /**
                 * Represents an evaluate context for async functions.
                 * @class
                 * @param {GC.Spread.CalcEngine.EvaluateContext} context The common evaluate context.
                 */
                constructor();
                /**
                 * Set the async function evaluate result to CalcEngine, CalcEngine uses this value to recalculate the cell that contains this async function and all dependents cells.
                 * @param {object} value The async function evaluate result.
                 */
                setAsyncResult(value:  any): void;
            }

            export class CalcError{
                /**
                 * Represents an error in calculation.
                 * @class
                 * @param {string} error The description of the error.
                 */
                constructor(error:  string);
                /**
                 * Parses the specified error from the string.
                 * @param {string} value The error string.
                 * @returns {GC.Spread.CalcEngine.CalcError} The calculation error.
                 */
                static parse(value: string): GC.Spread.CalcEngine.CalcError;
                /**
                 * Returns a string that represents this instance.
                 * @returns {string} The error string.
                 */
                toString(): string;
            }

            export class Expression{
                /**
                 * Provides the base class from which the classes that represent expression tree nodes are derived. This is an abstract class.
                 * @class
                 */
                constructor(type:  ExpressionType);
                /**
                 * Indicates the expression type
                 * @type {GC.Spread.CalcEngine.ExpressionType}
                 */
                type: ExpressionType;
            }
            module Functions{
                /**
                 * Defines a global custom function.
                 * @param {string} name The name of the function.
                 * @param {GC.Spread.CalcEngine.Functions.Function} fn The function to add.
                 */
                function defineGlobalCustomFunction(name:  string,  fn:  Functions.Function): void;
                /**
                 * Gets all of the global functions or one global function that specified by name.
                 * @param {string} name The name of the function.
                 * @returns {GC.Spread.CalcEngine.Functions.Function} If the name is empty, return all of the global functions, otherwise, return one function with the specified name.
                 */
                function findGlobalFunction(name?:  string): any;
                /**
                 * If the name is empty, remove all of the global functions, otherwise, remove one function with the specified name.
                 * @param {string} name The name of the function.
                 */
                function removeGlobalFunction(name?:  string): void;

                export interface IFunctionDescription{
                    description: string;
                    parameters: GC.Spread.CalcEngine.Functions.IParameterDescription[];
                }


                export interface IParameterDescription{
                    name: string;
                    repeatable?: boolean;
                    optional?: boolean;
                }

                /**
                 * Represents the asynchronous function evaluate mode.
                 * @enum {number}
                 */
                export enum AsyncFunctionEvaluateMode{
                    /**
                     * enum value is 0, Specifies that the async function evaluates the changed, referenced cells.
                     */
                    onRecalculation= 0,
                    /**
                     * enum value is 1, Specifies that the async function only evaluates once.
                     */
                    calculateOnce= 1,
                    /**
                     * enum value is 2, Specifies that the async function evaluates based on the interval.
                     */
                    onInterval= 2
                }


                export class AsyncFunction{
                    /**
                     * Represents an abstract base class for defining asynchronization functions.
                     * @class
                     * @param {string} name The name of the function.
                     * @param {number} minArgs The minimum number of arguments for the function.
                     * @param {number} maxArgs The maximum number of arguments for the function.
                     * @param {object} description The description of the function.
                     */
                    constructor(name:  string,  minArgs:  number,  maxArgs:  number,  description:  Object);
                    /**
                     * Returns the default value of the evaluated function result before getting the async result.
                     * @returns {object} The default value of the evaluated function result before getting the async result.
                     */
                    defaultValue(): any;
                    /**
                     * Returns the result of the function applied to the arguments.
                     * @param {GC.Spread.CalcEngine.AsyncEvaluateContext} context The evaluate context
                     * @param {object} args Arguments for the function evaluation
                     * @returns {object} The result of the function applied to the arguments.
                     */
                    evaluateAsync(context:  AsyncEvaluateContext,  args:  any[]): any;
                    /**
                     * Decides how to re-calculate the formula.
                     * @returns {GC.Spread.CalcEngine.Functions.AsyncFunctionEvaluateMode} The evaluate mode.
                     */
                    evaluateMode(): any;
                    /**
                     * Returns the interval.
                     * @returns {number} The interval in milliseconds.
                     */
                    interval(): any;
                }

                export class Function{
                    /**
                     * Represents an abstract base class for defining functions.
                     * @class
                     * @param {string} name The name of the function.
                     * @param {number} minArgs The minimum number of arguments for the function.
                     * @param {number} maxArgs The maximum number of arguments for the function.
                     * @param {object} functionDescription The description object of the function.
                     * @param {string} [functionDescription.description] - The description of the function.
                     * @param {object[]} [functionDescription.parameter] - The parameters' description array of the function.
                     * @param {string} functionDescription.parameter.name -  The parameter name..
                     * @param {boolean} [functionDescription.parameter.repeatable] - Whether the parameter is repeatable.
                     * @param {boolean} [functionDescription.parameter.optional] - Whether the parameter is optional.
                     */
                    constructor(name?:  string,  minArgs?:  number,  maxArgs?:  number,  description?:  GC.Spread.CalcEngine.Functions.IFunctionDescription);
                    /**
                     * Represents the maximum number of arguments for the function.
                     * @type {number}
                     */
                    maxArgs: number;
                    /**
                     * Represents the minimum number of arguments for the function.
                     * @type {number}
                     */
                    minArgs: number;
                    /**
                     * Represents the name of the function.
                     * @type {string}
                     */
                    name: string;
                    /**
                     * Represents the type name string used for supporting serialization.
                     * @type {string}
                     */
                    typeName: string;
                    /**
                     * Determines whether the function accepts array values for the specified argument.
                     * @param {number} argIndex Index of the argument.
                     * @function
                     * @returns {boolean} <c>true</c> if the function accepts array values for the specified argument; otherwise, <c>false</c>.
                     */
                    acceptsArray(argIndex:  number): boolean;
                    /**
                     * Indicates whether the function can process Error values.
                     * @param {number} argIndex Index of the argument.
                     * @returns {boolean} <c>true</c> if the function can process Error values for the specified argument; otherwise, <c>false</c>.
                     * @function
                     */
                    acceptsError(argIndex:  number): boolean;
                    /**
                     * Indicates whether the Evaluate method can process missing arguments.
                     * @param {number} argIndex Index of the argument
                     * @returns {boolean} <c>true</c> if the Evaluate method can process missing arguments; otherwise, <c>false</c>.
                     */
                    acceptsMissingArgument(argIndex:  number): boolean;
                    /**
                     * Determines whether the function accepts Reference values for the specified argument.
                     * @param {number} argIndex Index of the argument.
                     * @returns {boolean} <c>true</c> if the function accepts Reference values for the specified argument; otherwise, <c>false</c>.
                     * @function
                     */
                    acceptsReference(argIndex:  number): boolean;
                    /**
                     * Returns the description of the function.
                     * @function
                     * @returns {object} The description of the function.
                     */
                    description(): Object;
                    /**
                     * Returns the result of the function applied to the arguments.
                     * @param {object} args Arguments for the function evaluation
                     * @returns {object} The result of the function applied to the arguments.
                     */
                    evaluate(args:  any): any;
                    /**
                     * Finds the branch argument.
                     * @param {object} test The test.
                     * @returns {number} Indicates the index of the argument that would be treated as the branch condition.
                     */
                    findBranchArgument(test:  any): number;
                    /**
                     * Finds the test argument when this function is branched.
                     * @returns {number} Indicates the index of the argument that would be treated as the test condition.
                     */
                    findTestArgument(): boolean;
                    /**
                     * Gets a value that indicates whether this function is branched by arguments as conditional.
                     * @returns {boolean} <c>true</c> if this instance is branched; otherwise, <c>false</c>.
                     */
                    isBranch(): boolean;
                    /**
                     * Determines whether the evaluation of the function is dependent on the context in which the evaluation occurs.
                     * @returns {boolean} <c>true</c> if the evaluation of the function is dependent on the context; otherwise, <c>false</c>.
                     */
                    isContextSensitive(): boolean;
                    /**
                     * Determines whether the function is volatile while it is being evaluated.
                     * @returns {boolean} <c>true</c> if the function is volatile; otherwise, <c>false</c>.
                     */
                    isVolatile(): boolean;
                }
            }

        }

        module Commands{
            /**
             * Represents the key code.
             * @enum {number}
             * @example
             * //This example creates a custom action using the enter key.
             * var activeSheet = spread.getActiveSheet();
             * spread.commandManager().register('myCmd',
             *                 function ColorAction() {
             *                     //Click on a cell and press the Enter key.
             *                     activeSheet.getCell(activeSheet.getActiveRowIndex(), activeSheet.getActiveColumnIndex()).backColor("red");
             *                 }
             *             );
             * //Map the created action to the Enter key.
             * spread.commandManager().setShortcutKey('myCmd', GC.Spread.Commands.Key.enter, false, false, false, false);
             */
            export enum Key{
                /**
                 * Indicates the left arrow key.
                 */
                left= 37,
                /**
                 * Indicates the right arrow key.
                 */
                right= 39,
                /**
                 * Indicates the up arrow key.
                 */
                up= 38,
                /**
                 * Indicates the down arrow key.
                 */
                down= 40,
                /**
                 * Indicates the Tab key.
                 */
                tab= 9,
                /**
                 * Indicates the Enter key.
                 */
                enter= 13,
                /**
                 * Indicates the Shift key.
                 */
                shift= 16,
                /**
                 * Indicates the Ctrl key.
                 */
                ctrl= 17,
                /**
                 * Indicates the space key.
                 */
                space= 32,
                /**
                 * Indicates the Alt key.
                 */
                altkey= 18,
                /**
                 * Indicates the Home key.
                 */
                home= 36,
                /**
                 * Indicates the End key.
                 */
                end= 35,
                /**
                 * Indicates the Page Up key.
                 */
                pup= 33,
                /**
                 * Indicates the Page Down key.
                 */
                pdn= 34,
                /**
                 * Indicates the Backspace key.
                 */
                backspace= 8,
                /**
                 * Indicates the Delete key.
                 */
                del= 46,
                /**
                 * Indicates the Esc key.
                 */
                esc= 27,
                /**
                 * Indicates the A key
                 */
                a= 65,
                /**
                 * Indicates the C key.
                 */
                c= 67,
                /**
                 * Indicates the V key.
                 */
                v= 86,
                /**
                 * Indicates the X key.
                 */
                x= 88,
                /**
                 * Indicates the Z key.
                 */
                z= 90,
                /**
                 * Indicates the Y key.
                 */
                y= 89
            }


            export class CommandManager{
                /**
                 * Represents a command manager.
                 * @class
                 * @param {Object} context The execution context for all commands in the command manager.
                 * @constructor
                 */
                constructor(context:  Object);
                /**
                 * Executes a command and adds the command to UndoManager.
                 * @param {Object} commandOptions The options for the command.
                 * @param {string} commandOptions.cmd The command name, the field is required.
                 * @param {Object} [commandOptions.arg1] The command argument, the name and type are decided by the command definition.
                 * @param {Object} [commandOptions.arg2] The command argument, the name and type are decided by the command definition.
                 * @param {Object} [commandOptions.argN] The command argument, the name and type are decided by the command definition.
                 * @returns {string} The execute command result.
                 * @example
                 * //For example, the following code executes the autoFitColumn command.
                 * var spread = GC.Spread.Sheets.findControl(document.getElementById("ss"));
                 * spread.commandManager().execute({cmd: "autoFitColumn", sheetName: "Sheet1", columns: [{col: 1}], rowHeader: false, autoFitType: GC.Spread.Sheets.AutoFitType.cell});
                 */
                execute(commandOptions:  Object): any;
                /**
                 * Registers a command with the command manager.
                 * @param {string} name - The name of the command.
                 * @param {Object} command - The object that defines the command.
                 * @param {number|GC.Spread.Commands.Key} key - The key code.
                 * @param {boolean} ctrl - <c>true</c> if the command uses the Ctrl key; otherwise, <c>false</c>.
                 * @param {boolean} shift - <c>true</c> if the command uses the Shift key; otherwise, <c>false</c>.
                 * @param {boolean} alt - <c>true</c> if the command uses the Alt key; otherwise, <c>false</c>.
                 * @param {boolean} meta - <c>true</c> if the command uses the Command key on the Macintosh or the Windows key on Microsoft Windows; otherwise, <c>false</c>.
                 * @example
                 * //For example, the following code registers the changeBackColor command and then executes the command.
                 *  var command = {
                 *       canUndo: true,
                 execute: function (context, options, isUndo) {
                 var Commands = GC.Spread.Sheets.Commands;
                 if (isUndo) {
                 Commands.undoTransaction(context, options);
                 return true;
                 } else {
                 Commands.startTransaction(context, options);
                 var sheet = context.getSheetFromName(options.sheetName);
                 var cell = sheet.getCell(options.row, options.col);
                 cell.backColor(options.backColor);
                 Commands.endTransaction(context, options);
                 return true;
                 }
                 }
                 };
                 *  var spread = GC.Spread.Sheets.findControl(document.getElementById("ss"));
                 *  var commandManager = spread.commandManager();
                 *  commandManager.register("changeBackColor", command);
                 *  commandManager.execute({cmd: "changeBackColor", sheetName: spread.getSheet(0).name(), row: 1, col: 2, backColor: "red"});
                 */
                register(name:  string,  command:  Object,  key?:  number|GC.Spread.Commands.Key,  ctrl?:  boolean,  shift?:  boolean,  alt?:  boolean,  meta?:  boolean): void;
                /**
                 * Binds a shortcut key to a command.
                 * @param {string} commandName The command name, setting commandName to undefined removes the bound command of the shortcut key.
                 * @param {number|GC.Spread.Commands.Key} key The key code, setting the key code to undefined removes the shortcut key of the command.
                 * @param {boolean} ctrl <c>true</c> if the command uses the Ctrl key; otherwise, <c>false</c>.
                 * @param {boolean} shift <c>true</c> if the command uses the Shift key; otherwise, <c>false</c>.
                 * @param {boolean} alt <c>true</c> if the command uses the Alt key; otherwise, <c>false</c>.
                 * @param {boolean} meta <c>true</c> if the command uses the Command key on the Macintosh or the Windows key on Microsoft Windows; otherwise, <c>false</c>.
                 * @example
                 * //This example changes the behavior of default keys.
                 * var activeSheet = spread.getActiveSheet();
                 * //Change the default Up arrow key action to "Page Up" for the active cell.
                 * spread.commandManager().setShortcutKey('navigationPageUp', GC.Spread.Commands.Key.up, false, false, false, false);
                 * //Change the default Down arrow key action to "Page Down" for the active cell.
                 * spread.commandManager().setShortcutKey('navigationPageDown', GC.Spread.Commands.Key.down, false, false, false, false);
                 */
                setShortcutKey(commandName:  string,  key?:  number|GC.Spread.Commands.Key,  ctrl?:  boolean,  shift?:  boolean,  alt?:  boolean,  meta?:  boolean): void;
            }

            export class UndoManager{
                /**
                 * Represents the undo manager.
                 * @constructor
                 */
                constructor();
                /**
                 * Gets whether the redo operation is allowed.
                 * @returns {boolean} <c>true</c> if the redo operation is allowed; otherwise, <c>false</c>.
                 */
                canRedo(): boolean;
                /**
                 * Gets whether the undo operation is allowed.
                 * @returns {boolean} <c>true</c> if the undo operation is allowed; otherwise, <c>false</c>.
                 */
                canUndo(): boolean;
                /**
                 * Clears all of the undo stack and the redo stack.
                 */
                clear(): void;
                /**
                 * Redoes the last command.
                 * @returns {boolean} <c>true</c> if the redo operation is successful; otherwise, <c>false</c>.
                 */
                redo(): boolean;
                /**
                 * Undoes the last command.
                 * @returns {boolean} <c>true</c> if the undo operation is successful; otherwise, <c>false</c>.
                 */
                undo(): boolean;
            }
        }

        module Common{

            export interface IDateTimeFormat{
                abbreviatedDayNames?: string[];
                abbreviatedMonthGenitiveNames?: string[];
                abbreviatedMonthNames?: string[];
                amDesignator?: string;
                dayNames?: string[];
                fullDateTimePattern?: string;
                longDatePattern?: string;
                longTimePattern?: string;
                monthDayPattern?: string;
                monthGenitiveNames?: string[];
                monthNames?: string[];
                pmDesignator?: string;
                shortDatePattern?: string;
                shortTimePattern?: string;
                yearMonthPattern?: string;
            }


            export interface INumberFormat{
                currencyDecimalSeparator?: string;
                currencyGroupSeparator?: string;
                currencySymbol?: string;
                numberDecimalSeparator?: string;
                numberGroupSeparator?: string;
                listSeparator?: string;
                arrayListSeparator?: string;
                arrayGroupSeparator?: string;
                dbNumber?: Object
            }


            export class CultureInfo{
                /**
                 * Represents the custom culture class. The member variable can be overwritten.
                 * @class
                 */
                constructor();
                /**
                 * Indicates the date time format fields.
                 * @type {Object}
                 * @property {Array.<string>} abbreviatedDayNames - Specifies the day formatter for "ddd".
                 * @property {Array.<string>} abbreviatedMonthGenitiveNames - Specifies the month formatter for "MMM".
                 * @property {Array.<string>} abbreviatedMonthNames - Specifies the month formatter for "MMM".
                 * @property {string} amDesignator - Indicates the AM designator.
                 * @property {Array.<string>} dayNames - Specifies the day formatter for "dddd".
                 * @property {string} fullDateTimePattern - Specifies the standard date formatter for "F".
                 * @property {string} longDatePattern - Specifies the standard date formatter for "D".
                 * @property {string} longTimePattern - Specifies the standard date formatter for "T" and "U".
                 * @property {string} monthDayPattern - Specifies the standard date formatter for "M" and "m".
                 * @property {Array.<string>} monthGenitiveNames - Specifies the formatter for "MMMM".
                 * @property {Array.<string>} monthNames - Specifies the formatter for "M" or "MM".
                 * @property {string} pmDesignator - Indicates the PM designator.
                 * @property {string} shortDatePattern - Specifies the standard date formatter for "d".
                 * @property {string} shortTimePattern - Specifies the standard date formatter for "t".
                 * @property {string} yearMonthPattern - Specifies the standard date formatter for "y" and "Y".
                 * @example
                 * // This example creates a custom culture.
                 * var myCulture = new GC.Spread.Common.CultureInfo();
                 * myCulture.NumberFormat.currencySymbol = "\u20ac"
                 * myCulture.NumberFormat.numberDecimalSeparator = ",";
                 * myCulture.NumberFormat.numberGroupSeparator = ".";
                 * myCulture.NumberFormat.arrayGroupSeparator = ";";
                 * myCulture.NumberFormat.arrayListSeparator = "\\";
                 * myCulture.NumberFormat.listSeparator = ";";
                 * myCulture.DateTimeFormat.amDesignator = "";
                 * myCulture.DateTimeFormat.pmDesignator = "";
                 * myCulture.DateTimeFormat.abbreviatedMonthNames = ["Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez", ""];
                 * myCulture.DateTimeFormat.abbreviatedDayNames = ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"];
                 * myCulture.DateTimeFormat.abbreviatedMonthGenitiveNames = ["Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez", ""];
                 * myCulture.DateTimeFormat.dayNames = ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"];
                 * myCulture.DateTimeFormat.fullDateTimePattern = "dddd, d. MMMM yyyy HH:mm:ss";
                 * myCulture.DateTimeFormat.longDatePattern = "dddd, d. MMMM yyyy";
                 * myCulture.DateTimeFormat.longTimePattern = "HH:mm:ss";
                 * myCulture.DateTimeFormat.monthDayPattern = "dd MMMM";
                 * myCulture.DateTimeFormat.monthNames = ["Januar", "Februar", "M\xe4rz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember", ""];
                 * myCulture.DateTimeFormat.monthGenitiveNames = ["Januar", "Februar", "M\xe4rz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember", ""];
                 * myCulture.DateTimeFormat.shortDatePattern = "dd.MM.yyyy";
                 * myCulture.DateTimeFormat.shortTimePattern = "HH:mm";
                 * myCulture.DateTimeFormat.yearMonthPattern = "MMMM yyyy";
                 * //add one culture
                 * GC.Spread.Common.CultureManager.addCultureInfo("de-DE", myCulture);
                 * //switch to "de-DE" culture
                 * GC.Spread.Common.CultureManager.culture("de-DE");
                 * var d = new Date();
                 * //With culture
                 * activeSheet.setValue(1, 0, new Date(d.setDate(d.getDate() + 1)));
                 * activeSheet.getCell(1, 0).formatter("mmm");
                 * var dvalue = 12345.6789;
                 * activeSheet.setColumnWidth(0, 200);
                 * activeSheet.setColumnWidth(1, 200);
                 * activeSheet.setColumnWidth(2, 200);
                 * activeSheet.setValue(0, 0, dvalue);
                 * activeSheet.getCell(0, 0).formatter("###,###.00");
                 * activeSheet.setValue(2, 0, new Date(d.setDate(d.getDate() + 1)));
                 * //With culture
                 * activeSheet.getCell(3, 0).formatter("yyyy/mmm/dddd");
                 * activeSheet.setValue(3, 0, new Date());
                 */
                DateTimeFormat: GC.Spread.Common.IDateTimeFormat;
                /**
                 * Indicates all the number format fields.
                 * @type {Object}
                 * @property {string} currencyDecimalSeparator - Indicates the currency decimal point.
                 * @property {string} currencyGroupSeparator - Indicates the currency thousand separator.
                 * @property {string} currencySymbol - Indicates the currency symbol.
                 * @property {string} numberDecimalSeparator - Indicates the decimal point.
                 * @property {string} numberGroupSeparator - Indicates the thousand separator.
                 * @property {string} listSeparator - Indicates the separator for function arguments in a formula.
                 * @property {string} arrayListSeparator - Indicates the separator for the constants in one row of an array constant in a formula.
                 * @property {string} arrayGroupSeparator - Indicates the separator for the array rows of an array constant in a formula.
                 * @property {object} dbNumber - Specifies the DBNumber characters.
                 * The dbNumber object structure as follow:
                 *  {
                 *     1: {letters: ['\u5146', '\u5343', '\u767e', '\u5341', '\u4ebf', '\u5343', '\u767e', '\u5341', '\u4e07', '\u5343', '\u767e', '\u5341', ''], // \u5146\u5343\u767e\u5341\u4ebf\u5343\u767e\u5341\u4e07\u5343\u767e\u5341
                 *         numbers: ['\u25cb', '\u4e00', '\u4e8c', '\u4e09', '\u56db', '\u4e94', '\u516d', '\u4e03', '\u516b', '\u4e5d'] }, // \u25cb\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d
                 *     2: {letters: ['\u5146', '\u4edf', '\u4f70', '\u62fe', '\u4ebf', '\u4edf', '\u4f70', '\u62fe', '\u4e07', '\u4edf', '\u4f70', '\u62fe', ''], // \u5146\u4edf\u4f70\u62fe\u4ebf\u4edf\u4f70\u62fe\u4e07\u4edf\u4f70\u62fe
                 *         numbers: ['\u96f6', '\u58f9', '\u8d30', '\u53c1', '\u8086', '\u4f0d', '\u9646', '\u67d2', '\u634c', '\u7396']}, // \u96f6\u58f9\u8d30\u53c1\u8086\u4f0d\u9646\u67d2\u634c\u7396
                 *     3: {letters: null,
                 *         numbers: ['\uff10', '\uff11', '\uff12', '\uff13', '\uff14', '\uff15', '\uff16', '\uff17', '\uff18', '\uff19']} // \uff10\uff11\uff12\uff13\uff14\uff15\uff16\uff17\uff18\uff19
                 * };
                 * @example
                 * // This example creates a custom culture.
                 * var myCulture = new GC.Spread.Common.CultureInfo();
                 * myCulture.NumberFormat.currencySymbol = "\u20ac"
                 * myCulture.NumberFormat.numberDecimalSeparator = ",";
                 * myCulture.NumberFormat.numberGroupSeparator = ".";
                 * myCulture.NumberFormat.arrayGroupSeparator = ";";
                 * myCulture.NumberFormat.arrayListSeparator = "\\";
                 * myCulture.NumberFormat.listSeparator = ";";
                 * myCulture.DateTimeFormat.amDesignator = "";
                 * myCulture.DateTimeFormat.pmDesignator = "";
                 * myCulture.DateTimeFormat.abbreviatedMonthNames = ["Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez", ""];
                 * myCulture.DateTimeFormat.abbreviatedDayNames = ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"];
                 * myCulture.DateTimeFormat.abbreviatedMonthGenitiveNames = ["Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez", ""];
                 * myCulture.DateTimeFormat.dayNames = ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"];
                 * myCulture.DateTimeFormat.fullDateTimePattern = "dddd, d. MMMM yyyy HH:mm:ss";
                 * myCulture.DateTimeFormat.longDatePattern = "dddd, d. MMMM yyyy";
                 * myCulture.DateTimeFormat.longTimePattern = "HH:mm:ss";
                 * myCulture.DateTimeFormat.monthDayPattern = "dd MMMM";
                 * myCulture.DateTimeFormat.monthNames = ["Januar", "Februar", "M\xe4rz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember", ""];
                 * myCulture.DateTimeFormat.monthGenitiveNames = ["Januar", "Februar", "M\xe4rz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember", ""];
                 * myCulture.DateTimeFormat.shortDatePattern = "dd.MM.yyyy";
                 * myCulture.DateTimeFormat.shortTimePattern = "HH:mm";
                 * myCulture.DateTimeFormat.yearMonthPattern = "MMMM yyyy";
                 * //add one culture
                 * GC.Spread.Common.CultureManager.addCultureInfo("de-DE", myCulture);
                 * //switch to "de-DE" culture
                 * GC.Spread.Common.CultureManager.culture("de-DE");
                 * var d = new Date();
                 * //With culture
                 * activeSheet.setValue(1, 0, new Date(d.setDate(d.getDate() + 1)));
                 * activeSheet.getCell(1, 0).formatter("mmm");
                 * var dvalue = 12345.6789;
                 * activeSheet.setColumnWidth(0, 200);
                 * activeSheet.setColumnWidth(1, 200);
                 * activeSheet.setColumnWidth(2, 200);
                 * activeSheet.setValue(0, 0, dvalue);
                 * activeSheet.getCell(0, 0).formatter("###,###.00");
                 * activeSheet.setValue(2, 0, new Date(d.setDate(d.getDate() + 1)));
                 * //With culture
                 * activeSheet.getCell(3, 0).formatter("yyyy/mmm/dddd");
                 * activeSheet.setValue(3, 0, new Date());
                 */
                NumberFormat: GC.Spread.Common.INumberFormat;
            }

            export class CultureManager{
                /**
                 * Represente a culture manager.
                 * @constructor
                 */
                constructor();
                /**
                 * Adds the cultureInfo into the culture manager.
                 * @static
                 * @param {string} cultureName
                 * @param {GC.Spread.Common.CultureInfo} culture object
                 */
                static addCultureInfo(cultureName: any,  culture: any): GC.Spread.Common.CultureInfo;
                /**
                 * Get or set the Sheets culture.
                 * @static
                 * @param {string} cultureName The culture name to get.
                 * @returns {string}. The current culture name of Sheets.
                 */
                static culture(cultureName?:  string): string;
                /**
                 * Gets the specified cultureInfo. If no culture name, get current cultureInfo.
                 * @static
                 * @param {Object} cultureName Culture name or culture ID
                 * @returns {GC.Spread.Common.CultureInfo} cultureInfo object
                 */
                static getCultureInfo(cultureName:  Object): GC.Spread.Common.CultureInfo;
            }
        }

        module Excel{

            export class IO{
                /**
                 * Represents an excel import and export class.
                 * @class
                 */
                constructor();
                /**
                 * Imports an excel file.
                 * @param {Blob} file The excel file.
                 * @param {function} successCallBack Call this function after successfully loading the file. function (json) { }.
                 * @param {function} errorCallBack Call this function if an error occurs. The exception parameter object structure { errorCode: GC.Spread.Excel.IO.ErrorCode, errorMessage: string}.
                 * @param {Object} options The options for import excel.
                 ** options.password {string} the excel file's password.
                 */
                open(file:  Blob,  successCallBack:  Function,  errorCallBack:  Function,  options?:  any): void;
                /**
                 * Creates and saves an excel file with the SpreadJS json.
                 * @param {object} json The spread sheets json object, or string.
                 * @param {function} successCallBack Call this function after successfully exporting the file. function (blob) { }.
                 * @param {function} errorCallBack Call this function if an error occurs. The exception parameter object structure { errorCode: GC.Spread.Excel.IO.ErrorCode, errorMessage: string}.
                 * @param {Object} options The options for export excel.
                 ** options.password {string} the excel file's password.
                 */
                save(json:  String,  successCallBack:  Function,  errorCallBack:  Function,  options?:  any): void;
            }
            module IO{
                /**
                 * Specifies the excel io error code.
                 * @enum {number}
                 */
                export enum ErrorCode{
                    /**
                     *  File read and write exception.
                     */
                    fileIOError= 0,
                    /**
                     *  Incorrect file format.
                     */
                    fileFormatError= 1,
                    /**
                     *  The Excel file cannot be opened because the workbook/worksheet is password protected.
                     */
                    noPassword= 2,
                    /**
                     *  The specified password is incorrect.
                     */
                    invalidPassword= 3
                }

            }

        }

        module Formatter{

            export class FormatterBase{
                /**
                 * Represents a custom formatter with the specified format string.
                 * @class
                 * @param {string} format The format.
                 * @param {string} cultureName The culture name.
                 */
                constructor(format:  string,  cultureName:  string);
                /** Represents the type name string used for supporting serialization.
                 * @type {string}
                 */
                typeName: string;
                /**
                 * Formats the specified object as a string with a conditional color. This function should be overwritten.
                 * @param {Object} obj - The object with cell data to format.
                 * @param {Object} [options] - The additonal format data.
                 * @param {string} [options.conditionalForeColor] - The conditonal foreColor when format pattern contains color patter, such as [red]###.##
                 * @returns {string} The formatted string.
                 * @example
                 * //This example creates a custom formatter.
                 * var customFormatterTest = {};
                 * customFormatterTest.prototype = GC.Spread.Formatter.FormatterBase;
                 * customFormatterTest.format = function (obj, data) {
                 *     data.conditionalForeColor = "blue";
                 *     return "My format result : " + obj.toString();
                 * };
                 * customFormatterTest.parse = function (str) {
                 *     if (!str) {
                 *         return "";
                 *     }
                 *     return str;
                 * }
                 * activeSheet.getCell(1, 0).formatter(customFormatterTest);
                 * activeSheet.getCell(1, 0).value("Test");
                 */
                format(obj:  Object): string;
                /**
                 * Loads the object state from the specified JSON string.
                 * @param {Object} settings The custom formatter data from deserialization.
                 */
                fromJSON(settings:  Object): void;
                /**
                 * Parses the specified text. This function should be overwritten.
                 * @param {string} text The text.
                 * @returns {Object} The parsed object.
                 * @example
                 * //This example creates a custom formatter.
                 * var customFormatterTest = {};
                 * customFormatterTest.prototype = GC.Spread.Formatter.FormatterBase;
                 * customFormatterTest.format = function (obj, conditionalForeColor) {
                 *     conditionalForeColor.value = "blue";
                 *     return "My format result : " + obj.toString();
                 * };
                 * customFormatterTest.parse = function (str) {
                 *     if (!str) {
                 *         return "";
                 *     }
                 *     return str;
                 * }
                 * activeSheet.getCell(1, 0).formatter(customFormatterTest);
                 * activeSheet.getCell(1, 0).value("Test")
                 */
                parse(str:  string): Object;
                /**
                 * Saves the object state to a JSON string.
                 * @returns {Object} The custom formatter data.
                 */
                toJSON(): Object;
            }

            export class GeneralFormatter{
                /**
                 * Represents a formatter with the specified format mode and format string.
                 * @class
                 * @param {string} format The format.
                 * @param {string} cultureName The culture name.
                 */
                constructor(format:  string,  cultureName:  string);
                /**
                 * Formats the specified object as a string with a formatted data Object.
                 * @param {Object} obj The object with cell data to format.
                 * @param {Object} formattedData The object with formatted data.
                 * @param {Array} [formattedData.content]-The formatted data array, each item is an object that has two properties type and value, And it may contain these types: 'number', 'text', 'fillingChar', 'placeholder', 'exponent', 'decimalSeparator', 'groupSeparator', 'numberPlaceholder', 'percent', 'permille' and 'currency'. For example: {type: 'number', value: '123'}.
                 * @param {string} [formattedData.conditionalForeColor]-The conditional foreground color.
                 * @returns {string} The formatted string.
                 */
                format(obj:  Object,  formattedData:  Object): string;
                /**
                 * Gets or sets the format string for this formatter.
                 * @param {string} value The format string for this formatter.
                 * @returns {string|GC.Spread.Formatter.GeneralFormatter} If no value is set, returns the formatter string for this formatter; otherwise, returns the formatter.
                 */
                formatString(value?:  string): any;
                /**
                 * Parses the specified text.
                 * @param {string} text The text.
                 * @returns {Object} The parsed object.
                 */
                parse(str:  string): Object;
            }
        }

        module Sheets{
            /**
             * Represents the license key for evaluation version and production version.
             */
            var LicenseKey: string;
            /**
             * Gets the Workbook instance by the host element.
             * @param {HTMLElement|string} host The host element or the host element id.
             * @returns {GC.Spread.Sheets.Workbook} The Workbook instance.
             */
            function findControl(host:  HTMLElement|string): GC.Spread.Sheets.Workbook;
            /**
             * Gets the type from the type string. This method is used for supporting the serialization of the custom object.
             * @param {string} typeString The type string.
             * @returns {Object} The type.
             */
            function getTypeFromString(typeString:  string): any;

            export interface FloatingObjectLoadedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                floatingObject: FloatingObjects.FloatingObject;
                element: HTMLElement;
            }


            export interface IActiveSheetChangedEventArgs{
                oldSheet: GC.Spread.Sheets.Worksheet;
                newSheet: GC.Spread.Sheets.Worksheet;
            }


            export interface IActiveSheetChangingEventArgs{
                oldSheet: GC.Spread.Sheets.Worksheet;
                newSheet: GC.Spread.Sheets.Worksheet;
                cancel: boolean;
            }


            export interface IButtonClickedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                sheetArea: SheetArea;
            }


            export interface ICellChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                sheetArea: SheetArea;
                propertyName: string;
                oldValue: any;
                newValue: any;
            }


            export interface ICellClickEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                sheetArea: SheetArea;
                row: number;
                col: number;
            }


            export interface ICellDoubleClickEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                sheetArea: SheetArea;
                row: number;
                col: number;
            }


            export interface ICellPosition{
                row: number;
                col: number;
            }


            export interface IClipboardChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                copyData: string;
            }


            export interface IClipboardChangingEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                copyData: string;
                cancel: boolean;
            }


            export interface IClipboardPastedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                cellRange: Range;
                pasteOption: ClipboardPasteOptions;
            }


            export interface IClipboardPastingEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                cellRange: Range;
                pasteOption: ClipboardPasteOptions;
                cancel: boolean;
            }


            export interface IColumnChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                col: number;
                sheetArea: SheetArea;
                propertyName: string;
                oldValue: any;
                newValue: any;
                count?: number;
            }


            export interface IColumnWidthChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                colList: any[];
                header: boolean;
            }


            export interface IColumnWidthChangingEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                colList: any[];
                header: boolean;
                cancel: boolean;
            }


            export interface ICommentChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                comment: Comments.Comment;
                propertyName: string;
            }


            export interface ICommentRemovedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                comment: Comments.Comment;
            }


            export interface ICommentRemovingEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                comment: Comments.Comment;
                cancel: boolean;
            }


            export interface IDirtyCellInfo{
                row: number;
                col: number;
                newValue: any;
                oldValue: any;
            }


            export interface IDragDropBlockCompletedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                fromRow: number;
                fromCol: number;
                toRow: number;
                toCol: number;
                rowCount: number;
                colCount: number;
                copy: boolean;
                insert: boolean;
                copyOption: CopyToOptions;
            }


            export interface IDragDropBlockEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                fromRow: number;
                fromCol: number;
                toRow: number;
                toCol: number;
                rowCount: number;
                colCount: number;
                copy: boolean;
                insert: boolean;
                copyOption: CopyToOptions;
                cancel: boolean;
            }


            export interface IDragFillBlockCompletedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                fillRange: GC.Spread.Sheets.Range;
                autoFillType: GC.Spread.Sheets.Fill.AutoFillType;
                fillDirection: GC.Spread.Sheets.Fill.FillDirection;
            }


            export interface IDragFillBlockEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                fillRange: GC.Spread.Sheets.Range;
                autoFillType: GC.Spread.Sheets.Fill.AutoFillType;
                fillDirection: GC.Spread.Sheets.Fill.FillDirection;
                cancel: boolean;
            }


            export interface IEditChangeEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                editingText: any;
            }


            export interface IEditEndedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                editingText: Object;
            }


            export interface IEditEndingEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                editor: Object;
                editingText: Object;
                cancel: boolean;
            }


            export interface IEditorStatusChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                oldStatus: EditorStatus;
                newStatus: EditorStatus;
            }


            export interface IEditStartingEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                cancel: boolean;
            }


            export interface IEnterCellEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
            }


            export interface IFilterButtonHitInfo{
                rowFilter: any;
                row?: number;
                col?: number;
                x?: number;
                y?: number;
                width?: number;
                height?: number;
                sheetArea?: GC.Spread.Sheets.SheetArea;
            }


            export interface IFloatingObjectChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                floatingObject: FloatingObjects.FloatingObject;
                propertyName: string;
            }


            export interface IFloatingObjectRemovedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                floatingObject: FloatingObjects.FloatingObject;
            }


            export interface IFloatingObjectRemovingEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                floatingObject: FloatingObjects.FloatingObject;
                cancel: boolean;
            }


            export interface IFloatingObjectSelectionChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                floatingObject: FloatingObjects.FloatingObject;
            }


            export interface IFormulaInformation{
                hasFormula: boolean;
                formula: string;
                isArrayFormula: boolean;
                baseRange: Range;
            }


            export interface IFormulaRangeHitInfo{
                paramRange: GC.Spread.Sheets.IParamRange; //param range info
                inTopLeft?: boolean;
                inTopRight?: boolean;
                inBottomLeft?: boolean;
                inBottomRight?: boolean;
                inBorder?: boolean;
            }


            export interface IHitTestCellTypeHitInfo{
                x?: number;
                y?: number;
                row?: number;
                col?: number;
                cellRect?: GC.Spread.Sheets.Rect;
                sheetArea?: GC.Spread.Sheets.SheetArea;
                isReservedLocation?: boolean;
            }


            export interface IHitTestCommentHitInfo{
                x?: number;
                y?: number;
                comment?: GC.Spread.Sheets.Comments.Comment;
                area?: string;
            }


            export interface IHitTestDragInfo{
                action?: string;
                side?: string;
                outside?: boolean;
            }


            export interface IHitTestFloatingObjectHitInfo{
                x?: number;
                y?: number;
                floatingObject?: GC.Spread.Sheets.FloatingObjects.FloatingObject;
            }


            export interface IHitTestFooterCornerInfo{
                element?: string,
            }


            export interface IHitTestInformation{
                x?: number;
                y?: number;
                rowViewportIndex?: number;
                colViewportIndex?: number;
                row?: number;
                col?: number;
                hitTestType?: GC.Spread.Sheets.SheetArea;
                resizeInfo?: GC.Spread.Sheets.IHitTestResizeInfo;
                outlineHitInfo?: GC.Spread.Sheets.IHitTestOutlineHitInfo;
                filterButtonHitInfo?: GC.Spread.Sheets.IFilterButtonHitInfo;
                dragInfo?: GC.Spread.Sheets.IHitTestDragInfo;
                cellTypeHitInfo?: GC.Spread.Sheets.IHitTestCellTypeHitInfo;
                floatingObjectHitInfo?: GC.Spread.Sheets.IHitTestFloatingObjectHitInfo;
                formulaRangeHitInfo?: GC.Spread.Sheets.IFormulaRangeHitInfo;
                commentHitInfo?: GC.Spread.Sheets.IHitTestCommentHitInfo;
            }


            export interface IHitTestOutlineHitInfo{
                what?: string;
                info?: GC.Spread.Sheets.IOutlineHitInfo;
            }


            export interface IHitTestResizeInfo{
                action?: string;
                index?: number;
                sheetArea?: GC.Spread.Sheets.SheetArea;
                startY?: number;
                movingY?: number;
                startX?: number;
                movingX?: number;
            }


            export interface IHitTestScrollBarInfo{
                element?: string,
            }


            export interface IIHitTestTabStripInfo{
                navButton?: string;
                sheetTab?: GC.Spread.Sheets.SheetTabInfo;
                resize?: boolean;
                blank?: boolean;
            }


            export interface IInvalidOperationEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                invalidType: InvalidOperationType;
                message: string;
            }


            export interface ILeaveCellEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                cancel: boolean;
            }


            export interface ILeftColumnChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                oldLeftCol: number;
                newLeftCol: number;
            }


            export interface IOutlineColumnCheckStatusChanged{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number,
                col: number,
                status: boolean
            }


            export interface IOutlineHitInfo{
                index?: number;
                isExpanded?: boolean;
                level?: number;
                lineDirection?: GC.Spread.Sheets.Outlines.OutlineDirection;
                paintLine?: boolean;
            }


            export interface IParamRange{
                textOffset: number; // range text offset in formulatextbox's value
                text: string; // range text
                index: number; // index in all ranges
            }


            export interface IPictureChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                picture: FloatingObjects.Picture;
                propertyName: string;
            }


            export interface IPictureSelectionChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                picture: FloatingObjects.Picture;
            }


            export interface IProtectionOptions{
                allowSelectLockedCells?: boolean; //True or undefined if the user can select locked cells.
                allowSelectUnlockedCells?: boolean; //True or undefined if the user can select unlocked cells.
                allowSort?: boolean; //True if the user can sort ranges.
                allowFilter?: boolean; //True if the user can filter ranges.
                allowEditObjects?: boolean; //True if the user can edit floating objects.
                allowResizeRows?: boolean; //True if the user can resize rows.
                allowResizeColumns?: boolean; //True if the user can resize columns.
                allowDragInsertRows?: boolean; //True if the user can drag to insert rows.
                allowDragInsertColumns?: boolean; //True if the user can drag to insert columns.
                allowInsertRows?: boolean; //True if the user can insert rows.
                allowInsertColumns?: boolean; //True if the user can insert columns.
                allowDeleteRows?: boolean; //True if the user can delete rows.
                allowDeleteColumns?: boolean; //True if the user can delete columns.
            }


            export interface IRangeChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                rowCount: number;
                colCount: number;
                changedCells: ICellPosition[];
                action: RangeChangedAction;
            }


            export interface IRangeFilterClearedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                col: number;
            }


            export interface IRangeFilterClearingEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                col: number;
            }


            export interface IRangeFilteredEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                col: number;
                filterValues: any[];
            }


            export interface IRangeFilteringEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                col: number;
                filterValues: any[];
                conditionInfo : Object;
            }


            export interface IRangeGroupStateChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                isRowGroup: boolean;
                index: number;
                level: number;
            }


            export interface IRangeGroupStateChangingEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                isRowGroup: boolean;
                index: number;
                level: number;
                cancel: boolean;
            }


            export interface IRangeSortedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                col: number;
                ascending: boolean;
            }


            export interface IRangeSortingEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                col: number;
                ascending: boolean;
            }


            export interface IRowChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                sheetArea: SheetArea;
                propertyName: string;
                oldValue: any;
                newValue: any;
                count?: number;
            }


            export interface IRowHeightChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                rowList: any[];
                header: boolean;
            }


            export interface IRowHeightChangingEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                rowList: any[];
                header: boolean;
                cancel: boolean;
            }


            export interface ISelectionChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                oldSelections: Sheets.Range[];
                newSelections: Sheets.Range[];
            }


            export interface ISelectionChangingEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                oldSelections: any[];
                newSelections: any[];
            }


            export interface ISetBorderOptions{
                all?: boolean;
                left?: boolean;
                top?: boolean;
                right?: boolean;
                bottom?: boolean;
                outline?: boolean;
                inside?: boolean;
                innerHorizontal?: boolean;
                innerVertical?: boolean;
                diagonalUp?:boolean;
                diagonalDown?:boolean;
            }


            export interface IShapeChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                shape: GC.Spread.Sheets.Shapes.Shape;
                propertyName: string;
            }


            export interface IShapeRemovedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                shape: Shapes.Shape;
            }


            export interface IShapeRemovingEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                shape: Shapes.Shape;
                cancel: boolean;
            }


            export interface IShapeSelectionChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                shape: Shapes.Shape;
            }


            export interface ISheetDefaultOption{
                rowHeight?: number;
                colHeaderRowHeight?: number;
                colWidth?: number;
                rowHeaderColWidth?: number;
            }


            export interface ISheetNameChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                oldValue: string;
                newValue: string;
            }


            export interface ISheetNameChangingEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                oldValue: string;
                newValue: string;
                cancel: boolean;
            }


            export interface ISheetTabClickEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                sheetTabIndex: number;
            }


            export interface ISheetTabDoubleClickEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                sheetTabIndex: number;
            }


            export interface ISlicerChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                slicer: GC.Spread.Sheets.Slicers.Slicer;
                propertyName: string;
            }


            export interface ISparklineChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                sparkline: Sparklines.Sparkline;
            }


            export interface ITableFilterClearedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                table: GC.Spread.Sheets.Tables.Table;
                tableCol: number;
            }


            export interface ITableFilterClearingEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                table: GC.Spread.Sheets.Tables.Table;
                tableCol: number;
            }


            export interface ITableFilteredEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                table: GC.Spread.Sheets.Tables.Table;
                tableCol: number;
                filterValues: any[];
            }


            export interface ITableFilteringEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                table: GC.Spread.Sheets.Tables.Table;
                tableCol: number;
                filterValues: any[];
                conditionInfo: Object;
            }


            export interface ITopRowChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                oldTopRow: number;
                newTopRow: number;
            }


            export interface ITouchToolStripOpeningEventArgs{
                x: number;
                y: number;
                handled: boolean;
            }


            export interface IUserFormulaEnteredEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                formula: string;
            }


            export interface IUserZoomingEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                oldZoomFactor: number;
                newZoomFactor: number;
            }


            export interface IValidationErrorEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                validator: DataValidation.DefaultDataValidator;
                validationResult: DataValidation.DataValidationResult;
            }


            export interface IValueChangedEventArgs{
                sheet: GC.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                oldValue: any;
                newValue: any;
            }


            export interface IWorkbookHitTestInformation{
                x?: number;
                y?: number;
                worksheetHitInfo: GC.Spread.Sheets.IHitTestInformation;
                tabStripHitInfo: GC.Spread.Sheets.IIHitTestTabStripInfo;
                horizontalScrollBarHitInfo: GC.Spread.Sheets.IHitTestScrollBarInfo;
                verticalScrollBarHitInfo: GC.Spread.Sheets.IHitTestScrollBarInfo;
                footerCornerHitInfo: GC.Spread.Sheets.IHitTestFooterCornerInfo;
            }


            export interface IWorkbookOptions{
                allowUserDragMerge:boolean ; //  Whether to allow the user to drag merge cells.
                allowUserDragDrop :boolean ; // Whether to allow the user to drag and drop range data.
                allowUserDragFill :boolean ; // Whether to allow the user to drag fill a range.
                allowUserZoom :boolean ; // Whether to zoom the display by scrolling the mouse wheel while pressing the Ctrl key.
                allowUserResize :boolean ; // Whether to allow the user to resize columns and rows.
                allowUndo :boolean ; // Whether to allow the user to undo edits.
                allowSheetReorder :boolean ; // Whether the user can reorder the sheets in the Spread component.
                allowContextMenu :boolean; // Whether to allow the user to open the built-in context menu.
                allowUserDeselect :boolean; // Whether to allow the user to can use deselect in selection.
                defaultDragFillType :GC.Spread.Sheets.Fill.AutoFillType; // The default fill type.
                showDragFillSmartTag :boolean ; // Whether to display the drag fill dialog.
                showHorizontalScrollbar :boolean ; // Whether to display the horizontal scroll bar.
                showVerticalScrollbar :boolean ; // Whether to display the vertical scroll bar.
                scrollbarShowMax :boolean ; // Whether the displayed scroll bars are based on the entire number of columns and rows in the sheet.
                scrollbarMaxAlign :boolean ; // Whether the scroll bar aligns with the last row and column of the active sheet.
                tabStripVisible :boolean ; // Whether to display the sheet tab strip.
                tabStripRatio :number; // The width of the tab strip expressed as a percentage of the overall horizontal scroll bar width.
                tabEditable :boolean ; // Whether to allow the user to edit the sheet tab strip.
                newTabVisible :boolean ; // Whether the spreadsheet displays the special tab to let users insert new sheets.
                tabNavigationVisible :boolean ; // Whether to display the sheet tab navigation.
                cutCopyIndicatorVisible :boolean ; // Whether to display an indicator when copying or cutting the selected item.
                cutCopyIndicatorBorderColor :string; // The border color for the indicator displayed when the user cuts or copies the selection.
                backColor :string; // A color string used to represent the background color of the Spread component, such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.
                backgroundImage :string; // The background image of the Spread component.
                backgroundImageLayout :GC.Spread.Sheets.ImageLayout; // The background image layout for the Spread component.
                grayAreaBackColor :string; // A color string used to represent the background color of the gray area , such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.
                showResizeTip :GC.Spread.Sheets.ShowResizeTip; // How to display the resize tip.
                showDragDropTip :boolean ; // Whether to display the drag-drop tip.
                showDragFillTip :boolean ; // Whether to display the drag-fill tip.
                showScrollTip :GC.Spread.Sheets.ShowScrollTip; // How to display the scroll tip.
                scrollIgnoreHidden :boolean ; // Whether the scroll bar ignores hidden rows or columns.
                highlightInvalidData :boolean ; // Whether to highlight invalid data.
                useTouchLayout :boolean ; // Whether to use touch layout to present the Spread component.
                hideSelection :boolean ; // Whether to display the selection highlighting when the Spread component does not have focus.
                resizeZeroIndicator :GC.Spread.Sheets.ResizeZeroIndicator; // The drawing policy when the row or column is resized to zero.
                allowUserEditFormula :boolean ; // Whether the user can edit formulas in a cell in the spreadsheet.
                enableFormulaTextbox :boolean ; // Whether to enable the formula text box in the spreadsheet.
                autoFitType :GC.Spread.Sheets.AutoFitType; // Whether content will be formatted to fit in cells or in cells and headers.
                referenceStyle :GC.Spread.Sheets.ReferenceStyle; // The style for cell and range references in cell formulas on this sheet.
                calcOnDemand :boolean; // Whether to calculate formulas only when they are demanded.
                allowCopyPasteExcelStyle :boolean ; //Whether the user can copy style from Spread Sheets then paste to Excel, or copy style from Excel then paste to Spread Sheets.
                allowExtendPasteRange :boolean ; //Whether extend paste range if the paste range is not enough for pasting.
                copyPasteHeaderOptions :GC.Spread.Sheets.CopyPasteHeaderOptions; // Which headers are included when data is copied to or pasted.
            }


            export interface IWorkSheetGridlineOption{
                color?: string; //The grid line color
                showVerticalGridline?: boolean; //Whether to show the vertical grid line.
                showHorizontalGridline?: boolean; //Whether to show the horizontal grid line.
            }


            export interface IWorksheetOptions{
                allowCellOverflow: boolean; //indicates whether data can overflow into adjacent empty cells.
                sheetTabColor: string; //A color string used to represent the sheet tab color, such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.
                frozenlineColor: string; //A color string used to represent the frozen line color, such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.
                clipBoardOptions: GC.Spread.Sheets.ClipboardPasteOptions; //The clipboard option.
                gridline: GC.Spread.Sheets.IWorkSheetGridlineOption; //The grid line's options.
                rowHeaderVisible: boolean; //Indicates whether the row header is visible.
                colHeaderVisible: boolean; //Indicates whether the column header is visible.
                rowHeaderAutoText: GC.Spread.Sheets.HeaderAutoText; //Indicates whether the row header displays letters or numbers or is blank.
                colHeaderAutoText: GC.Spread.Sheets.HeaderAutoText; //Indicates whether the column header displays letters or numbers or is blank.
                rowHeaderAutoTextIndex: GC.Spread.Sheets.HeaderAutoText; //Specifies which row header column displays the automatic text when there are multiple row header columns.
                colHeaderAutoTextIndex: GC.Spread.Sheets.HeaderAutoText; //Specifies which column header row displays the automatic text when there are multiple column header rows.
                isProtected: boolean; //Indicates whether cells on this sheet that are marked as protected cannot be edited.
                protectionOptions: GC.Spread.Sheets.IProtectionOptions; //A value that indicates the elements that you want users to be able to change.
                selectionBackColor: string; //The selection's background color for the sheet.
                selectionBorderColor: string; //The selection's border color for the sheet.
            }


            export interface IWorkSheetSheetAreaOffsetOption{
                left?: number; //The offset left of sheet from host.
                top?: number; //The offset top of sheet from host
            }


            export interface SheetTabInfo{
                sheetName?: string;
                sheetIndex?: number;
            }

            /**
             * Represents whether the component automatically resizes cells or headers.
             * @enum {number}
             * @example
             * //This example uses the AutoFitType enumeration.
             * spread.options.autoFitType = GC.Spread.Sheets.AutoFitType.cellWithHeader;
             */
            export enum AutoFitType{
                /**
                 *  The component autofits cells.
                 */
                cell= 0,
                /**
                 *   The component autofits cells and headers.
                 */
                cellWithHeader= 1
            }

            /**
             * Specifies what data is pasted from the Clipboard.
             * @enum {number}
             * @example
             * //This example uses the ClipboardPasteOptions enumeration.
             * activeSheet.options.clipBoardOptions = GC.Spread.Sheets.ClipboardPasteOptions.values;
             */
            export enum ClipboardPasteOptions{
                /**
                 * Pastes all data objects, including values, formatting, and formulas.
                 */
                all= 0,
                /**
                 * Pastes only values.
                 */
                values= 1,
                /**
                 * Pastes only formatting.
                 */
                formatting= 2,
                /**
                 * Pastes only formulas.
                 */
                formulas= 3,
                /**
                 * Pastes values and formatting.
                 */
                valuesAndFormatting= 4,
                /**
                 * Pastes formulas and formatting.
                 */
                formulasAndFormatting= 5
            }

            /**
             * Specifies which headers are included when data is copied to or pasted.
             * @enum {number}
             * @example
             * //This example allows you to copy and paste headers.
             * spread.options.copyPasteHeaderOptions = GC.Spread.Sheets.CopyPasteHeaderOptions.allHeaders;
             * activeSheet.setRowCount(2,GC.Spread.Sheets.SheetArea.colHeader);
             * activeSheet.setColumnCount(2,GC.Spread.Sheets.SheetArea.rowHeader);
             * activeSheet.setValue(0, 2,"Column",GC.Spread.Sheets.SheetArea.colHeader);
             * activeSheet.setValue(1, 0,"Row",GC.Spread.Sheets.SheetArea.rowHeader);
             */
            export enum CopyPasteHeaderOptions{
                /**
                 * Includes neither column nor row headers when data is copied; does not overwrite selected column or row headers when data is pasted.
                 */
                noHeaders= 0,
                /**
                 * Includes selected row headers when data is copied; overwrites selected row headers when data is pasted.
                 */
                rowHeaders= 1,
                /**
                 * Includes selected column headers when data is copied; overwrites selected column headers when data is pasted.
                 */
                columnHeaders= 2,
                /**
                 * Includes selected headers when data is copied; overwrites selected headers when data is pasted.
                 */
                allHeaders= 3
            }

            /**
             * Specifies the copy to option.
             * @enum {number}
             * @example
             * //This example uses the CopyToOption enumeration.
             * activeSheet.getCell(0,0).value("1");
             * activeSheet.copyTo(0,0,1,1,2,2,GC.Spread.Sheets.CopyToOptions.value);
             */
            export enum CopyToOptions{
                /**
                 * Indicates the type of data is pure data.
                 */
                value= 0x01,
                /**
                 * Indicates the type of data is a formula.
                 */
                formula= 0x02,
                /**
                 * Indicates the type of data is a comment.
                 */
                comment= 0x04,
                /**
                 * Indicates to copy a range group.
                 */
                outline= 0x08,
                /**
                 * Indicates the type of data is a sparkline.
                 */
                sparkline= 0x10,
                /**
                 * Indicates to copy a span.
                 */
                span= 0x20,
                /**
                 * Indicates the type of data is a style.
                 */
                style= 0x40,
                /**
                 * Indicates the type of data is a tag.
                 */
                tag= 0x80,
                /**
                 * Indicates the type of data is a binding path.
                 */
                bindingPath= 0x100,
                /**
                 * Indicates the type of data is a conditional format.
                 */
                conditionalFormat= 0x200,
                /**
                 * Indicates all types of data.
                 */
                all= 0x3ff
            }

            /**
             * Specifies the editor status.
             * @enum {number}
             */
            export enum EditorStatus{
                /**
                 * Cell is in Ready mode.
                 */
                ready= 0,
                /**
                 * Cell is in editing mode and can commit the input value and navigate to or select other cells when invoking navigation or selection actions.
                 */
                enter= 1,
                /**
                 * Cell is in editing mode and cannot commit the input value and navigate to or select other cells.
                 */
                edit= 2
            }

            /**
             * Specifies which default labels are displayed in headers.
             * @enum {number}
             */
            export enum HeaderAutoText{
                /**
                 *  Displays blanks in the headers.
                 */
                blank= 0,
                /**
                 *  Displays numbers in the headers.
                 */
                numbers= 1,
                /**
                 *  Displays letters in the headers.
                 */
                letters= 2
            }

            /**
             * Specifies the horizontal alignment.
             * @enum {number}
             * @example
             * //This example uses the HorizontalAlign type.
             * var style = new GC.Spread.Sheets.Style();
             * style.font = "8pt Arial";
             * style.hAlign = GC.Spread.Sheets.HorizontalAlign.center;
             * style.vAlign = GC.Spread.Sheets.VerticalAlign.center;
             * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
             * activeSheet.getCell(1,1).value("B2");
             */
            export enum HorizontalAlign{
                /**
                 *  Indicates that the cell content is left-aligned.
                 */
                left= 0,
                /**
                 *  Indicates that the cell content is centered.
                 */
                center= 1,
                /**
                 *  Indicates that the cell content is right-aligned.
                 */
                right= 2,
                /**
                 *  Indicates that the horizontal alignment is based on the value type.
                 */
                general= 3
            }

            /**
             * Specifies the horizontal position of the cell or column in the component.
             * @enum {number}
             * @example
             * //This example uses the HorizontalPosition enumeration.
             * activeSheet.setActiveCell(10,5);
             * activeSheet.showCell(10, 5, GC.Spread.Sheets.VerticalPosition.top, GC.Spread.Sheets.HorizontalPosition.center);
             */
            export enum HorizontalPosition{
                /**
                 *  Positions the cell or column to the left.
                 */
                left= 0,
                /**
                 *  Positions the cell or column in the center.
                 */
                center= 1,
                /**
                 *  Positions the cell or column to the right.
                 */
                right= 2,
                /**
                 *  Positions the cell or column to the nearest edge.
                 */
                nearest= 3
            }

            /**
             * Defines the background image layout.
             * @enum {number}
             * @example
             * var rowImage = "./css/images/quarter1.png";
             * sheet.getCell(1, -1).backgroundImage(rowImage);
             * sheet.getCell(1, -1).backgroundImageLayout(GC.Spread.Sheets.ImageLayout.center);
             */
            export enum ImageLayout{
                /** Specifies that the background image fills the area.
                 * @type {number}
                 */
                stretch= 0,
                /** Specifies that the background image displays in the center of the area.
                 * @type {number}
                 */
                center= 1,
                /** Specifies that the background image displays in the area with its original aspect ratio.
                 * @type {number}
                 */
                zoom= 2,
                /** Specifies that the background image displays in the upper left corner of the area with its original size.
                 * @type {number}
                 */
                none= 3
            }

            /**
             * Defines the IME mode to control the state of the Input Method Editor (IME).
             * @enum {number}
             * @example
             * //This example uses the imeMode method.
             * activeSheet.getRange(-1, 2, -1, 1).imeMode(GC.Spread.Sheets.ImeMode.auto);
             */
            export enum ImeMode{
                /**
                 * No change is made to the current input method editor state.
                 */
                auto= 0x01,
                /** All characters are entered through the IME. Users can still deactivate the IME.
                 */
                active= 0x02,
                /**
                 * All characters are entered without IME. Users can still activate the IME.
                 */
                inactive= 0x04,
                /**
                 * The input method editor is disabled and may not be activated by the user.
                 */
                disabled= 0x00
            }

            /**
             * Identifies which operation was invalid.
             * @enum {number}
             * @example
             * //This example gets the invalid type.
             * activeSheet.getCell(1,1).locked(true);
             * activeSheet.options.isProtected = true;
             * activeSheet.getCell(1,1).value(2);
             * //Bind event
             * activeSheet.bind(GC.Spread.Sheets.Events.InvalidOperation, function (e, info) {
             *         alert("Message (" + info.invalidType + ")");
             * });
             */
            export enum InvalidOperationType{
                /**
                 * Specifes the formula is invalid.
                 */
                setFormula= 0,
                /**
                 * Specifies the copy paste is invalid.
                 */
                copyPaste= 1,
                /**
                 * Specifies the drag fill is invalid.
                 */
                dragFill= 2,
                /**
                 * Specifies the drag drop is invalid.
                 */
                dragDrop= 3,
                /**
                 * Specifies the insert row is invalid.
                 */
                changePartOfArrayFormula= 4,
                /**
                 * Specifies the changed sheet name is invalid.
                 */
                changeSheetName= 5
            }

            /**
             * Specifies the cell label position.
             * @enum {number}
             * @example
             * //This example sets cell padding, alignment, and other options.
             * var type = new GC.Spread.Sheets.Style();
             * type.watermark = "User name";
             * type.cellPadding = "20";
             * type.labelOptions = {alignment:GC.Spread.Sheets.LabelAlignment.topLeft, visibility: GC.Spread.Sheets.LabelVisibility.visible};
             * activeSheet.setStyle(0, 1, type);
             * activeSheet.getRange(0, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).height(60);
             * activeSheet.getRange(-1, 1, -1, 1).width(150);
             * var combo = new GC.Spread.Sheets.CellTypes.ComboBox();
             * combo.items([{ text: "Oranges", value: "11k" }, { text: "Apples", value: "15k" }, { text: "Grape", value: "100k" }]);
             * combo.editorValueType(GC.Spread.Sheets.CellTypes.EditorValueType.text);
             * activeSheet.setCellType(2, 1, combo, GC.Spread.Sheets.SheetArea.viewport);
             * activeSheet.getCell(2, 1, GC.Spread.Sheets.SheetArea.viewport).watermark("ComboBox Cell Type").cellPadding('10 10 20 10');
             * activeSheet.getCell(2, 1, GC.Spread.Sheets.SheetArea.viewport).labelOptions({alignment: GC.Spread.Sheets.LabelAlignment.bottomCenter, foreColor: 'yellowgreen', font: 'bold 15px Arial'});
             * activeSheet.getRange(2, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).height(60);
             */
            export enum LabelAlignment{
                /**
                 *  Indicates that the cell label position is top-left.
                 */
                topLeft= 0,
                /**
                 *  Indicates that the cell label position is top-center.
                 */
                topCenter= 1,
                /**
                 *  Indicates that the cell label position is top-right.
                 */
                topRight= 2,
                /**
                 *  Indicates that the cell label position is bottom-left.
                 */
                bottomLeft= 3,
                /**
                 *  Indicates that the cell label position is bottom-center.
                 */
                bottomCenter= 4,
                /**
                 *  Indicates that the cell label position is bottom-right.
                 */
                bottomRight= 5
            }

            /**
             * Specifies the cell label visibility.
             * @enum {number}
             * @example
             * //This example sets label options for the watermark.
             * var type = new GC.Spread.Sheets.Style();
             * type.watermark = "User name";
             * type.cellPadding = "20";
             * type.labelOptions = {alignment:GC.Spread.Sheets.LabelAlignment.topLeft, visibility: GC.Spread.Sheets.LabelVisibility.visible};
             * activeSheet.setStyle(0, 1, type);
             * activeSheet.getRange(0, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).height(60);
             * activeSheet.getRange(-1, 1, -1, 1).width(150);
             * var combo = new GC.Spread.Sheets.CellTypes.ComboBox();
             * combo.items([{ text: "Oranges", value: "11k" }, { text: "Apples", value: "15k" }, { text: "Grape", value: "100k" }]);
             * combo.editorValueType(GC.Spread.Sheets.CellTypes.EditorValueType.text);
             * activeSheet.setCellType(2, 1, combo, GC.Spread.Sheets.SheetArea.viewport);
             * activeSheet.getCell(2, 1, GC.Spread.Sheets.SheetArea.viewport).watermark("ComboBox Cell Type").cellPadding('10 10 20 10');
             * activeSheet.getCell(2, 1, GC.Spread.Sheets.SheetArea.viewport).labelOptions({alignment: GC.Spread.Sheets.LabelAlignment.bottomCenter, foreColor: 'yellowgreen', font: 'bold 15px Arial'});
             * activeSheet.getRange(2, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).height(60);
             */
            export enum LabelVisibility{
                /**
                 *  Specifies to always show the watermark in the padding area and not to show the watermark in the cell area, regardless of the cell value.
                 */
                visible= 0,
                /**
                 *  Specifies to not show the watermark in the padding area, but to show the watermark in the cell area based on a value condition.
                 */
                hidden= 1,
                /**
                 *  Specifies to show the watermark in the padding area when the cell has a value or to show the watermark in the cell area if the cell does not have a value.
                 */
                auto= 2
            }

            /**
             * Specifies the line drawing style for the border.
             * @enum {number}
             * @example
             * //This example creates a border.
             * var border = new GC.Spread.Sheets.LineBorder
             * border.color = "#7FFFD4";
             * border.style = GC.Spread.Sheets.LineStyle.double;
             * var cell = activeSheet.getCell(1, 1, GC.Spread.Sheets.SheetArea.viewport);
             * cell.borderLeft(border);
             */
            export enum LineStyle{
                /**
                 * Indicates a border line without a style.
                 */
                empty= 0,
                /**
                 *  Indicates a border line with a solid thin line.
                 */
                thin= 1,
                /**
                 *  Indicates a medium border line with a solid line.
                 */
                medium= 2,
                /**
                 *  Indicates a border line with dashes.
                 */
                dashed= 3,
                /**
                 *  Indicates a border line with dots.
                 */
                dotted= 4,
                /**
                 *  Indicates a thick border line with a solid line.
                 */
                thick= 5,
                /**
                 *  Indicates a double border line.
                 */
                double= 6,
                /**
                 *  Indicates a border line with all dots.
                 */
                hair= 7,
                /**
                 *  Indicates a medium border line with dashes.
                 */
                mediumDashed= 8,
                /**
                 *  Indicates a border line with dash-dot.
                 */
                dashDot= 9,
                /**
                 *  Indicates a medium border line with dash-dot-dot.
                 */
                mediumDashDot= 10,
                /**
                 *  Indicates a border line with dash-dot-dot.
                 */
                dashDotDot= 11,
                /**
                 *  Indicates a medium border line with dash-dot-dot.
                 */
                mediumDashDotDot= 12,
                /**
                 *  Indicates a slanted border line with dash-dot.
                 */
                slantedDashDot= 13
            }

            /**
             * Defines the type of action that raised the RangeChanged event.
             * @enum {number}
             */
            export enum RangeChangedAction{
                /**
                 * Indicates drag drop undo action.
                 */
                dragDrop= 0,
                /**
                 * Indicates drag fill undo action.
                 */
                dragFill= 1,
                /**
                 * Indicates clear range value undo action.
                 */
                clear= 2,
                /**
                 * Indicates paste undo action.
                 */
                paste= 3,
                /**
                 * Indicates sorting a range of cells.
                 */
                sort= 4,
                /**
                 * Indicates setting a formula in a specified range of cells .
                 */
                setArrayFormula= 5,
                /**
                 * Indicates setting a formula in a specified range of cells .
                 */
                evaluateFormula= 6
            }

            /**
             * Specifies the formula reference style.
             * @enum {number}
             * @example
             * //This example sets the reference style for the active sheet.
             * activeSheet.options.referenceStyle = GC.Spread.Sheets.ReferenceStyle.r1c1;
             */
            export enum ReferenceStyle{
                /**
                 * Indicates a1 style.
                 */
                a1= 0,
                /**
                 * Indicates r1c1 style.
                 */
                r1c1= 1
            }

            /**
             * Specifies the drawing policy of the row or column when it is resized to zero.
             * @enum {number}
             * @example
             * //This example displays double grid lines for the column or row with zero width or height.
             * spread.options.resizeZeroIndicator = GC.Spread.Sheets.ResizeZeroIndicator.enhanced;
             * activeSheet.getRange(-1, 2, -1, 1).width(0);
             * activeSheet.getRange(1, -1, 1, -1).height(0);
             */
            export enum ResizeZeroIndicator{
                /**
                 *  Uses the current drawing policy when the row or column is resized to zero.
                 */
                default= 0,
                /**
                 * Draws two short lines when the row or column is resized to zero.
                 */
                enhanced= 1
            }

            /**
             * Specifies how users can select items in the control.
             * @enum {number}
             * @example
             * //This example sets the selection policy.
             * activeSheet.selectionUnit(GC.Spread.Sheets.SelectionUnit.row);
             * activeSheet.selectionPolicy(GC.Spread.Sheets.SelectionPolicy.range);
             */
            export enum SelectionPolicy{
                /**
                 * Allows users to only select single items.
                 */
                single= 0,
                /**
                 * Allows users to select single items and ranges of items, but not multiple ranges.
                 */
                range= 1,
                /**
                 * Allows users to select single items and ranges of items, including multiple ranges.
                 */
                multiRange= 2
            }

            /**
             * Specifies the smallest unit users or the application can select.
             * @enum {number}
             * @example
             * //This example sets the unit type.
             * activeSheet.selectionUnit(GC.Spread.Sheets.SelectionUnit.row);
             * activeSheet.selectionPolicy(GC.Spread.Sheets.SelectionPolicy.range);
             */
            export enum SelectionUnit{
                /**
                 * Indicates that the smallest unit that can be selected is a cell.
                 */
                cell= 0,
                /**
                 * Indicates that the smallest unit that can be selected is a row.
                 */
                row= 1,
                /**
                 * Indicates that the smallest unit that can be selected is a column.
                 */
                column= 2
            }

            /**
             * Specifies the sheet area.
             * @enum {number}
             * @example
             * //Creates log text describing which area in the sheet was clicked.
             * // Use IE to see the console log text
             * activeSheet.bind(GC.Spread.Sheets.Events.CellClick, function (sender, args) {
             *     if(args.sheetArea === GC.Spread.Sheets.SheetArea.colHeader){
             *         console.log("The column header was clicked.");
             *     }
             *     if(args.sheetArea === GC.Spread.Sheets.SheetArea.rowHeader){
             *         console.log("The row header was clicked.");
             *     }
             *     if(args.sheetArea === GC.Spread.Sheets.SheetArea.corner){
             *         console.log("The corner header was clicked.");
             *     }
             *     console.log("Clicked column index: " + args.col);
             *     console.log("Clicked row index: " + args.row);
             * });
             * //Bind event
             * activeSheet.bind(GC.Spread.Sheets.Events.CellDoubleClick, function (sender, args) {
             *     if(args.sheetArea === GC.Spread.Sheets.SheetArea.colHeader){
             *         console.log("The column header was double clicked.");
             *     }
             *     if(args.sheetArea === GC.Spread.Sheets.SheetArea.rowHeader){
             *         console.log("The row header was double clicked.");
             *     }
             *     if(args.sheetArea === GC.Spread.Sheets.SheetArea.corner){
             *         console.log("The corner header was double clicked.");
             *     }
             *     console.log("Double clicked column index: " + args.col);
             *     console.log("Double clicked row index: " + args.row);
             * });
             */
            export enum SheetArea{
                /**
                 * Indicates the sheet corner.
                 */
                corner= 0,
                /**
                 * Indicates the column header.
                 */
                colHeader= 1,
                /**
                 * Indicates the row header.
                 */
                rowHeader= 2,
                /**
                 * Indicates the viewport.
                 */
                viewport= 3
            }

            /**
             * Defines how the resize tip is displayed.
             * @enum {number}
             * @example
             * //This example displays both resize tips.
             * spread.options.showDragDropTip = true;
             * spread.options.showDragFillTip = true;
             * spread.options.showScrollTip = GC.Spread.Sheets.ShowScrollTip.both;
             * spread.options.showResizeTip = GC.Spread.Sheets.ShowResizeTip.both;
             */
            export enum ShowResizeTip{
                /** Specifies that no resize tip is displayed.
                 * @type {number}
                 */
                none= 0,
                /** Specifies that only the horizontal resize tip is displayed.
                 * @type {number}
                 */
                column= 1,
                /** Specifies that only the vertical resize tip is displayed.
                 * @type {number}
                 */
                row= 2,
                /** Specifies that horizontal and vertical resize tips are displayed.
                 * @type {number}
                 */
                both= 3
            }

            /**
             * Specifies how the scroll tip is displayed.
             * @enum {number}
             * @example
             * //This example displays both resize tips.
             * spread.options.showDragDropTip = true;
             * spread.options.showDragFillTip = true;
             * spread.options.showScrollTip = GC.Spread.Sheets.ShowScrollTip.both;
             * spread.options.showResizeTip = GC.Spread.Sheets.ShowResizeTip.both;
             */
            export enum ShowScrollTip{
                /** Specifies that no scroll tip is displayed.
                 * @type {number}
                 */
                none= 0,
                /** Specifies that only the horizontal scroll tip is displayed.
                 * @type {number}
                 */
                horizontal= 1,
                /** Specifies that only the vertical scroll tip is displayed.
                 * @type {number}
                 */
                vertical= 2,
                /** Specifies that horizontal and vertical scroll tips are displayed.
                 * @type {number}
                 */
                both= 3
            }

            /**
             * Specifies the type of sorting to perform.
             * @enum {number}
             * @example
             * //This example sets the sort order of the items in the slicer.
             * //create a table
             * datas = [
             *     ["1", "NewYork", "1968/6/8", "80", "180"],
             *     ["4", "NewYork", "1972/7/3", "72", "168"],
             *     ["4", "NewYork", "1964/3/2", "71", "179"],
             *     ["5", "Washington", "1972/8/8","80", "171"],
             *     ["6", "Washington", "1986/2/2", "89", "161"],
             *     ["7", "Washington", "2012/2/15", "71", "240"]];
             * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
             * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
             * table.setColumnName(0, dataColumns[0]);
             * table.setColumnName(1, dataColumns[1]);
             * table.setColumnName(2, dataColumns[2]);
             * table.setColumnName(3, dataColumns[3]);
             * table.setColumnName(4, dataColumns[4]);
             * //create style
             * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.light4();
             * //add a slicer to the sheet and return the slicer instance
             * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Height");
             * //set slicer properties
             * slicer.position(new GC.Spread.Sheets.Point(100, 200));
             * slicer.sortState(GC.Spread.Sheets.SortState.descending);
             * slicer.style(style1);
             */
            export enum SortState{
                /** Indicates the sorting is disabled.
                 * @type {number}
                 */
                none= 0,
                /** Indicates the sorting is ascending.
                 * @type {number}
                 */
                ascending= 1,
                /** Indicates the sorting is descending.
                 * @type {number}
                 */
                descending= 2
            }

            /**
             * Represents the storage data type.
             * @enum {number}
             * @example
             * //This example uses the StorageType enumeration.
             * activeSheet.getCell(0,0).value("A1");
             * activeSheet.clear(0,0,3,3,GC.Spread.Sheets.SheetArea.viewport,GC.Spread.Sheets.StorageType.data);
             */
            export enum StorageType{
                /**
                 *  Indicates the storage data type is pure value.
                 */
                data= 0x01,
                /**
                 *  Indicates the storage data type is style.
                 */
                style= 0x02,
                /**
                 *  Indicates the storage data type is comment.
                 */
                comment= 0x04,
                /**
                 *  Indicates the storage data type is tag.
                 */
                tag= 0x08,
                /**
                 *  Indicates the storage data type is sparkline.
                 */
                sparkline= 0x10,
                /**
                 *  Indicates the storage data type is the axis information.
                 */
                axis= 0x20,
                /**
                 *  Indicates the storage data type is data binding path.
                 */
                bindingPath= 0x40
            }

            /**
             * Defines the type of the text decoration.
             * @enum {number}
             * @example
             * //This example uses the TextDecorationType enumeration.
             * activeSheet.getCell(0, 0).textDecoration(GC.Spread.Sheets.TextDecorationType.underline);
             * activeSheet.getRange(1, -1, 1, -1).textDecoration(GC.Spread.Sheets.TextDecorationType.overline | GC.Spread.Sheets.TextDecorationType.underline);
             * activeSheet.getRange(-1, 1, -1, 1).textDecoration(GC.Spread.Sheets.TextDecorationType.overline | GC.Spread.Sheets.TextDecorationType.lineThrough | GC.Spread.Sheets.TextDecorationType.underline);
             * var style = new GC.Spread.Sheets.Style();
             * style.textDecoration = GC.Spread.Sheets.TextDecorationType.overline | GC.Spread.Sheets.TextDecorationType.underline;
             * activeSheet.setStyle(1, 1, style, GC.Spread.Sheets.SheetArea.viewport);
             * activeSheet.getCell(0, 0).value("Test");
             * activeSheet.getCell(1, 0).value("Test");
             * activeSheet.getCell(0, 1).value("Test");
             */
            export enum TextDecorationType{
                /** Specifies to display a line below the text.
                 */
                underline= 1,
                /** Specifies to display a line through the text.
                 */
                lineThrough= 2,
                /** Specifies to display a line above the text.
                 */
                overline= 4,
                /** Specifies to display double line below the text.
                 */
                doubleUnderline= 8,
                /** Specifies normal text.
                 */
                none= 0
            }

            /**
             * Specifies cell value's type.
             * @enum {number}
             */
            export enum ValueType{
                /**
                 *  indicate normal value type.
                 */
                normal= 0,
                /**
                 *  indicate rich text value type.
                 */
                richText= 1
            }

            /**
             * Defines the type of the text vertAlign.
             * @enum {number}
             * @example
             * //This example uses the VertAlign enumeration.
             * activeSheet.setValue(1, 1, {richText:[{style:{vertAlign:GC.Spread.Sheets.Style.VertAlign.subscript},text:'SpreadJS'}]}, GC.Spread.Sheets.SheetArea.viewport);
             */
            export enum VertAlign{
                /**
                 *  indicate normal text align.
                 */
                normal= 0,
                /**
                 *  indicate superscript.
                 */
                superscript= 1,
                /**
                 *  indicate subscript.
                 */
                subscript= 2
            }

            /**
             * Specifies the vertical alignment.
             * @enum {number}
             * @example
             * //This example uses the VerticalAlign type.
             * var style = new GC.Spread.Sheets.Style();
             * style.font = "8pt Arial";
             * style.hAlign = GC.Spread.Sheets.HorizontalAlign.center;
             * style.vAlign = GC.Spread.Sheets.VerticalAlign.center;
             * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
             * activeSheet.getCell(1,1).value("B2");
             */
            export enum VerticalAlign{
                /**
                 *  Indicates that the cell content is top-aligned.
                 */
                top= 0,
                /**
                 *  Indicates that the cell content is centered.
                 */
                center= 1,
                /**
                 *  Indicates that the cell content is bottom-aligned.
                 */
                bottom= 2
            }

            /**
             * Specifies the vertical position of the cell or row in the component.
             * @enum {number}
             * @example
             * //This example uses the VerticalPosition enumeration.
             * activeSheet.setActiveCell(10,5);
             * activeSheet.showCell(10, 5, GC.Spread.Sheets.VerticalPosition.top, GC.Spread.Sheets.HorizontalPosition.center);
             */
            export enum VerticalPosition{
                /**
                 *  Positions the cell or row at the top.
                 */
                top= 0,
                /**
                 *  Positions the cell or row in the center.
                 */
                center= 1,
                /**
                 *  Positions the cell or row at the bottom.
                 */
                bottom= 2,
                /**
                 *  Positions the cell or row at the nearest edge.
                 */
                nearest= 3
            }

            /**
             * Specifies the visual state.
             * @enum {number}
             */
            export enum VisualState{
                /**
                 * Indicates normal visual state.
                 */
                normal= 0,
                /**
                 * Indicates highlight visual state.
                 */
                highlight= 1,
                /**
                 * Indicates selected visual state.
                 */
                selected= 2,
                /**
                 * Indicates active visual state.
                 */
                active= 3,
                /**
                 * Indicates hover visual state.
                 */
                hover= 4
            }


            export class CellRange{
                /**
                 * Represents a cell range in a sheet.
                 * @class
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that contains this cell range.
                 * @param {number} row The row index of the cell.
                 * @param {number} col The column index of the cell.
                 * @param {number} rowCount The row count of the cell. If you do not provide this parameter, it defaults to <b>1</b>.
                 * @param {number} colCount The column count of the cell. If you do not provide this parameter, it defaults to <b>1</b>.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If you do not provide this parameter, it defaults to <b>viewport</b>.
                 * If row is -1 and rowCount is -1, the range represents columns. For example, new GC.Spread.Sheets.CellRange(-1,4,-1,6) represents columns "E:J".
                 * If col is -1 and colCount is -1, the range represents rows. For example, new GC.Spread.Sheets.CellRange(4,-1,6,-1) represents rows "5:10".
                 */
                constructor(sheet:  GC.Spread.Sheets.Worksheet,  row:  number,  col:  number,  rowCount?:  number,  colCount?:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea);
                /**
                 * Gets the starting column index.
                 * @type {number}
                 */
                col: number;
                /**
                 * Gets the column count.
                 * @type {number}
                 */
                colCount: number;
                /**
                 * Gets the starting row index.
                 *@type {number}
                 */
                row: number;
                /**
                 * Gets the row count.
                 * @type {number}
                 */
                rowCount: number;
                /**
                 * Gets the sheet that contains this cell range.
                 * @type {GC.Spread.Sheets.Worksheet}
                 */
                sheet: GC.Spread.Sheets.Worksheet;
                /**
                 * Gets the area that contains this cell range.
                 * @type {GC.Spread.Sheets.SheetArea}
                 */
                sheetArea: GC.Spread.Sheets.SheetArea;
                /**
                 * Gets or sets the background color for the cell, such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.
                 * @param {string} value The cell background color.
                 * @returns {string|GC.Spread.Sheets.CellRange} If no value is set, returns the cell background color; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GC.Spread.Sheets.SheetArea.viewport).backColor("pink");
                 */
                backColor(value?:  string): any;
                /**
                 * Gets or sets the background image for the cell.
                 * @param {string} value The cell background image.
                 * @returns {string|GC.Spread.Sheets.CellRange} If no value is set, returns the cell background image; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(1,1).backgroundImage("images/example.jpg");
                 */
                backgroundImage(value?:  string): any;
                /**
                 * Gets or sets the background image layout for the cell.
                 * @param {GC.Spread.Sheets.ImageLayout} value The cell background image layout.
                 * @returns {GC.Spread.Sheets.ImageLayout|GC.Spread.Sheets.CellRange} If no value is set, returns the cell background image layout; otherwise, returns the cell.
                 * @example
                 * var layout = GC.Spread.Sheets.ImageLayout.stretch;
                 * activeSheet.getRange(-1, 1, -1, 1, GC.Spread.Sheets.SheetArea.viewport).backgroundImageLayout(layout);
                 */
                backgroundImageLayout(value?:  GC.Spread.Sheets.ImageLayout): any;
                /**
                 * Gets or sets the binding path for cell binding.
                 * @param {string} path The binding path for cell binding.
                 * @returns {string | GC.Spread.Sheets.Worksheet} If no value is set, returns the binding path for cell binding; otherwise, returns the worksheet.
                 * @example
                 * //This example uses the bindingPath method.
                 * var test = {name: "John"};
                 * activeSheet.getCell(0,0).bindingPath( "name");
                 * activeSheet.setDataSource(new GC.Spread.Sheets.Bindings.CellBindingSource(test));
                 */
                bindingPath(path?:  string): any;
                /**
                 * Gets or sets the bottom border of the cell.
                 * @param {GC.Spread.Sheets.LineBorder} value The cell bottom border line.
                 * @returns {GC.Spread.Sheets.LineBorder|GC.Spread.Sheets.CellRange} If no value is set, returns the cell bottom border line; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GC.Spread.Sheets.SheetArea.viewport).borderBottom(new GC.Spread.Sheets.LineBorder("blue", GC.Spread.Sheets.LineStyle.mediumDashed));
                 */
                borderBottom(value?:  GC.Spread.Sheets.LineBorder): any;
                /**
                 * Gets or sets the left border of the cell.
                 * @param {GC.Spread.Sheets.LineBorder} value The cell left border line.
                 * @returns {GC.Spread.Sheets.LineBorder|GC.Spread.Sheets.CellRange} If no value is set, returns the cell left border line; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(2, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).borderLeft(new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.mediumDashed));
                 * @example
                 * activeSheet.getCell(1,1).borderLeft(new GC.Spread.Sheets.LineBorder("red", GC.Spread.Sheets.LineStyle.double));
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GC.Spread.Sheets.SheetArea.viewport).borderLeft(new GC.Spread.Sheets.LineBorder("blue", GC.Spread.Sheets.LineStyle.mediumDashed));
                 */
                borderLeft(value?:  GC.Spread.Sheets.LineBorder): any;
                /**
                 * Gets or sets the right border of the cell.
                 * @param {GC.Spread.Sheets.LineBorder} value The cell right border line.
                 * @returns {GC.Spread.Sheets.LineBorder|GC.Spread.Sheets.CellRange} If no value is set, returns the cell right border line; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(2, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).borderRight(new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.mediumDashed));
                 * @example
                 * activeSheet.getCell(1,1).borderRight(new GC.Spread.Sheets.LineBorder("red", GC.Spread.Sheets.LineStyle.double));
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GC.Spread.Sheets.SheetArea.viewport).borderRight(new GC.Spread.Sheets.LineBorder("blue", GC.Spread.Sheets.LineStyle.mediumDashed));
                 */
                borderRight(value?:  GC.Spread.Sheets.LineBorder): any;
                /**
                 * Gets or sets the top border of the cell.
                 * @param {GC.Spread.Sheets.LineBorder} value The cell top border line.
                 * @returns {GC.Spread.Sheets.LineBorder|GC.Spread.Sheets.CellRange} If no value is set, returns the cell top border line; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(2, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).borderTop(new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.mediumDashed));
                 * @example
                 * activeSheet.getCell(1,1).borderTop(new GC.Spread.Sheets.LineBorder("red", GC.Spread.Sheets.LineStyle.double));
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GC.Spread.Sheets.SheetArea.viewport).borderTop(new GC.Spread.Sheets.LineBorder("blue", GC.Spread.Sheets.LineStyle.mediumDashed));
                 */
                borderTop(value?:  GC.Spread.Sheets.LineBorder): any;
                /**
                 * Gets or sets the cell padding.
                 * @param {string} value The cell padding.
                 * @returns {string|GC.Spread.Sheets.CellRange} If no value is set, returns the value of the cell padding; otherwise, returns the cell.
                 * @example
                 * // This example adds cell padding around the watermark.
                 * var type = new GC.Spread.Sheets.Style();
                 * type.watermark = "User name";
                 * type.cellPadding = "20";
                 * type.labelOptions = {alignment:GC.Spread.Sheets.LabelAlignment.topLeft, visibility: GC.Spread.Sheets.LabelVisibility.visible};
                 * activeSheet.setStyle(0, 1, type);
                 * activeSheet.getRange(0, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).height(60);
                 * activeSheet.getRange(-1, 1, -1, 1).width(150);
                 * var combo = new GC.Spread.Sheets.CellTypes.ComboBox();
                 * combo.items([{ text: "Oranges", value: "11k" }, { text: "Apples", value: "15k" }, { text: "Grape", value: "100k" }]);
                 * combo.editorValueType(GC.Spread.Sheets.CellTypes.EditorValueType.text);
                 * activeSheet.setCellType(2, 1, combo, GC.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(2, 1, GC.Spread.Sheets.SheetArea.viewport).watermark("ComboBox Cell Type").cellPadding('10 10 20 10');
                 * activeSheet.getCell(2, 1, GC.Spread.Sheets.SheetArea.viewport).labelOptions({alignment: GC.Spread.Sheets.LabelAlignment.bottomCenter, foreColor: 'yellowgreen', font: 'bold 15px Arial'});
                 * activeSheet.getRange(2, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).height(60);
                 */
                cellPadding(value?:  string): any;
                /**
                 * Gets or sets the cell type of the cell.
                 * @param {GC.Spread.Sheets.CellTypes.Base} value The cell type.
                 * @returns {GC.Spread.Sheets.CellTypes.Base|GC.Spread.Sheets.CellRange} If no value is set, returns the cell type; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 1, -1, 1, GC.Spread.Sheets.SheetArea.viewport).cellType(new GC.Spread.Sheets.CellTypes.CheckBox());
                 */
                cellType(value?:  GC.Spread.Sheets.CellTypes.Base): any;
                /**
                 * Clears the specified area.
                 * @param {GC.Spread.Sheets.StorageType} type The clear type.
                 */
                clear(type:  GC.Spread.Sheets.StorageType): void;
                /**
                 * Gets or sets the comment for the cell.
                 * @param {GC.Spread.Sheets.Comments.Comment} value The comment to set in the cell.
                 * @returns {GC.Spread.Sheets.Comments.Comment} If no value is set, returns the comment in the cell; otherwise, returns the cell range.
                 * @example
                 * // This example creates a cell comment.
                 * var comment = new GC.Spread.Sheets.Comments.Comment();
                 * comment.text("new comment!");
                 * comment.backColor("yellow");
                 * comment.foreColor("green");
                 * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                 * activeSheet.getCell(5,5).comment(comment);
                 */
                comment(value?:  GC.Spread.Sheets.Comments.Comment): any;
                /**
                 * Gets or sets the diagonalDown of the cell.
                 * @param {GC.Spread.Sheets.LineBorder} value The cell diagonalDown line.
                 * @returns {GC.Spread.Sheets.LineBorder|GC.Spread.Sheets.CellRange} If no value is set, returns the cell diagonalDown line; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GC.Spread.Sheets.SheetArea.viewport).diagonalDown(new GC.Spread.Sheets.LineBorder("blue", GC.Spread.Sheets.LineStyle.mediumDashed));
                 */
                diagonalDown(value?:  GC.Spread.Sheets.LineBorder): any;
                /**
                 * Gets or sets the diagonalUp of the cell.
                 * @param {GC.Spread.Sheets.LineBorder} value The cell diagonalUp line.
                 * @returns {GC.Spread.Sheets.LineBorder|GC.Spread.Sheets.CellRange} If no value is set, returns the cell diagonalUp line; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GC.Spread.Sheets.SheetArea.viewport).diagonalUp(new GC.Spread.Sheets.LineBorder("blue", GC.Spread.Sheets.LineStyle.mediumDashed));
                 */
                diagonalUp(value?:  GC.Spread.Sheets.LineBorder): any;
                /**
                 * Gets or sets the font for the cell, such as "normal normal normal 20px/normal Arial".
                 * @param {string} value The cell font.
                 * @returns {string|GC.Spread.Sheets.CellRange} If no value is set, returns the cell's font; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(2, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).font("12pt Arial");
                 * @example
                 * activeSheet.getCell(1,1).font("8pt Arial");
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GC.Spread.Sheets.SheetArea.viewport).font("12pt Arial");
                 */
                font(value?:  string): any;
                /**
                 * Gets or sets the color of the text in the cell, such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.
                 * @param {string} value The color of the text.
                 * @returns {string|GC.Spread.Sheets.CellRange} If no value is set, returns the cell foreground color; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GC.Spread.Sheets.SheetArea.viewport).foreColor("blue");
                 */
                foreColor(value?:  string): any;
                /**
                 * Gets or sets the formatter for the cell.
                 * @param {string | GC.Spread.Formatter.GeneralFormatter} value The cell formatter string or object.
                 * @returns {string | GC.Spread.Formatter.GeneralFormatter |GC.Spread.Sheets.CellRange} If no value is set, returns the cell formatter string or object; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(1,1).formatter("0.000%");
                 * @example
                 * activeSheet.getCell(1, -1).formatter("0.000%");
                 * activeSheet.getCell(1,0).value("2");
                 * @example
                 * activeSheet.getCell(-1, 0).formatter("0.000%");
                 * activeSheet.getCell(0,0).value("2");
                 */
                formatter(value?:  any): any;
                /**
                 * Gets or sets the formula for the cell.
                 * @param {string} value The cell formula.
                 * @returns {string|GC.Spread.Sheets.CellRange} If no value is set, returns the cell formula; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(0,2).formula("DATEDIF(DATE(2003,1,1),DATE(2016,1,1),\"Y\")");
                 */
                formula(value?:  string): any;
                /**
                 * Gets or sets the horizontal alignment of the contents of the cell.
                 * @param {GC.Spread.Sheets.HorizontalAlign} value The horizontal alignment.
                 * @returns {GC.Spread.Sheets.HorizontalAlign|GC.Spread.Sheets.CellRange} If no value is set, returns the horizontal alignment of the contents of the cell; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GC.Spread.Sheets.SheetArea.viewport).hAlign(GC.Spread.Sheets.HorizontalAlign.right);
                 */
                hAlign(value?:  GC.Spread.Sheets.HorizontalAlign): any;
                /**
                 * Gets or sets the height of the row in pixels.
                 * @param {number} value The cell row height.
                 * @returns {number|GC.Spread.Sheets.CellRange} If no value is set, returns the row height; otherwise, returns the row.
                 * @example
                 * activeSheet.getRange(0, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).height(90);
                 */
                height(value?:  number): any;
                /**
                 * Gets or sets the imeMode of the cell.
                 * @param {GC.Spread.Sheets.ImeMode} value The cell imeMode.
                 * @returns {GC.Spread.Sheets.ImeMode|GC.Spread.Sheets.CellRange} If no value is set, returns the cell imeMode; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(0, 0).imeMode(GC.Spread.Sheets.ImeMode.disabled);
                 * //or
                 * var style = new GC.Spread.Sheets.Style();
                 * style.imeMode = GC.Spread.Sheets.ImeMode.disabled;
                 * activeSheet.setStyle(0, 0, style);
                 * @example
                 * activeSheet.getRange(2, -1, 1, -1).imeMode(GC.Spread.Sheets.ImeMode.active);
                 * @example
                 * activeSheet.getRange(-1, 2, -1, 1).imeMode(GC.Spread.Sheets.ImeMode.auto);
                 */
                imeMode(value?:  GC.Spread.Sheets.ImeMode): any;
                /**
                 * Gets or sets whether the cell's text is vertical.
                 * @param {boolean} value Set to <c>true</c> to have the cell's text vertical.
                 * @returns {boolean|GC.Spread.Sheets.CellRange} If no value is set, returns whether the cell's text vertical; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(2,-1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).isVerticalText(false);
                 * activeSheet.setText(2,0,"This is a test");
                 * @example
                 * activeSheet.getCell(1,1).isVerticalText(true);
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GC.Spread.Sheets.SheetArea.viewport).isVerticalText(true);
                 */
                isVerticalText(value?:  boolean): any;
                /**
                 * Gets or sets the cell label options.
                 * @param {Object} value The cell label options.
                 * @param {GC.Spread.Sheets.LabelAlignment} [value.alignment] - The cell label position.
                 * @param {GC.Spread.Sheets.LabelVisibility} [value.visibility] - The cell label visibility.
                 * @param {string} [value.font] - The cell label font.
                 * @param {string} [value.foreColor] - The cell label forecolor.
                 * @param {string} [value.margin] - The cell label margin.
                 * @returns {Object|GC.Spread.Sheets.CellRange} If no value is set, returns the value of the cell label options; otherwise, returns the cell.
                 * @example
                 * //This example sets label options for the watermark.
                 * var type = new GC.Spread.Sheets.Style();
                 * type.watermark = "User name";
                 * type.cellPadding = "20";
                 * type.labelOptions = {alignment:GC.Spread.Sheets.LabelAlignment.topLeft, visibility: GC.Spread.Sheets.LabelVisibility.visible};
                 * activeSheet.setStyle(0, 1, type);
                 * activeSheet.getRange(0, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).height(60);
                 * activeSheet.getRange(-1, 1, -1, 1).width(150);
                 * var combo = new GC.Spread.Sheets.CellTypes.ComboBox();
                 * combo.items([{ text: "Oranges", value: "11k" }, { text: "Apples", value: "15k" }, { text: "Grape", value: "100k" }]);
                 * combo.editorValueType(GC.Spread.Sheets.CellTypes.EditorValueType.text);
                 * activeSheet.setCellType(2, 1, combo, GC.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(2, 1, GC.Spread.Sheets.SheetArea.viewport).watermark("ComboBox Cell Type").cellPadding('10 10 20 10');
                 * activeSheet.getCell(2, 1, GC.Spread.Sheets.SheetArea.viewport).labelOptions({alignment: GC.Spread.Sheets.LabelAlignment.bottomCenter, foreColor: 'yellowgreen', font: 'bold 15px Arial'});
                 * activeSheet.getRange(2, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).height(60);
                 */
                labelOptions(value?:  Object): any;
                /**
                 * Gets or sets whether the cell is locked. When the sheet is protected, the locked cell cannot be edited.
                 * @param {boolean} value Set to <c>true</c> to lock the cell.
                 * @returns {boolean|GC.Spread.Sheets.CellRange} If no value is set, returns whether the cell is locked; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GC.Spread.Sheets.SheetArea.viewport).locked(true);
                 */
                locked(value?:  boolean): any;
                /**
                 * Gets or sets the quote Prefix the cell watermark.
                 * @param {boolean} value The value of the quote Prefix.
                 * @returns {boolean|GC.Spread.Sheets.CellRange} If no value is set, returns the content of the quotePrefix; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(1,1).quotePrefix(true);
                 */
                quotePrefix(value?:  boolean): any;
                /**
                 * Gets or sets whether the row or column can be resized by the user.
                 * @param {boolean} value Set to <c>true</c> to make the row resizable.
                 * @returns {boolean|GC.Spread.Sheets.CellRange} If no value is set, returns whether the user can resize the row; otherwise, returns the row or column.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1. GC.Spread.Sheets.SheetArea.viewport).resizable(true);
                 */
                resizable(value?:  boolean): any;
                /**
                 * Sets the border for the specified area.
                 * @param {GC.Spread.Sheets.LineBorder} border The border line.
                 * @param {Object} option Determines which part of the cell range to set, the option object contains {all:true, left:true, top:true, right:true, bottom:true, diagonalUp:true, diagonalDown:true, outline:true,inside:true, innerHorizontal:true, innerVertical:true}
                 * @param {boolean} [options.all] - all border.
                 * @param {boolean} [options.left] - left border.
                 * @param {boolean} [options.top] - top border.
                 * @param {boolean} [options.right] - right border.
                 * @param {boolean} [options.bottom] - bottom border.
                 * @param {boolean} [options.outline] - outline border.
                 * @param {boolean} [options.inside] - inside border.
                 * @param {boolean} [options.innerHorizontal] - innerHorizontal border.
                 * @param {boolean} [options.innerVertical] - innerVertical border.
                 * @param {boolean} [options.diagonalUp] - diagonalUp border.
                 * @param {boolean} [options.diagonalDown] - diagonalDown border.
                 * @example
                 * //This example creates borders.
                 * sheet.getCell(1, 1).borderTop(new GC.Spread.Sheets.LineBorder("#F0F8FF",GC.Spread.Sheets.LineStyle.double));
                 * sheet.getCell(1, 1).borderLeft(new GC.Spread.Sheets.LineBorder("#F0F8FF",GC.Spread.Sheets.LineStyle.hair));
                 * sheet.getCell(1, 1).borderRight(new GC.Spread.Sheets.LineBorder("#FAEBD7",GC.Spread.Sheets.LineStyle.dashDot));
                 * sheet.getCell(1, 1).borderBottom(new GC.Spread.Sheets.LineBorder("#00FFFF",GC.Spread.Sheets.LineStyle.medium));
                 * sheet.getRange(-1, 5, -1, 1, GC.Spread.Sheets.SheetArea.viewport).borderTop(new GC.Spread.Sheets.LineBorder("#F0FFFF",GC.Spread.Sheets.LineStyle.medium));
                 * sheet.getRange(-1, 5, -1, 1, GC.Spread.Sheets.SheetArea.viewport).borderLeft(new GC.Spread.Sheets.LineBorder("#F5F5DC",GC.Spread.Sheets.LineStyle.medium));
                 * sheet.getRange(-1, 5, -1, 1, GC.Spread.Sheets.SheetArea.viewport).borderRight(new GC.Spread.Sheets.LineBorder("#FF02FF", GC.Spread.Sheets.LineStyle.dashDot));
                 * sheet.getRange(-1, 5, -1, 1, GC.Spread.Sheets.SheetArea.viewport).borderBottom (new GC.Spread.Sheets.LineBorder("#FFE4C4",GC.Spread.Sheets.LineStyle.thin));
                 * sheet.getRange(2, 2, 2, 2, GC.Spread.Sheets.SheetArea.viewport).setBorder(new GC.Spread.Sheets.LineBorder("#8A2BE2",GC.Spread.Sheets.LineStyle.thick), { all:true },3);
                 * sheet.getRange(5, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).borderTop( new GC.Spread.Sheets.LineBorder("#A52A2A",GC.Spread.Sheets.LineStyle.mediumDashed));
                 * sheet.getRange(5, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).borderLeft( new GC.Spread.Sheets.LineBorder("#FF02FF",GC.Spread.Sheets.LineStyle.medium));
                 * sheet.getRange(5, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).borderRight(new GC.Spread.Sheets.LineBorder("#5F9EA0", GC.Spread.Sheets.LineStyle.dashDot));
                 * sheet.getRange(5, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).borderBottom(new GC.Spread.Sheets.LineBorder("#6495ED",GC.Spread.Sheets.LineStyle.dotted));
                 * sheet.getRange(5, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).diagonalUp(new GC.Spread.Sheets.LineBorder("#FF02FF",GC.Spread.Sheets.LineStyle.dotted));
                 * sheet.getRange(5, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).diagonalDown(new GC.Spread.Sheets.LineBorder("#6495ED",GC.Spread.Sheets.LineStyle.medium));
                 */
                setBorder(border:  GC.Spread.Sheets.LineBorder,  option:  GC.Spread.Sheets.ISetBorderOptions): void;
                /**
                 * Gets or sets whether the cell shrinks the text to fit the cell size.
                 * @param {boolean} value Set to <c>true</c> to have the cell shrink text to fit.
                 * @returns {boolean|GC.Spread.Sheets.CellRange} If no value is set, returns whether the cell shrinks the text to fit; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(2,-1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).shrinkToFit(false);
                 * activeSheet.setText(2,0,"This is a test");
                 * @example
                 * activeSheet.getCell(1,1).shrinkToFit(true);
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GC.Spread.Sheets.SheetArea.viewport).shrinkToFit(true);
                 */
                shrinkToFit(value?:  boolean): any;
                /**
                 * Gets or sets a value that indicates whether the user can set focus to the cell using the Tab key.
                 * @param {boolean} value Set to <c>true</c> to set focus to the cell using the Tab key.
                 * @returns {boolean|GC.Spread.Sheets.CellRange} If no value is set, returns whether the user can set focus to the cell using the Tab key; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(1,1).tabStop(false);
                 * activeSheet.getRange(1, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).tabStop(false);
                 * activeSheet.getRange(-1, 1, -1, 1, GC.Spread.Sheets.SheetArea.viewport).tabStop(false);
                 */
                tabStop(value?:  boolean): any;
                /**
                 * Gets or sets the tag for the cell.
                 * @param {Object} value The tag value.
                 * @returns {Object|GC.Spread.Sheets.CellRange} If no value is set, returns the tag value; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(1,1).tag("cell tag");
                 */
                tag(value?:  any): any;
                /**
                 * Gets or sets the formatted text for the cell.
                 * @param {string} value The cell text.
                 * @returns {string|GC.Spread.Sheets.CellRange} If no value is set, returns the cell text; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(1,1).text("cell object");
                 */
                text(value?:  string): any;
                /**
                 * Gets or sets the type of the decoration added to the cell's text.
                 * @param {GC.Spread.Sheets.TextDecorationType} value The type of the decoration.
                 * @returns {GC.Spread.Sheets.TextDecorationType|GC.Spread.Sheets.CellRange} If no value is set, returns the type of the decoration; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(1, -1, 1, -1).textDecoration(GC.Spread.Sheets.TextDecorationType.overline | GC.Spread.Sheets.TextDecorationType.underline);
                 */
                textDecoration(value?:  GC.Spread.Sheets.TextDecorationType): any;
                /**
                 * Gets or sets the text indent of the cell.
                 * @param {number}  value The cell text indent.
                 * @returns {number|GC.Spread.Sheets.CellRange} If no value is set, returns the cell text indent; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GC.Spread.Sheets.SheetArea.viewport).textIndent(1);
                 */
                textIndent(value?:  number): any;
                /**
                 * Gets or sets the theme font for the cell.
                 * @param {string} value The cell's theme font.
                 * @returns {string|GC.Spread.Sheets.CellRange} If no value is set, returns the cell's theme font; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(-1, 0).themeFont("Body");
                 * activeSheet.getCell(0,0).value("Test");
                 */
                themeFont(value?:  string): any;
                /**
                 * Gets or sets the data validator for the cell.
                 * @param {GC.Spread.Sheets.DataValidation.DefaultDataValidator} value The cell data validator.
                 * @returns {GC.Spread.Sheets.DataValidation.DefaultDataValidator|GC.Spread.Sheets.CellRange} If no value is set, returns the cell data validator; otherwise, returns the cell.
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GC.Spread.Sheets.DataValidation.createDateValidator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between, new Date(2012, 11, 31), new Date(2013, 11, 31));
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Enter a date between 12/31/2012 and 12/31/2013.");
                 * dv.inputTitle("Tip");
                 * activeSheet.getCell(0,0).validator(dv);
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GC.Spread.Sheets.DataValidation.createDateValidator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between, new Date(2012, 11, 31), new Date(2013, 11, 31));
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Enter a date between 12/31/2012 and 12/31/2013.");
                 * dv.inputTitle("Tip");
                 * activeSheet.getCell(1, -1).validator(dv);
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GC.Spread.Sheets.DataValidation.createListValidator("1,2,3");
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Value must be 1,2 or 3");
                 * dv.inputTitle("tip");
                 * activeSheet.setDataValidator(-1,0,dv);
                 */
                validator(value?:  GC.Spread.Sheets.DataValidation.DefaultDataValidator): any;
                /**
                 * Gets or sets the vertical alignment of the contents of the cell.
                 * @param {GC.Spread.Sheets.VerticalAlign} value The vertical alignment.
                 * @returns {GC.Spread.Sheets.VerticalAlign|GC.Spread.Sheets.CellRange} If no value is set, returns the vertical alignment of the contents of the cell; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GC.Spread.Sheets.SheetArea.viewport).vAlign(GC.Spread.Sheets.VerticalAlign.top);
                 */
                vAlign(value?:  GC.Spread.Sheets.VerticalAlign): any;
                /**
                 * Gets or sets the unformatted value of the cell.
                 * @param {Object} value The cell value.
                 * @returns {Object|GC.Spread.Sheets.CellRange} If no value is set, returns the cell value; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(1,1).value(10);
                 */
                value(value?:  any): any;
                /**
                 * Gets or sets whether the row or column is displayed.
                 * @param {boolean} value Set to <c>true</c> to make the row visible.
                 * @returns {boolean|GC.Spread.Sheets.CellRange} If no value is set, returns the visible of the row or column; otherwise, returns the row or column.
                 * @example
                 * activeSheet.getCell(-1, 0).visible(false);
                 */
                visible(value?:  boolean): any;
                /**
                 * Gets or sets the content of the cell watermark.
                 * @param {string} value The content of the watermark.
                 * @returns {string|GC.Spread.Sheets.CellRange} If no value is set, returns the content of the watermark; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(1,1).watermark("lightgreen");
                 */
                watermark(value?:  string): any;
                /**
                 * Gets or sets the width of the column in pixels.
                 * @param {number} value The column width.
                 * @returns {number|GC.Spread.Sheets.CellRange} If no value is set, returns the column width; otherwise, returns the column.
                 * @example
                 * activeSheet.getCell(-1, 0).width(20);
                 */
                width(value?:  number): any;
                /**
                 * Gets or sets whether the cell lets text wrap.
                 * @param {boolean} value Set to <c>true</c> to let text wrap within the cell.
                 * @returns {boolean|GC.Spread.Sheets.CellRange} If no value is set, returns whether the cell lets text wrap; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GC.Spread.Sheets.SheetArea.viewport).wordWrap(true);
                 */
                wordWrap(value?:  boolean): any;
            }

            export class ColorScheme{
                /**
                 * Creates a ColorScheme instance.
                 * @constructor
                 * @class
                 * @classdesc Represents the theme color.
                 * @param {string} name The owner that contains the named variable.
                 * @param {string} background1 The theme color for background1.
                 * @param {string} background2 The theme color for background2.
                 * @param {string} text1 The theme color for text1.
                 * @param {string} text2 The theme color for text2.
                 * @param {string} accent1 The theme color for accent1.
                 * @param {string} accent2 The theme color for accent2.
                 * @param {string} accent3 The theme color for accent3.
                 * @param {string} accent4 The theme color for accent4.
                 * @param {string} accent5 The theme color for accent5.
                 * @param {string} accent6 The theme color for accent6.
                 * @param {string} link The color of the link.
                 * @param {string} followedLink The color of the followedLink.
                 * @example
                 * //This example creates colors for the theme.
                 * var ntheme = new GC.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("accent 1 30");
                 */
                constructor(name:  string,  background1:  string,  background2:  string,  text1:  string,  text2:  string,  accent1:  string,  accent2:  string,  accent3:  string,  accent4:  string,  accent5:  string,  accent6:  string,  link:  string,  followedLink:  string);
                /**
                 * Gets or sets the accent1 theme color of the color scheme.
                 * @param {string} value The accent1 theme color string.
                 * @returns {string|GC.Spread.Sheets.ColorScheme} If no value is set, returns the accent1 theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the accent1 color.
                 * var ntheme = new GC.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("accent 1 30");
                 */
                accent1(value?:  string): any;
                /**
                 * Gets or sets the accent2 theme color of the color scheme.
                 * @param {string} value The accent2 theme color string.
                 * @returns {string|GC.Spread.Sheets.ColorScheme} If no value is set, returns the accent2 theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the accent2 color.
                 * var ntheme = new GC.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().accent2("red");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("accent 2");
                 */
                accent2(value?:  string): any;
                /**
                 * Gets or sets the accent3 theme color of the color scheme.
                 * @param {string} value The accent3 theme color string.
                 * @returns {string|GC.Spread.Sheets.ColorScheme} If no value is set, returns the accent3 theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the accent3 color.
                 * var ntheme = new GC.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().accent3("yellow");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("accent 3");
                 */
                accent3(value?:  string): any;
                /**
                 * Gets or sets the accent4 theme color of the color scheme.
                 * @param {string} value The accent4 theme color string.
                 * @returns {string|GC.Spread.Sheets.ColorScheme} If no value is set, returns the accent4 theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the accent4 color.
                 * var ntheme = new GC.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().accent4("blue");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("accent 4");
                 */
                accent4(value?:  string): any;
                /**
                 * Gets or sets the accent5 theme color of the color scheme.
                 * @param {string} value The accent5 theme color string.
                 * @returns {string|GC.Spread.Sheets.ColorScheme} If no value is set, returns the accent5 theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the accent5 color.
                 * var ntheme = new GC.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().accent5("blue");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("accent 5");
                 */
                accent5(value?:  string): any;
                /**
                 * Gets or sets the accent6 theme color of the color scheme.
                 * @param {string} value The accent6 theme color string.
                 * @returns {string|GC.Spread.Sheets.ColorScheme} If no value is set, returns the accent6 theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the accent6 color.
                 * var ntheme = new GC.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().accent6("blue");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("accent 6");
                 */
                accent6(value?:  string): any;
                /**
                 * Gets or sets the background1 theme color of the color scheme.
                 * @param {string} value The background1 theme color string.
                 * @returns {string|GC.Spread.Sheets.ColorScheme} If no value is set, returns the background1 theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the background1 color.
                 * var ntheme = new GC.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().background1("orange");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("background 1");
                 */
                background1(value?:  string): any;
                /**
                 *  Gets or sets the background2 theme color of the color scheme.
                 * @param {string} value The background2 theme color string.
                 * @returns {string|GC.Spread.Sheets.ColorScheme} If no value is set, returns the background2 theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the background2 color.
                 * var ntheme = new GC.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().background2("orange");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("background 2");
                 */
                background2(value?:  string): any;
                /**
                 * Gets or sets the followed hyperlink theme color of the color scheme.
                 * @param {string} value The followed hyperlink theme color string.
                 * @returns {string|GC.Spread.Sheets.ColorScheme} If no value is set, returns the followed hyperlink theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the followedHyperline color.
                 * var ntheme = new GC.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().followedHyperlink("orange");
                 * ntheme.colors().hyperlink("red");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("followedHyperlink");
                 * activeSheet.getCell(2, 0).backColor("hyperlink");
                 */
                followedHyperlink(value?:  string): any;
                /**
                 * Gets the color based on the theme color.
                 * @param {string} name The theme color name.
                 * @returns {string} The theme color.
                 * @example
                 * //This example gets the theme color.
                 * var ntheme = new GC.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().followedHyperlink("orange");
                 * ntheme.colors().hyperlink("red");
                 * ntheme.colors().name("test");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("followedHyperlink");
                 * activeSheet.getCell(2, 0).backColor("hyperlink");
                 * var cname = ntheme.getColor("accent 1");
                 * alert(cname);
                 */
                getColor(name: any): void;
                /**
                 * Gets or sets the hyperlink theme color of the color scheme.
                 * @param {string} value The hyperlink theme color string.
                 * @returns {string|GC.Spread.Sheets.ColorScheme} If no value is set, returns the hyperlink theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the hyperline color.
                 * var ntheme = new GC.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().followedHyperlink("orange");
                 * ntheme.colors().hyperlink("red");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("followedHyperlink");
                 * activeSheet.getCell(2, 0).backColor("hyperlink");
                 */
                hyperlink(value?:  string): any;
                /**
                 * Gets or sets the name of the color scheme.
                 * @param {string} value The name.
                 * @returns {string|GC.Spread.Sheets.ColorScheme} If no value is set, returns the name; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the theme name.
                 * var ntheme = new GC.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().name("green theme");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 */
                name(value?:  string): any;
                /**
                 * Gets or sets the textcolor1 theme color of the color scheme.
                 * @param {string} value The textcolor1 theme color string.
                 * @returns {string|GC.Spread.Sheets.ColorScheme} If no value is set, returns the textcolor1 theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the textColor1 color.
                 * var ntheme = new GC.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().textColor1("orange");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("Text 1");
                 */
                textColor1(value?:  string): any;
                /**
                 * Gets or sets the textcolor2 theme color of the color scheme.
                 * @param {string} value The textcolor2 theme color string.
                 * @returns {string|GC.Spread.Sheets.ColorScheme} If no value is set, returns the textcolor2 theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the textColor2 color.
                 * var ntheme = new GC.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().textColor2("orange");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("Text 2");
                 */
                textColor2(value?:  string): any;
            }

            export class Events{
                /**
                 * Defines the events supported in SpreadJS.
                 * @class
                 */
                constructor();
                /**
                 * Occurs when the user has changed the active sheet.
                 * @name GC.Spread.Sheets.Workbook#ActiveSheetChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} oldSheet The old sheet.
                 * @param {GC.Spread.Sheets.Worksheet} newSheet The new sheet.
                 * @example
                 * //This example creates log text for the ActiveSheetChanged event.
                 * // Use IE to see the console log text
                 * spread.bind(GC.Spread.Sheets.Events.ActiveSheetChanged, function (sender, args) {
                 *     console.log("Active sheet has been switched.");
                 * });
                 */
                static ActiveSheetChanged: string;
                /**
                 * Occurs when the user is changing the active sheet.
                 * @name GC.Spread.Sheets.Workbook#ActiveSheetChanging
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} oldSheet The old sheet.
                 * @param {GC.Spread.Sheets.Worksheet} newSheet The new sheet.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example stops the active sheet from changing.
                 * spread.bind(GC.Spread.Sheets.Events.ActiveSheetChanging, function (sender, args) {
                 *     //Cancel sheet switching.
                 *     args.cancel = true;
                 * });
                 */
                static ActiveSheetChanging: string;
                /**
                 * Occurs when the user clicks a button, check box, or hyperlink in a cell.
                 * @name GC.Spread.Sheets.Workbook#ButtonClicked
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index of the cell.
                 * @param {number} col The column index of the cell.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area that contains the cell.
                 * @example
                 * //This example creates a button cell.
                 * var cellType = new GC.Spread.Sheets.CellTypes.Button();
                 * cellType.buttonBackColor("#FFFF00");
                 * cellType.text("this is a button");
                 * activeSheet.setCellType(1,1,cellType);
                 * //bind
                 * spread.bind(GC.Spread.Sheets.Events.ButtonClicked, function (e, args) {
                 *     var sheet = args.sheet, row = args.row, col = args.col;
                 *     var cellType = activeSheet.getCellType(row, col);
                 *     if (cellType instanceof GC.Spread.Sheets.CellTypes.Button) {
                 *         alert("Button Clicked");
                 *     }
                 * });
                 */
                static ButtonClicked: string;
                /**
                 * Occurs when a change is made to a cell in this sheet that may require the cell to be repainted.
                 * @name GC.Spread.Sheets.Worksheet#CellChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index of the cell.
                 * @param {number} col The column index of the cell.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheetArea of the cell.
                 * @param {string} propertyName The name of the cell's property that has changed.
                 * @example
                 * //This example uses the CellChanged event.
                 * activeSheet.bind(GC.Spread.Sheets.Events.CellChanged, function (e, info) {
                 *     if(info.sheetArea === GC.Spread.Sheets.SheetArea.viewport){
                 *         alert("Cell index (" + info.row + "," + info.col + ")");
                 *     }
                 * });
                 */
                static CellChanged: string;
                /**
                 * Occurs when the user presses down the left mouse button in a cell.
                 * @name GC.Spread.Sheets.Worksheet#CellClick
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area the clicked cell is in.
                 * @param {number} row The row index of the clicked cell.
                 * @param {number} col The column index of the clicked cell.
                 * @example
                 * //This example uses the CellClick event.
                 * // Use IE to see the console log text
                 * activeSheet.bind(GC.Spread.Sheets.Events.CellClick, function (sender, args) {
                 *     if(args.sheetArea === GC.Spread.Sheets.SheetArea.colHeader){
                 *         console.log("The column header was clicked.");
                 *     }
                 *     if(args.sheetArea === GC.Spread.Sheets.SheetArea.rowHeader){
                 *         console.log("The row header was clicked.");
                 *     }
                 *     if(args.sheetArea === GC.Spread.Sheets.SheetArea.corner){
                 *         console.log("The corner header was clicked.");
                 *     }
                 *     console.log("Clicked column index: " + args.col);
                 *     console.log("Clicked row index: " + args.row);
                 * });
                 * //bind
                 * activeSheet.bind(GC.Spread.Sheets.Events.CellDoubleClick, function (sender, args) {
                 *     if(args.sheetArea === GC.Spread.Sheets.SheetArea.colHeader){
                 *         console.log("The column header was double clicked.");
                 *    }
                 *     if(args.sheetArea === GC.Spread.Sheets.SheetArea.rowHeader){
                 *         console.log("The row header was double clicked.");
                 *     }
                 *     if(args.sheetArea === GC.Spread.Sheets.SheetArea.corner){
                 *         console.log("The corner header was double clicked.");
                 *     }
                 *     console.log("Double clicked column index: " + args.col);
                 *     console.log("Double clicked row index: " + args.row);
                 * })
                 */
                static CellClick: string;
                /**
                 * Occurs when the user presses down the left mouse button twice (double-clicks) in a cell.
                 * @name GC.Spread.Sheets.Worksheet#CellDoubleClick
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area the clicked cell is in.
                 * @param {number} row The row index of the clicked cell.
                 * @param {number} col The column index of the clicked cell.
                 * @example
                 * //This example uses the CellDoubleClick event.
                 * // Use IE to see the console log text
                 * activeSheet.bind(GC.Spread.Sheets.Events.CellClick, function (sender, args) {
                 *     if(args.sheetArea === GC.Spread.Sheets.SheetArea.colHeader){
                 *         console.log("The column header was clicked.");
                 *     }
                 *     if(args.sheetArea === GC.Spread.Sheets.SheetArea.rowHeader){
                 *         console.log("The row header was clicked.");
                 *     }
                 *     if(args.sheetArea === GC.Spread.Sheets.SheetArea.corner){
                 *         console.log("The corner header was clicked.");
                 *     }
                 *     console.log("Clicked column index: " + args.col);
                 *     console.log("Clicked row index: " + args.row);
                 * });
                 * //bind
                 * activeSheet.bind(GC.Spread.Sheets.Events.CellDoubleClick, function (sender, args) {
                 *     if(args.sheetArea === GC.Spread.Sheets.SheetArea.colHeader){
                 *         console.log("The column header was double clicked.");
                 *     }
                 *     if(args.sheetArea === GC.Spread.Sheets.SheetArea.rowHeader){
                 *         console.log("The row header was double clicked.");
                 *     }
                 *     if(args.sheetArea === GC.Spread.Sheets.SheetArea.corner){
                 *         console.log("The corner header was double clicked.");
                 *     }
                 *     console.log("Double clicked column index: " + args.col);
                 *     console.log("Double clicked row index: " + args.row);
                 * });
                 */
                static CellDoubleClick: string;
                /**
                 * Occurs when a Clipboard change occurs that affects Spread.Sheets.
                 * @name GC.Spread.Sheets.Worksheet#ClipboardChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {Object} copyData The data from Spread.Sheets that has been set into the clipboard.
                 * @param {string} copyData.text The text string of the clipboard.
                 * @param {string} copyData.html The html string of the clipboard.
                 * @example
                 * //This example uses the ClipboardChanged event.
                 * // Use IE to see the console log text
                 * var activeSheet = spread.getActiveSheet();
                 * activeSheet.bind(GC.Spread.Sheets.Events.ClipboardChanged, function (sender, args) {
                 *     console.log("ClipboardChanged.");
                 * });
                 * activeSheet.bind(GC.Spread.Sheets.Events.ClipboardChanging, function (sender, args) {
                 *     console.log("ClipboardChanging");
                 * });
                 * activeSheet.bind(GC.Spread.Sheets.Events.ClipboardPasted, function (sender, args) {
                 *     console.log("ClipboardPasted");
                 * });
                 * activeSheet.bind(GC.Spread.Sheets.Events.ClipboardPasting, function (sender, args) {
                 *     console.log("ClipboardPasting");
                 * });
                 */
                static ClipboardChanged: string;
                /**
                 * Occurs when the Clipboard is changing due to a Spread.Sheets action.
                 * @name GC.Spread.Sheets.Worksheet#ClipboardChanging
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {Object} copyData The data from Spread.Sheets that is set into the clipboard.
                 * @param {string} copyData.text The text string of the clipboard.
                 * @param {string} copyData.html The html string of the clipboard.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the ClipboardChanging event.
                 * // Use IE to see the console log text
                 * var activeSheet = spread.getActiveSheet();
                 * activeSheet.bind(GC.Spread.Sheets.Events.ClipboardChanged, function (sender, args) {
                 *     console.log("ClipboardChanged.");
                 * });
                 * activeSheet.bind(GC.Spread.Sheets.Events.ClipboardChanging, function (sender, args) {
                 *     console.log("ClipboardChanging");
                 * });
                 * activeSheet.bind(GC.Spread.Sheets.Events.ClipboardPasted, function (sender, args) {
                 *     console.log("ClipboardPasted");
                 * });
                 * activeSheet.bind(GC.Spread.Sheets.Events.ClipboardPasting, function (sender, args) {
                 *     console.log("ClipboardPasting");
                 * });
                 */
                static ClipboardChanging: string;
                /**
                 * Occurs when the user pastes from the Clipboard.
                 * @name GC.Spread.Sheets.Worksheet#ClipboardPasted
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.Range} cellRange The range that was pasted.
                 * @param {GC.Spread.Sheets.ClipboardPasteOptions} pasteOption The paste option that indicates what data is pasted from the clipboard: values, formatting, or formulas.
                 * @param {Object} pasteData The data from the clipboard that will be pasted into Spread.Sheets.
                 * @param {string} pasteData.text The text string of the clipboard.
                 * @param {string} pasteData.html The html string of the clipboard.
                 * @example
                 * //This example uses the ClipboardPasted event.
                 * // Use IE to see the console log text
                 * var activeSheet = spread.getActiveSheet();
                 * activeSheet.bind(GC.Spread.Sheets.Events.ClipboardChanged, function (sender, args) {
                 *     console.log("ClipboardChanged.");
                 * });
                 * activeSheet.bind(GC.Spread.Sheets.Events.ClipboardChanging, function (sender, args) {
                 *     console.log("ClipboardChanging");
                 * });
                 * activeSheet.bind(GC.Spread.Sheets.Events.ClipboardPasted, function (sender, args) {
                 *     console.log("ClipboardPasted");
                 * });
                 * activeSheet.bind(GC.Spread.Sheets.Events.ClipboardPasting, function (sender, args) {
                 *     console.log("ClipboardPasting");
                 * });
                 */
                static ClipboardPasted: string;
                /**
                 * Occurs when the user is pasting from the Clipboard.
                 * @name GC.Spread.Sheets.Worksheet#ClipboardPasting
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.Range} cellRange The range to paste.
                 * @param {GC.Spread.Sheets.ClipboardPasteOptions} pasteOption The paste option that indicates what data is pasted from the clipboard: values, formatting, or formulas.
                 * @param {Object} pasteData The data from the clipboard that will be pasted into Spread.Sheets.
                 * @param {string} pasteData.text The text string of the clipboard.
                 * @param {string} pasteData.html The html string of the clipboard.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the ClipboardPasting event.
                 * // Use IE to see the console log text
                 * var activeSheet = spread.getActiveSheet();
                 * activeSheet.bind(GC.Spread.Sheets.Events.ClipboardChanged, function (sender, args) {
                 *     console.log("ClipboardChanged.");
                 * });
                 * activeSheet.bind(GC.Spread.Sheets.Events.ClipboardChanging, function (sender, args) {
                 *     console.log("ClipboardChanging");
                 * });
                 * activeSheet.bind(GC.Spread.Sheets.Events.ClipboardPasted, function (sender, args) {
                 *     console.log("ClipboardPasted");
                 * });
                 * activeSheet.bind(GC.Spread.Sheets.Events.ClipboardPasting, function (sender, args) {
                 *     console.log("ClipboardPasting");
                 * });
                 */
                static ClipboardPasting: string;
                /**
                 * Occurs when a change is made to a column or range of columns in this sheet that may require the column or range of columns to be repainted.
                 * @name GC.Spread.Sheets.Worksheet#ColumnChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} col The column index.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheetArea of the column.
                 * @param {string} propertyName The name of the column's property that has changed.
                 * @example
                 * //This example uses the ColumnChanged event.
                 * activeSheet.bind(GC.Spread.Sheets.Events.ColumnChanged, function (e, info) {
                 *     if(info.sheetArea === GC.Spread.Sheets.SheetArea.viewport){
                 *         alert("Index (" + info.col + ")");
                 *     }
                 * });
                 */
                static ColumnChanged: string;
                /**
                 * Occurs when the column width has changed.
                 * @name GC.Spread.Sheets.Worksheet#ColumnWidthChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {Array} colList The list of columns whose widths have changed.
                 * @param {boolean} header Whether the columns are row header columns.
                 * @example
                 * //This example uses the ColumnWidthChanged event.
                 * activeSheet.bind(GC.Spread.Sheets.Events.ColumnWidthChanged, function (e, info) {
                 *         alert("Column (" + info.colList + ")");
                 * });
                 */
                static ColumnWidthChanged: string;
                /**
                 * Occurs when the column width is changing.
                 * @name GC.Spread.Sheets.Worksheet#ColumnWidthChanging
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {Array} colList The list of columns whose widths are changing.
                 * @param {boolean} header Whether the columns are row header columns.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the ColumnWidthChanging event.
                 * activeSheet.bind(GC.Spread.Sheets.Events.ColumnWidthChanging, function (e, info) {
                 *         alert("Column (" + info.colList + ")");
                 * });
                 */
                static ColumnWidthChanging: string;
                /**
                 * Occurs when any comment has changed.
                 * @name GC.Spread.Sheets.Worksheet#CommentChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.Comments.Comment} comment The comment that triggered the event.
                 * @param {string} propertyName The name of the comment's property that has changed.
                 * @example
                 * //This example uses the CommentChanged event.
                 * activeSheet.bind(GC.Spread.Sheets.Events.CommentChanged, function (e, info) {
                 *     alert("changed");
                 * });
                 */
                static CommentChanged: string;
                /**
                 * Occurs when the user has removed the comment.
                 * @name GC.Spread.Sheets.Worksheet#CommentRemoved
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.Comments.Comment} comment The comment has been removed.
                 * @example
                 * //This example uses the CommentRemoved event.
                 * var comment = new GC.Spread.Sheets.Comments.Comment();
                 * comment.text("new comment!");
                 * comment.backColor("orange");
                 * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                 * activeSheet.getCell(5,5).comment(comment);
                 * activeSheet.bind(GC.Spread.Sheets.Events.CommentRemoved, function (e, info) {
                 *        console.log("sheet name: " + info.sheetName);
                 * });
                 */
                static CommentRemoved: string;
                /**
                 * Occurs when the user is removing any comment.
                 * @name GC.Spread.Sheets.Worksheet#CommentRemoving
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.Comments.Comment} comment The comment is being removed.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example prevents the comment from being removed.
                 * var comment = new GC.Spread.Sheets.Comments.Comment();
                 * comment.text("new comment!");
                 * comment.backColor("orange");
                 * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                 * activeSheet.getCell(5,5).comment(comment);
                 * activeSheet.bind(GC.Spread.Sheets.Events.CommentRemoving, function (e, info) {
                 *       info.cancel = true;
                 * });
                 */
                static CommentRemoving: string;
                /**
                 * Occurs when the user is dragging and dropping a range of cells.
                 * @name GC.Spread.Sheets.Worksheet#DragDropBlock
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} fromRow The row index of the top left cell of the source range (range being dragged).
                 * @param {number} fromCol The column index of the top left cell of the source range (range being dragged).
                 * @param {number} toRow The row index of the top left cell of the destination range (where selection is dropped).
                 * @param {number} toCol The column index of the bottom right cell of the destination range (where selection is dropped).
                 * @param {number} rowCount The row count of the cell range being dragged.
                 * @param {number} colCount The column count of the cell range being dragged.
                 * @param {boolean} copy Whether the source range is copied.
                 * @param {boolean} insert Whether the source range is inserted.
                 * @param {GC.Spread.Sheets.CopyToOptions} copyOption The CopyOption value for the drag and drop operation.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example creates log text for the DragDropBlock event.
                 * // Use IE to see the console log text
                 * var activeSheet = spread.getActiveSheet();
                 * activeSheet.bind(GC.Spread.Sheets.Events.DragDropBlock, function (e, args) {
                 *         console.log("From Column:" + args.fromCol);
                 *         console.log("From Row:" + args.fromRow);
                 *         console.log("To Column:" + args.toCol);
                 *         console.log("To Row:" + args.toRow);
                 *     });
                 */
                static DragDropBlock: string;
                /**
                 * Occurs when the user completes dragging and dropping a range of cells.
                 * @name GC.Spread.Sheets.Worksheet#DragDropBlockCompleted
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} fromRow The row index of the top left cell of the source range (range being dragged).
                 * @param {number} fromCol The column index of the top left cell of the source range (range being dragged).
                 * @param {number} toRow The row index of the top left cell of the destination range (where selection is dropped).
                 * @param {number} toCol The column index of the bottom right cell of the destination range (where selection is dropped).
                 * @param {number} rowCount The row count of the cell range being dragged.
                 * @param {number} colCount The column count of the cell range being dragged.
                 * @param {boolean} copy Whether the source range is copied.
                 * @param {boolean} insert Whether the source range is inserted.
                 * @param {GC.Spread.Sheets.CopyToOptions} copyOption The CopyOption value for the drag and drop operation.
                 * @example
                 * //This example uses the DragDropBlockCompleted event.
                 * activeSheet.bind(GC.Spread.Sheets.Events.DragDropBlockCompleted, function (e, args) {
                 *         alert("From Column (" + args.fromCol + ")");
                 * });
                 */
                static DragDropBlockCompleted: string;
                /**
                 * Occurs when the user is dragging to fill a range of cells.
                 * @name GC.Spread.Sheets.Worksheet#DragFillBlock
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.Range} fillRange The range used for the fill operation.
                 * @param {GC.Spread.Sheets.Fill.AutoFillType} autoFillType AutoFillType value used for the fill operation.
                 * @param {GC.Spread.Sheets.Fill.FillDirection} fillDirection The direction of the fill.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the DragFillBlock event.
                 * activeSheet.bind(GC.Spread.Sheets.Events.DragFillBlock, function (e, info) {
                 *         alert("Direction (" + info.fillDirection + ")");
                 * });
                 */
                static DragFillBlock: string;
                /**
                 * Occurs when the user completes dragging to fill a range of cells.
                 * @name GC.Spread.Sheets.Worksheet#DragFillBlockCompleted
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.Range} fillRange The range used for the fill operation.
                 * @param {GC.Spread.Sheets.Fill.AutoFillType} autoFillType AutoFillType value used for the fill operation.
                 * @param {GC.Spread.Sheets.Fill.FillDirection} fillDirection The direction of the fill.
                 * @example
                 * //This example uses the DragFillBlockCompleted event.
                 * activeSheet.bind(GC.Spread.Sheets.Events.DragFillBlockCompleted, function (e, info) {
                 *         alert("Type (" + info.autoFillType + ")");
                 * });
                 */
                static DragFillBlockCompleted: string;
                /**
                 * Occurs after user drag merge cells.
                 * @name GC.Spread.Sheets.Worksheet#DragMerged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.Range} mergeRange The range that will be merged.
                 * @example
                 * //This example returns the row index.
                 * // Press Ctrl key to merge
                 * $(document).keydown(function (e) {
                 *      if (e.keyCode === 17) {
                 *         spread.options.allowUserDragMerge = true;
                 *      }
                 * });
                 * $(document).keyup(function (e) {
                 *      if (e.keyCode === 17) {
                 *         spread.options.allowUserDragMerge = false;
                 *      }
                 * });
                 * activeSheet.bind(GC.Spread.Sheets.Events.DragMerging, function (e, data) {
                 *      var mergeRange = data.mergeRange;
                 *      alert(mergeRange.row);
                 * });
                 * activeSheet.bind(GC.Spread.Sheets.Events.DragMerged, function (e, data) {
                 *      var mergeRange = data.mergeRange;
                 *      alert(mergeRange.row);
                 * });
                 */
                static DragMerged: string;
                /**
                 * Occurs before user drag merge cells.
                 * @name GC.Spread.Sheets.Worksheet#DragMerging
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.Range} mergeRange The range that will be merged.
                 * @param {bool} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example returns the row index.
                 * // Press Ctrl key to merge
                 * $(document).keydown(function (e) {
                 *      if (e.keyCode === 17) {
                 *          spread.options.allowUserDragMerge = true;
                 *      }
                 * });
                 * $(document).keyup(function (e) {
                 *      if (e.keyCode === 17) {
                 *          spread.options.allowUserDragMerge = false;
                 *      }
                 * });
                 * activeSheet.bind(GC.Spread.Sheets.Events.DragMerging, function (e, data) {
                 *      var mergeRange = data.mergeRange;
                 *      alert(mergeRange.row);
                 * });
                 * activeSheet.bind(GC.Spread.Sheets.Events.DragMerged, function (e, data) {
                 *      var mergeRange = data.mergeRange;
                 *      alert(mergeRange.row);
                 * });
                 */
                static DragMerging: string;
                /**
                 * Occurs when a cell is in edit mode and the text is changed.
                 * @name GC.Spread.Sheets.Worksheet#EditChange
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index of cell.
                 * @param {number} col The column index of cell.
                 * @param {object} editingText The value from the current editor.
                 * @example
                 * //This example creates log text for the EditChange event.
                 * // Use IE to see the console log text
                 * activeSheet.bind(GC.Spread.Sheets.Events.EditChange, function (sender, args) {
                 *     console.log("Cell (" + args.row + ", " + args.col + ") data has been changed.")
                 * });
                 */
                static EditChange: string;
                /**
                 * Occurs when a cell leaves edit mode.
                 * @name GC.Spread.Sheets.Worksheet#EditEnded
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index of cell.
                 * @param {number} col The column index of cell.
                 * @param {object} editingText The value from the current editor.
                 * @example
                 * //This example creates log text for the EditStarting and EditEnded events.
                 *  // Use IE to see the console log text
                 * var activeSheet = spread.getActiveSheet();
                 * activeSheet.bind(GC.Spread.Sheets.Events.EditStarting, function (sender, args) {
                 *     console.log("Start cell editing.");
                 * });
                 * activeSheet.bind(GC.Spread.Sheets.Events.EditEnded, function (sender, args) {
                 *     console.log("Finish cell editing.");
                 * });
                 */
                static EditEnded: string;
                /**
                 * Occurs when a cell is leaving edit mode.
                 * @name GC.Spread.Sheets.Worksheet#EditEnding
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index of cell.
                 * @param {number} col The column index of cell.
                 * @param {object} editor The current editor.
                 * @param {object} editingText The value from the current editor.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the EditEnding event.
                 * activeSheet.bind(GC.Spread.Sheets.Events.EditStarting, function (sender, args) {
                 *     console.log("Start cell editing.");
                 * });
                 * activeSheet.bind(GC.Spread.Sheets.Events.EditEnding, function (sender, args) {
                 *     console.log("EditEnding event.");
                 * });
                 * activeSheet.bind(GC.Spread.Sheets.Events.EditEnded, function (sender, args) {
                 *     console.log("EditEnded event.");
                 * });
                 */
                static EditEnding: string;
                /**
                 * Occurs when the editor's status has changed.
                 * @name GC.Spread.Sheets.Worksheet#EditorStatusChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.EditorStatus} oldStatus The old status of the editor.
                 * @param {GC.Spread.Sheets.EditorStatus} newStatus The new status of the editor.
                 * @example
                 * //This example uses the EditorStatusChanged event.
                 * activeSheet.bind(GC.Spread.Sheets.Events.EditorStatusChanged, function (e, info) {
                 *         alert("Column (" + info.newStatus + ")");
                 * });
                 */
                static EditorStatusChanged: string;
                /**
                 * Occurs when a cell is entering edit mode.
                 * @name GC.Spread.Sheets.Worksheet#EditStarting
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index of cell.
                 * @param {number} col The column index of cell.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example creates log text for the EditStarting and EditEnded events.
                 * // Use IE to see the console log text
                 * var activeSheet = spread.getActiveSheet();
                 * activeSheet.bind(GC.Spread.Sheets.Events.EditStarting, function (sender, args) {
                 *     console.log("Start cell editing.");
                 * });
                 * activeSheet.bind(GC.Spread.Sheets.Events.EditEnded, function (sender, args) {
                 *     console.log("Finish cell editing.");
                 * });
                 */
                static EditStarting: string;
                /**
                 * Occurs when the focus enters a cell.
                 * @name GC.Spread.Sheets.Worksheet#EnterCell
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index of the cell being entered.
                 * @param {number} col The column index of the cell being entered.
                 * @example
                 * //This example uses the EnterCell event.
                 * activeSheet.bind(GC.Spread.Sheets.Events.EnterCell, function (e, info) {
                 *         alert("Cell (" + info.row + ", " + info.col +")");
                 * });
                 */
                static EnterCell: string;
                /**
                 * Occurs when any floating object has changed.
                 * @name GC.Spread.Sheets.Worksheet#FloatingObjectsChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.FloatingObjects.FloatingObject} floatingObject The floating object that triggered the event.
                 * @param {string} propertyName The name of the floating object's property that has changed.
                 * @example
                 * //This example uses the FloatingObjectChanged event.
                 * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                 * var btn = document.createElement('button');
                 * btn.style.width = "60px";
                 * btn.style.height = "30px";
                 * btn.innerText = "button";
                 * customFloatingObject.content(btn);
                 * activeSheet.floatingObjects.add(customFloatingObject);
                 * activeSheet.bind(GC.Spread.Sheets.Events.FloatingObjectChanged, function (e, info) {
                 *        alert("changed");
                 * });
                 */
                static FloatingObjectChanged: string;
                /**
                 * Occurs when the custom floating object content is loaded.
                 * @name GC.Spread.Sheets.Worksheet#FloatingObjectLoaded
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.FloatingObjects.FloatingObject} floatingObject The custom floating object that triggered the event.
                 * @param {HTMLElement} element The HTMLElement of the custom floating object.
                 */
                static FloatingObjectLoaded: string;
                /**
                 * Occurs when the user has removed the floating object.
                 * @name GC.Spread.Sheets.Worksheet#FloatingObjectRemoved
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.FloatingObjects.FloatingObject} floatingObject The floating object has been removed.
                 * @example
                 * //This example uses the FloatingObjectRemoved event.
                 * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                 * var btn = document.createElement('button');
                 * btn.style.width = "60px";
                 * btn.style.height = "30px";
                 * btn.innerText = "button";
                 * customFloatingObject.content(btn);
                 * activeSheet.floatingObjects.add(customFloatingObject);
                 * activeSheet.bind(GC.Spread.Sheets.Events.FloatingObjectRemoved, function (e, info) {
                 *         alert(info.sheetName);
                 * });
                 */
                static FloatingObjectRemoved: string;
                /**
                 * Occurs when the user is removing any floating object.
                 * @name GC.Spread.Sheets.Worksheet#FloatingObjectRemoving
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.FloatingObjects.FloatingObject} floatingObject The floating object is being removed.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the FloatingObjectRemoving event.
                 * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                 * var btn = document.createElement('button');
                 * btn.style.width = "60px";
                 * btn.style.height = "30px";
                 * btn.innerText = "button";
                 * customFloatingObject.content(btn);
                 * activeSheet.floatingObjects.add(customFloatingObject);
                 * activeSheet.bind(GC.Spread.Sheets.Events.FloatingObjectRemoving, function (e, info) {
                 *         info.cancel = true;
                 * });
                 */
                static FloatingObjectRemoving: string;
                /**
                 * Occurs when the selections of the floating object have changed.
                 * @name GC.Spread.Sheets.Worksheet#FloatingObjectsSelectionChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.FloatingObjects.FloatingObject} floatingObject The floating object that triggered the event.
                 * @example
                 * //This example uses the FloatingObjectSelectionChanged event.
                 * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                 * var btn = document.createElement('button');
                 * btn.style.width = "60px";
                 * btn.style.height = "30px";
                 * btn.innerText = "button";
                 * customFloatingObject.content(btn);
                 * activeSheet.floatingObjects.add(customFloatingObject);
                 * // Use IE to see the console log text
                 * activeSheet.bind(GC.Spread.Sheets.Events.FloatingObjectSelectionChanged, function (e, info) {
                 *        console.log("sheet name: " + info.sheetName);
                 * });
                 */
                static FloatingObjectSelectionChanged: string;
                /**
                 * Occurs when an invalid operation is performed.
                 * @name GC.Spread.Sheets.Worksheet#InvalidOperation
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.InvalidOperationType} invalidType Indicates which operation was invalid.
                 * @param {string} message The description of the invalid operation.
                 * @example
                 * //This example uses the InvalidOperation event.
                 * activeSheet.bind(GC.Spread.Sheets.Events.InvalidOperation, function (e, info) {
                 *         alert("Message (" + info.message + ")");
                 * });
                 */
                static InvalidOperation: string;
                /**
                 * Occurs when the focus leaves a cell.
                 * @name GC.Spread.Sheets.Worksheet#LeaveCell
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index of the cell being left.
                 * @param {number} col The column index of the cell being left.
                 * @param {boolean} cancel Whether the operation should be canceled.
                 * @example
                 * //This example creates log text for the LeaveCell event.
                 * // Use IE to see the console log text
                 * activeSheet.bind(GC.Spread.Sheets.Events.LeaveCell, function (sender, args) {
                 *     console.log("The column index before moving: " + args.col);
                 *     console.log("The row index before moving: " + args.row);
                 * });
                 */
                static LeaveCell: string;
                /**
                 * Occurs when the left column changes.
                 * @name GC.Spread.Sheets.Worksheet#LeftColumnChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} oldLeftCol The old left column index.
                 * @param {number} newLeftCol The new left column index.
                 * @example
                 * //This example synchronizes vertical and horizontal scrolling for sheet 1 and sheet 2.
                 * var sheet1 = spread.getSheet(0),
                 * sheet2 = spread.getSheet(1);
                 * sheet1.bind(GC.Spread.Sheets.Events.TopRowChanged, function (sender, args) {
                 *     //Set the displayed top row of sheet1 to sheet2 (vertical scroll synchronization).
                 *     sheet2.showRow(args.newTopRow, GC.Spread.Sheets.VerticalPosition.top);
                 * });
                 * sheet1.bind(GC.Spread.Sheets.Events.LeftColumnChanged, function (sender, args) {
                 *     //Set the displayed left column of sheet1 to sheet2 (Horizontal scroll synchronization).
                 *     sheet2.showColumn(args.newLeftCol, GC.Spread.Sheets.HorizontalPosition.left);
                 * });
                 */
                static LeftColumnChanged: string;
                /**
                 * Occurs when the outline column check status has changed.
                 * @name GC.Spread.Sheets.Worksheet#OutlineColumnCheckStatusChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The outline column's change row index.
                 * @param {number} col The outline column's change col index.
                 * @param {boolean} status The outline column's change status
                 * @example
                 * //Removing the sparkline causes a change.
                 * activeSheet.bind(GC.Spread.Sheets.Events.OutlineColumnCheckStatusChanged, function (e, info) {
                 *      console.log("status: " + info.status);
                 * });
                 */
                static OutlineColumnCheckStatusChanged: string;
                /**
                 * Occurs when any picture has changed.
                 * @name GC.Spread.Sheets.Worksheet#PictureChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.FloatingObjects.Picture} picture The picture that triggered the event.
                 * @param {string} propertyName The name of the picture's property that has changed.
                 * @example
                 * var spread = new GC.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var activeSheet = spread.getActiveSheet();
                 * activeSheet.pictures.add("f2","Event.png",2,2,6,6);
                 * activeSheet.pictures.add("f1","tsoutline.png",3,0,6,6);
                 * // Use IE to see the console log text
                 * activeSheet.bind(GC.Spread.Sheets.Events.PictureChanged, function (e, info) {
                 * console.log("Sheet: " + info.sheetName);
                 * });
                 * @example
                 * var spread = new GC.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var activeSheet = spread.getActiveSheet();
                 * activeSheet.pictures.add("f2","Event.png",2,2,6,6);
                 * activeSheet.pictures.add("f1","tsoutline.png",3,0,6,6);
                 * // Use IE to see the console log text
                 * activeSheet.bind(GC.Spread.Sheets.Events.PictureChanged, function (e, info) {
                 * console.log("Property: " + info.propertyName);
                 * });
                 */
                static PictureChanged: string;
                /**
                 * Occurs when the selections of the picture have changed.
                 * @name GC.Spread.Sheets.Worksheet#PictureSelectionChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.FloatingObjects.Picture} picture The picture that triggered the event.
                 * @example
                 * //This example uses the PictureSelectionChanged event.
                 * var spread = new GC.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var activeSheet = spread.getActiveSheet();
                 * activeSheet.pictures.add("f2","Event.png",2,2,6,6);
                 * activeSheet.pictures.add("f1","tsoutline.png",3,0,6,6);
                 * // Use IE to see the console log text
                 * activeSheet.bind(GC.Spread.Sheets.Events.PictureSelectionChanged, function (e, info) {
                 * console.log("Sheet: " + info.sheetName);
                 * });
                 */
                static PictureSelectionChanged: string;
                /**
                 * Occurs when the cell range has changed.
                 * @name GC.Spread.Sheets.Worksheet#RangeChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The range's row index.
                 * @param {number} col The range's column index.
                 * @param {number} rowCount The range's row count.
                 * @param {number} colCount The range's column count.
                 * @param {Array.<Object>} changedCells The positions of the cells whose data has changed, each position has row and col.
                 * @param {GC.Spread.Sheets.RangeChangedAction} action The type of action that raises the RangeChanged event.
                 * @example
                 * //This example returns the sheet name and action when changing the cell range in Microsoft Internet Explorer.
                 *  activeSheet.bind(GC.Spread.Sheets.Events.RangeChanged, function (sender, args) {
                 *   console.log(args.sheetName, args.action);
                 * });
                 */
                static RangeChanged: string;
                /**
                 * Occurs when a range column has just been clear filtered.
                 * @name GC.Spread.Sheets.Worksheet#RangeFilterCleared
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} col The index of the sheet column has just been clear filtered.
                 * @example
                 * //This example uses the RangeFilterCleared event.
                 * activeSheet.getCell(0,0).text("Name");
                 * activeSheet.getCell(0,1).text("Value");
                 * activeSheet.getCell(0,2).text("T/F");
                 * activeSheet.getCell(1,0).text("AW");
                 * activeSheet.getCell(1,1).text("5");
                 * activeSheet.getCell(1,2).text("T");
                 * var cellRange =new GC.Spread.Sheets.Range(0, 0, 5, 1);
                 * var hideRowFilter =new GC.Spread.Sheets.Filter.HideRowFilter(cellRange);
                 * activeSheet.rowFilter(hideRowFilter);
                 * activeSheet.bind(GC.Spread.Sheets.Events.RangeFilterCleared, function (e, info) {
                 *         alert("Col (" + info.col + ")");
                 * });
                 */
                static RangeFilterCleared: string;
                /**
                 * Occurs when a range column is about to be automatically clear filter.
                 * @name GC.Spread.Sheets.Worksheet#RangeFilterClearing
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} col The index of the sheet column to be automatically clear filter.
                 * @example
                 * //This example uses the RangeFilterClearing event.
                 * activeSheet.getCell(0,0).text("Name");
                 * activeSheet.getCell(0,1).text("Value");
                 * activeSheet.getCell(0,2).text("T/F");
                 * activeSheet.getCell(1,0).text("AW");
                 * activeSheet.getCell(1,1).text("5");
                 * activeSheet.getCell(1,2).text("T");
                 * var cellRange =new GC.Spread.Sheets.Range(0, 0, 5, 1);
                 * var hideRowFilter =new GC.Spread.Sheets.Filter.HideRowFilter(cellRange);
                 * activeSheet.rowFilter(hideRowFilter);
                 * activeSheet.bind(GC.Spread.Sheets.Events.RangeFilterClearing, function (e, info) {
                 *         alert("Col (" + info.col + ")");
                 * });
                 */
                static RangeFilterClearing: string;
                /**
                 * Occurs when a column has just been automatically filtered.
                 * @name GC.Spread.Sheets.Worksheet#RangeFiltered
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} col The index of the column that was automatically filtered.
                 * @param {Array} filterValues The values by which the column was filtered.
                 * @param {Array} conditionInfo The condition rule info that which the column was filtered.
                 * @example
                 * //This example uses the RangeFiltered event.
                 * var cellrange =new GC.Spread.Sheets.Range(0, 2, 5, 1);
                 * var hideRowFilter =new GC.Spread.Sheets.Filter.HideRowFilter(cellrange);
                 * activeSheet.rowFilter(hideRowFilter);
                 * activeSheet.bind(GC.Spread.Sheets.Events.RangeFiltered, function (e, info) {
                 *         alert("Col (" + info.col + ")");
                 * });
                 */
                static RangeFiltered: string;
                /**
                 * Occurs when a column is about to be automatically filtered.
                 * @name GC.Spread.Sheets.Worksheet#RangeFiltering
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} col The index of the column to be automatically filtered.
                 * @param {Array} filterValues The values by which to filter the column.
                 * @param {Object} conditionInfo The condition rule info by which to filter the column.
                 * @example
                 * //This example uses the RangeFiltering event.
                 * var cellrange =new GC.Spread.Sheets.Range(0, 2, 5, 1);
                 * var hideRowFilter =new GC.Spread.Sheets.Filter.HideRowFilter(cellrange);
                 * activeSheet.rowFilter(hideRowFilter);
                 * activeSheet.bind(GC.Spread.Sheets.Events.RangeFiltering, function (e, info) {
                 *        alert("Col (" + info.col + ")");
                 * });
                 */
                static RangeFiltering: string;
                /**
                 * Occurs when the user has changed the outline state (range group) for rows or columns.
                 * @name GC.Spread.Sheets.Worksheet#RangeGroupStateChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {boolean} isRowGroup Whether the outline (range group) is a group of rows.
                 * @param {number} index The index of the RangeGroupInfo object whose state has changed.
                 * @param {number} level The level of the RangeGroupInfo object whose state has changed.
                 * @example
                 * //This example uses the RangeGroupStateChanged event.
                 * activeSheet.suspendPaint();
                 * activeSheet.setRowCount(34);
                 * activeSheet.setValue(0,0,"Western");
                 * activeSheet.setValue(0,1,"Western");
                 * activeSheet.setValue(0,2,"Western");
                 * activeSheet.setValue(1,0,"A");
                 * activeSheet.setValue(1,1,"B");
                 * activeSheet.setValue(1,2,"C");
                 * activeSheet.setValue(2,0,"A");
                 * activeSheet.setValue(2,1,"B");
                 * activeSheet.setValue(2,2,"C");
                 * activeSheet.rowOutlines.group(0,2);
                 * activeSheet.columnOutlines.group(0,1);
                 * activeSheet.resumePaint();
                 * activeSheet.bind(GC.Spread.Sheets.Events.RangeGroupStateChanged, function (e, info) {
                 *         alert("Level (" + info.level + ")");
                 * });
                 */
                static RangeGroupStateChanged: string;
                /**
                 * Occurs before the user changes the outline state (range group) for rows or columns.
                 * @name GC.Spread.Sheets.Worksheet#RangeGroupStateChanging
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {boolean} isRowGroup Whether the outline (range group) is a group of rows.
                 * @param {number} index The index of the RangeGroupInfo object whose state is changing.
                 * @param {number} level The level of the RangeGroupInfo object whose state is changing.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the RangeGroupStateChanging event.
                 * activeSheet.suspendPaint();
                 * activeSheet.setRowCount(34);
                 * activeSheet.setValue(0,0,"Western");
                 * activeSheet.setValue(0,1,"Western");
                 * activeSheet.setValue(0,2,"Western");
                 * activeSheet.setValue(1,0,"A");
                 * activeSheet.setValue(1,1,"B");
                 * activeSheet.setValue(1,2,"C");
                 * activeSheet.setValue(2,0,"A");
                 * activeSheet.setValue(2,1,"B");
                 * activeSheet.setValue(2,2,"C");
                 * activeSheet.rowOutlines.group(0,2);
                 * activeSheet.columnOutlines.group(0,1);
                 * activeSheet.resumePaint();
                 * activeSheet.bind(GC.Spread.Sheets.Events.RangeGroupStateChanging, function (e, info) {
                 *         alert("Level (" + info.level + ")");
                 * });
                 */
                static RangeGroupStateChanging: string;
                /**
                 * Occurs when a column has just been automatically sorted.
                 * @name GC.Spread.Sheets.Worksheet#RangeSorted
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} col The index of the column that was automatically sorted.
                 * @param {boolean} ascending Whether the automatic sort is ascending.
                 * @example
                 * //This example uses the RangeSorted event.
                 * activeSheet.setValue(0, 0, 10);
                 * activeSheet.setValue(1, 0, 100);
                 * activeSheet.setValue(2, 0, 50);
                 * activeSheet.setValue(3, 0, 40);
                 * activeSheet.setValue(4, 0, 80);
                 * activeSheet.setValue(5, 0, 1);
                 * activeSheet.setValue(6, 0, 65);
                 * activeSheet.setValue(7, 0, 20);
                 * activeSheet.setValue(8, 0, 30);
                 * activeSheet.setValue(9, 0, 35);
                 * var cellRange =new GC.Spread.Sheets.Range(0, 0, 5, 1);
                 * var hideRowFilter =new GC.Spread.Sheets.Filter.HideRowFilter(cellRange);
                 * activeSheet.rowFilter(hideRowFilter);
                 * activeSheet.bind(GC.Spread.Sheets.Events.RangeSorted, function (e, info) {
                 *         alert("Col (" + info.col + ", " + info.ascending +")");
                 * });
                 */
                static RangeSorted: string;
                /**
                 * Occurs when a column is about to be automatically sorted.
                 * @name GC.Spread.Sheets.Worksheet#RangeSorting
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} col The index of the column to be automatically sorted.
                 * @param {boolean} ascending Whether the automatic sort is ascending.
                 * @param {boolean} cancel Whether the operation should be canceled.
                 * @example
                 * //This example uses the RangeSorting event.
                 * activeSheet.setValue(0, 0, 10);
                 * activeSheet.setValue(1, 0, 100);
                 * activeSheet.setValue(2, 0, 50);
                 * activeSheet.setValue(3, 0, 40);
                 * activeSheet.setValue(4, 0, 80);
                 * activeSheet.setValue(5, 0, 1);
                 * activeSheet.setValue(6, 0, 65);
                 * activeSheet.setValue(7, 0, 20);
                 * activeSheet.setValue(8, 0, 30);
                 * activeSheet.setValue(9, 0, 35);
                 * var cellrange =new GC.Spread.Sheets.Range(0, 0, 5, 1);
                 * var hideRowFilter =new GC.Spread.Sheets.Filter.HideRowFilter(cellrange);
                 * activeSheet.rowFilter(hideRowFilter);
                 * activeSheet.bind(GC.Spread.Sheets.Events.RangeSorting, function (e, info) {
                 *         alert("Col (" + info.col + ", " + info.ascending +")");
                 * });
                 */
                static RangeSorting: string;
                /**
                 * Occurs when a change is made to a row or range of rows in this sheet that may require the row or range of rows to be repainted.
                 * @name GC.Spread.Sheets.Worksheet#RowChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheetArea of the row.
                 * @param {string} propertyName The name of the row's property that has changed.
                 * @example
                 * //This example uses the RowChanged event.
                 * activeSheet.bind(GC.Spread.Sheets.Events.RowChanged, function (e, info) {
                 *         alert("Row (" + info.row + ")");
                 * });
                 */
                static RowChanged: string;
                /**
                 * Occurs when the row height has changed.
                 * @name GC.Spread.Sheets.Worksheet#RowHeightChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {Array} rowList The list of rows whose heights have changed.
                 * @param {boolean} header Whether the columns are column header columns.
                 * @example
                 * //This example uses the RowHeightChanged event.
                 * activeSheet.bind(GC.Spread.Sheets.Events.RowHeightChanged, function (e, info) {
                 *         alert("Row List (" + info.rowList + ")");
                 * });
                 */
                static RowHeightChanged: string;
                /**
                 * Occurs when the row height is changing.
                 * @name GC.Spread.Sheets.Worksheet#RowHeightChanging
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {Array} rowList The list of rows whose heights are changing.
                 * @param {boolean} header Whether the columns are column header columns.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the RowHeightChanging event.
                 * activeSheet.bind(GC.Spread.Sheets.Events.RowHeightChanging, function (e, info) {
                 *         alert("Row List (" + info.rowList + ")");
                 * });
                 */
                static RowHeightChanging: string;
                /**
                 * Occurs when the selection of cells on the sheet has changed.
                 * @name GC.Spread.Sheets.Worksheet#SelectionChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {Array.<GC.Spread.Sheets.Range>} oldSelections The old selection ranges.
                 * @param {Array.<GC.Spread.Sheets.Range>} newSelections The new selection ranges.
                 * @example
                 * //This example uses the SelectionChanged event.
                 * activeSheet.bind(GC.Spread.Sheets.Events.SelectionChanged, function (e, info) {
                 *         alert("Name (" + info.sheetName + ")");
                 * });
                 */
                static SelectionChanged: string;
                /**
                 * Occurs when the selection of cells on the sheet is changing.
                 * @name GC.Spread.Sheets.Worksheet#SelectionChanging
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {Array.<GC.Spread.Sheets.Range>} oldSelections The old selection ranges.
                 * @param {Array.<GC.Spread.Sheets.Range>} newSelections The new selection ranges.
                 * @example
                 * //This example uses the SelectionChanging event.
                 * activeSheet.bind(GC.Spread.Sheets.Events.SelectionChanging, function (e, info) {
                 * //Use IE to see console
                 *         console.log("Name (" + info.sheetName + ")");
                 * });
                 */
                static SelectionChanging: string;
                /**
                 * Occurs when any shape has changed.
                 * @name GC.Spread.Sheets.Worksheet#ShapeChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.Shapes.Shape} shape The shape that triggered the event.
                 * @param {string} propertyName The name of the shape's property that has changed.
                 * @example
                 * //This example uses the ShapeChanged event.
                 * var shape1 = activeSheet.shapes.add("shape1", GC.Spread.Sheets.Shapes.AutoShapeType.rectangle, 20, 20, 200, 200);
                 * activeSheet.bind(GC.Spread.Sheets.Events.ShapeChanged, function (e, info) {
                 *        alert("changed");
                 * });
                 */
                static ShapeChanged: string;
                /**
                 * Occurs when the user has removed the shape.
                 * @name GC.Spread.Sheets.Worksheet#ShapeRemoved
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.Shapes.Shape} shape The shape has been removed.
                 * @example
                 * //This example uses the ShapeRemoved event.
                 * var shape = activeSheet.shapes.add("myShape", GC.Spread.Sheets.Shapes.AutoShapeType.diamond, 0, 90, 200, 200);
                 * activeSheet.bind(GC.Spread.Sheets.Events.ShapeRemoved, function (e, info) {
                 *         alert(info.shape.name());
                 * });
                 */
                static ShapeRemoved: string;
                /**
                 * Occurs when the user is removing any shape.
                 * @name GC.Spread.Sheets.Worksheet#ShapeRemoving
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.Shapes.Shape} shape The shape is being removed.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the ShapeRemoving event.
                 * var shape = sheet.shapes.add("myShape", GC.Spread.Sheets.Shapes.AutoShapeType.diamond, 0, 90, 200, 200);
                 * activeSheet.bind(GC.Spread.Sheets.Events.ShapeRemoving, function (e, info) {
                 *         info.cancel = true;// the shape will not remove
                 * });
                 */
                static ShapeRemoving: string;
                /**
                 * Occurs when the selections of the shape have changed.
                 * @name GC.Spread.Sheets.Worksheet#ShapeSelectionChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.Shapes.Shape} shape The shape that triggered the event.
                 * @example
                 * //This example uses the ShapeSelectionChanged event.
                 * var shape = sheet.shapes.add("myShape", GC.Spread.Sheets.Shapes.AutoShapeType.diamond, 0, 90, 200, 200);
                 * activeSheet.bind(GC.Spread.Sheets.Events.ShapeSelectionChanged, function (e, info) {
                 *        console.log("event info: " + info);
                 * });
                 */
                static ShapeSelectionChanged: string;
                /**
                 * Occurs after the user drags and moves the sheet.
                 * @name GC.Spread.Sheets.Worksheet#SheetMoved
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} oldIndex The previous sheet index.
                 * @param {number} newIndex The new sheet index.
                 * @example
                 * //This example uses the SheetMoved event.
                 * window.onload = function(){
                 *      var spread = new GC.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 *      var activeSheet = spread.getActiveSheet();
                 *      spread.bind(GC.Spread.Sheets.Events.SheetMoving, function (e, data) {
                 *          alert(data.sheetName + '\n' +  'oldIndex: ' + data.oldIndex + '\n' +  'newIndex: ' + data.newIndex + '\n' +  'cancel: ' + data.cancel);
                 *      });
                 *      spread.bind(GC.Spread.Sheets.Events.SheetMoved, function (e, data) {
                 *          alert(data.sheetName + '\n' +  'oldIndex: ' + data.oldIndex + '\n' +  'newIndex: ' + data.newIndex);
                 *      });
                 * }
                 */
                static SheetMoved: string;
                /**
                 * Occurs before the user drags and moves the sheet.
                 * @name GC.Spread.Sheets.Worksheet#SheetMoving
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} oldIndex The old sheet index.
                 * @param {number} newIndex A value that indicates the index will be moved to.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the SheetMoving event.
                 * window.onload = function(){
                 *      var spread = new GC.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 *      var activeSheet = spread.getActiveSheet();
                 *      spread.bind(GC.Spread.Sheets.Events.SheetMoving, function (e, data) {
                 *          alert(data.sheetName + '\n' +  'oldIndex: ' + data.oldIndex + '\n' +  'newIndex: ' + data.newIndex + '\n' +  'cancel: ' + data.cancel);
                 *      });
                 *      spread.bind(GC.Spread.Sheets.Events.SheetMoved, function (e, data) {
                 *          alert(data.sheetName + '\n' +  'oldIndex: ' + data.oldIndex + '\n' +  'newIndex: ' + data.newIndex);
                 *      });
                 * }
                 */
                static SheetMoving: string;
                /**
                 * Occurs when the user has changed the sheet name.
                 * @name GC.Spread.Sheets.Worksheet#SheetNameChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} oldValue The sheet's old name.
                 * @param {string} newValue The sheet's new name.
                 * @example
                 * //This example uses the SheetNameChanged event.
                 * // Use IE to see the console log text
                 * spread.bind(GC.Spread.Sheets.Events.SheetNameChanging, function (sender, args) {
                 *    console.log(args.oldValue);
                 * });
                 * spread.bind(GC.Spread.Sheets.Events.SheetNameChanged, function (sender, args) {
                 *    console.log(args.newValue);
                 * });
                 */
                static SheetNameChanged: string;
                /**
                 * Occurs when the user is changing the sheet name.
                 * @name GC.Spread.Sheets.Worksheet#SheetNameChanging
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} oldValue The sheet's old name.
                 * @param {string} newValue The sheet's new name.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the SheetNameChanging event.
                 * // Use IE to see the console log text
                 * spread.bind(GC.Spread.Sheets.Events.SheetNameChanging, function (sender, args) {
                 *    console.log(args.oldValue);
                 * });
                 * spread.bind(GC.Spread.Sheets.Events.SheetNameChanged, function (sender, args) {
                 *    console.log(args.newValue);
                 * });
                 */
                static SheetNameChanging: string;
                /**
                 * Occurs when the user clicks the sheet tab.
                 * @name GC.Spread.Sheets.Worksheet#SheetTabClick
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} sheetTabIndex The index of the sheet tab that the user clicked.
                 * @example
                 * //This example uses the SheetTabClick event.
                 * spread.bind(GC.Spread.Sheets.Events.SheetTabClick, function (e, info) {
                 *         alert("Index (" + info.sheetTabIndex + ")");
                 * });
                 */
                static SheetTabClick: string;
                /**
                 * Occurs when the user double-clicks the sheet tab.
                 * @name GC.Spread.Sheets.Worksheet#SheetTabDoubleClick
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} sheetTabIndex The index of the sheet tab that the user double-clicked.
                 * @example
                 * //This example uses the SheetTabDoubleClick event.
                 * spread.bind(GC.Spread.Sheets.Events.SheetTabDoubleClick, function (e, info) {
                 *         alert("Index (" + info.sheetTabIndex + ")");
                 * });
                 */
                static SheetTabDoubleClick: string;
                /**
                 * Occurs when any slicer has changed.
                 * @name GC.Spread.Sheets.Worksheet#SlicerChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.Slicers.Slicer} slicer The slicer that triggered the event.
                 * @param {string} propertyName The name of the slicer's property that has changed.
                 * @example
                 * //This example uses the SlicerChanged event.
                 * //create a table
                 * datas = [
                 *     ["1", "NewYork", "1968/6/8", "80", "180"],
                 *     ["4", "NewYork", "1972/7/3", "72", "168"],
                 *     ["4", "NewYork", "1964/3/2", "71", "179"],
                 *     ["5", "Washington", "1972/8/8","80", "171"],
                 *     ["6", "Washington", "1986/2/2", "89", "161"],
                 *     ["7", "Washington", "2012/2/15", "71", "240"]];
                 * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                 * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                 * table.setColumnName(0, dataColumns[0]);
                 * table.setColumnName(1, dataColumns[1]);
                 * table.setColumnName(2, dataColumns[2]);
                 * table.setColumnName(3, dataColumns[3]);
                 * table.setColumnName(4, dataColumns[4]);
                 * //add a slicer to the sheet and return the slicer instance.
                 * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                 * //change the slicer properties.
                 * slicer.width(200);
                 * slicer.height(200);
                 * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                 * slicer.style(GC.Spread.Sheets.Slicers.SlicerStyles.dark4());
                 * // Use IE to see the console log text
                 * activeSheet.bind(GC.Spread.Sheets.Events.SlicerChanged, function (e, info) {
                 * console.log("name: " + info.propertyName);
                 * });
                 */
                static SlicerChanged: string;
                /**
                 * Occurs when the sparkline has changed.
                 * @name GC.Spread.Sheets.Worksheet#SparklineChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.Sparklines.Sparkline} sparkline The sparkline whose property has changed.
                 * @example
                 * //Removing the sparkline causes a change.
                 * var data = new GC.Spread.Sheets.Range(1, 0, 8, 1);
                 * var setting = new GC.Spread.Sheets.Sparklines.SparklineSetting();
                 * setting.options.showMarkers = true;
                 * setting.options.lineWeight = 3;
                 * setting.options.displayXAxis = true;
                 * setting.options.showFirst = true;
                 * setting.options.showLast = true;
                 * setting.options.showLow = true;
                 * setting.options.showHigh = true;
                 * setting.options.showNegative = true;
                 * setting.options.seriesColor = "Text 2 1";
                 * setting.options.firstMarkerColor = "Text 2 3";
                 * setting.options.negativeColor = "Accent 2 1";
                 * setting.options.markersColor = "Accent 3 1";
                 * setting.options.lowMarkerColor = "Accent 4 1";
                 * setting.options.highMarkerColor = "Accent 6 1";
                 * setting.options.lastMarkerColor = "Accent 6 6";
                 * setting.options.axisColor = "Text 1 1";
                 * activeSheet.addSpan(13, 0, 4, 3, null);
                 * activeSheet.setSparkline(13, 0, data, GC.Spread.Sheets.Sparklines.DataOrientation.vertical, GC.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 * activeSheet.setValue(1, 0, 1);
                 * activeSheet.setValue(2, 0, -2);
                 * activeSheet.setValue(3, 0, -1);
                 * activeSheet.setValue(4, 0, 6);
                 * activeSheet.setValue(5, 0, 4);
                 * activeSheet.setValue(6, 0, -4);
                 * activeSheet.setValue(7, 0, 3);
                 * activeSheet.setValue(8, 0, 8);
                 * // Use IE to see the console log text
                 * activeSheet.bind(GC.Spread.Sheets.Events.SparklineChanged, function (e, info) {
                 *      console.log("name: " + info.sheetName);
                 * });
                 * $("#button1").click(function () {
                 *      activeSheet.removeSparkline(13, 0);
                 * });
                 */
                static SparklineChanged: string;
                /**
                 * Occurs when a table column has just been clear filter.
                 * @name GC.Spread.Sheets.Worksheet#TableFilterCleared
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.Tables.Table} table The table column to be automatically filtered.
                 * @param {number} tableCol The index of the table column has just been clear filter.
                 * @example
                 * //This example uses the TableFilterCleared event.
                 * activeSheet.tables.add("Table1", 0, 0, 3, 3, GC.Spread.Sheets.Tables.TableTheme.dark1);
                 * activeSheet.getCell(0,0).text("Name");
                 * activeSheet.getCell(0,1).text("Value");
                 * activeSheet.getCell(0,2).text("T/F");
                 * activeSheet.getCell(1,0).text("AW");
                 * activeSheet.getCell(1,1).text("5");
                 * activeSheet.getCell(1,2).text("T");
                 * activeSheet.bind(GC.Spread.Sheets.Events.TableFilterCleared, function (e, info) {
                 *        alert("Sheet (" + info.sheetName + ")");
                 * });
                 */
                static TableFilterCleared: string;
                /**
                 * Occurs when a table column is about to be automatically clear filter.
                 * @name GC.Spread.Sheets.Worksheet#TableFilterCleared
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.Tables.Table} table The table column to be automatically filtered.
                 * @param {number} tableCol The index of the table column to be automatically clear filter.
                 * @example
                 * //This example uses the TableFilterClearing event.
                 * activeSheet.tables.add("Table1", 0, 0, 3, 3, GC.Spread.Sheets.Tables.TableTheme.dark1);
                 * activeSheet.getCell(0,0).text("Name");
                 * activeSheet.getCell(0,1).text("Value");
                 * activeSheet.getCell(0,2).text("T/F");
                 * activeSheet.getCell(1,0).text("AW");
                 * activeSheet.getCell(1,1).text("5");
                 * activeSheet.getCell(1,2).text("T");
                 * activeSheet.bind(GC.Spread.Sheets.Events.TableFilterClearing, function (e, info) {
                 *        alert("Sheet (" + info.sheetName + ")");
                 * });
                 */
                static TableFilterClearing: string;
                /**
                 * Occurs when a table column has just been automatically filtered.
                 * @name GC.Spread.Sheets.Worksheet#TableFiltered
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.Tables.Table} table The table column to be automatically filtered.
                 * @param {number} col The index of the table column to be automatically filtered.
                 * @param {Array} filterValues The values by which to filter the column.
                 * @param {Object} conditionInfo The condition rule info by which to filter the column.
                 * @example
                 * //This example uses the TableFiltered event.
                 * activeSheet.tables.add("Table1", 0, 0, 3, 3, GC.Spread.Sheets.Tables.TableTheme.dark1);
                 * activeSheet.getCell(0,0).text("Name");
                 * activeSheet.getCell(0,1).text("Value");
                 * activeSheet.getCell(0,2).text("T/F");
                 * activeSheet.getCell(1,0).text("AW");
                 * activeSheet.getCell(1,1).text("5");
                 * activeSheet.getCell(1,2).text("T");
                 * activeSheet.bind(GC.Spread.Sheets.Events.TableFiltered, function (e, info) {
                 *        alert("Sheet (" + info.sheetName + ")");
                 * });
                 */
                static TableFiltered: string;
                /**
                 * Occurs when a table column is about to be automatically filtered.
                 * @name GC.Spread.Sheets.Worksheet#TableFiltering
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GC.Spread.Sheets.Tables.Table} table The table column to be automatically filtered.
                 * @param {number} col The index of the table column to be automatically filtered.
                 * @param {Array} filterValues The values by which to filter the column.
                 * @param {Object} conditionInfo The condition rule info by which to filter the column.
                 * @example
                 * //This example uses the TableFiltering event.
                 * activeSheet.tables.add("Table1", 0, 0, 3, 3, GC.Spread.Sheets.Tables.TableTheme.dark1);
                 * activeSheet.getCell(0,0).text("Name");
                 * activeSheet.getCell(0,1).text("Value");
                 * activeSheet.getCell(0,2).text("T/F");
                 * activeSheet.getCell(1,0).text("AW");
                 * activeSheet.getCell(1,1).text("5");
                 * activeSheet.getCell(1,2).text("T");
                 * activeSheet.bind(GC.Spread.Sheets.Events.TableFiltering, function (e, info) {
                 *        alert("Sheet (" + info.sheetName + ")");
                 * });
                 */
                static TableFiltering: string;
                /**
                 * Occurs when the top row changes.
                 * @name GC.Spread.Sheets.Worksheet#TopRowChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} oldTopRow The old top row index.
                 * @param {number} newTopRow The new top row index.
                 * @example
                 * //This example synchronizes vertical and horizontal scrolling for sheet 1 and sheet 2.
                 * var sheet1 = spread.getSheet(0),
                 * sheet2 = spread.getSheet(1);
                 * sheet1.bind(GC.Spread.Sheets.Events.TopRowChanged, function (sender, args) {
                 *     //Set the displayed top row of sheet1 to sheet2 (vertical scroll synchronization).
                 *     sheet2.showRow(args.newTopRow, GC.Spread.Sheets.VerticalPosition.top);
                 * });
                 * sheet1.bind(GC.Spread.Sheets.Events.LeftColumnChanged, function (sender, args) {
                 *     //Set the displayed left column of sheet1 to sheet2 (Horizontal scroll synchronization).
                 *     sheet2.showColumn(args.newLeftCol, GC.Spread.Sheets.HorizontalPosition.left);
                 * });
                 */
                static TopRowChanged: string;
                /**
                 * Occurs before the touch toolbar pops up.
                 * @name GC.Spread.Sheets.Worksheet#TouchToolStripOpening
                 * @event
                 * @param {number} x The <i>x</i>-coordinate of the horizontal position.
                 * @param {number} y The <i>y</i>-coordinate of the vertical position.
                 * @param {boolean} handled If <c>true</c>, the touch toolbar is prevented from popping up; otherwise, the toolbar is displayed at the default position.
                 * @example
                 * //This example uses the TouchToolStripOpening event.
                 *  activeSheet.bind(GC.Spread.Sheets.Events.TouchToolStripOpening, function (e, info) {
                 *         alert(info.x);
                 * });
                 */
                static TouchToolStripOpening: string;
                /**
                 * Occurs when the user types a formula.
                 * @name GC.Spread.Sheets.Worksheet#UserFormulaEntered
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index of the cell in which the user entered a formula.
                 * @param {number} col The column index of the cell in which the user entered a formula.
                 * @param {string} formula The formula that the user entered.
                 * @example
                 * //This example uses the UserFormulaEntered event.
                 *  activeSheet.bind(GC.Spread.Sheets.Events.UserFormulaEntered, function (e, info) {
                 *         alert("Formula (" + info.formula + ")");
                 * });
                 */
                static UserFormulaEntered: string;
                /**
                 * Occurs when the user zooms.
                 * @name GC.Spread.Sheets.Worksheet#UserZooming
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} oldZoomFactor The new zoom factor.
                 * @param {number} newZoomFactor The old zoom factor.
                 * @example
                 * //This example uses the UserZooming event.
                 * spread.options.allowUserZoom = true;
                 * activeSheet.bind(GC.Spread.Sheets.Events.UserZooming, function (e, info) {
                 *      alert("Zoom (" + info.newZoomFactor + ")");
                 * });
                 */
                static UserZooming: string;
                /**
                 * Occurs when the applied cell value is invalid.
                 * @name GC.Spread.Sheets.Worksheet#ValidationError
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The cell's row index.
                 * @param {number} col The cell's column index.
                 * @param {GC.Spread.Sheets.DataValidation.DefaultDataValidator} validator The data validator that caused the error.
                 * @param {GC.Spread.Sheets.DataValidation.DataValidationResult} validationResult The policy that the user can set to determine how to process the error.
                 * @example
                 * //This example uses the ValidationError event.
                 * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.cellValueCondition);
                 * nCondition.compareType(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.equalsTo);
                 * nCondition.expected(0);
                 * //When the option is false, the validation fails and the red alert is displayed.
                 * //When the option is true, the blank cell is treated as zero and the validation is successful.
                 * nCondition.treatNullValueAsZero(false);
                 * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition)
                 * validator.ignoreBlank(false);
                 * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.wholeNumber)
                 * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                 * spread.options.highlightInvalidData = true;
                 * activeSheet.setValue(0, 0, null);
                 * //Type different values in cell (0,0). This event fires if the user types an invalid value.
                 * activeSheet.bind("ValidationError", vError);
                 * function vError(sender, args) {
                 *     alert("error");
                 * }
                 */
                static ValidationError: string;
                /**
                 * Occurs when the value in the subeditor changes.
                 * @name GC.Spread.Sheets.Worksheet#ValueChanged
                 * @event
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index of the cell.
                 * @param {number} col The column index of the cell.
                 * @param {Object} oldValue The old value of the cell.
                 * @param {Object} newValue The new value of the cell.
                 * @example
                 * //This example uses the ValueChanged event.
                 * activeSheet.bind(GC.Spread.Sheets.Events.ValueChanged, function (e, info) {
                 *         alert("Value (" + info.newValue + ")");
                 * });
                 */
                static ValueChanged: string;
            }

            export class LineBorder{
                /**
                 * Represents the line border for a border side.
                 * @class
                 * @param {string} color Indicates the border color and uses a format such as color name (for example, "red") or "#RGB", "#RRGGBB", "rgb(R,B,B)", "rgba(R,G,B,A)".
                 * @param {GC.Spread.Sheets.LineStyle} style Indicates the border line style.
                 * @example
                 * //This example creates a border.
                 * var border = new GC.Spread.Sheets.LineBorder
                 * border.color = "#7FFFD4";
                 * border.style = GC.Spread.Sheets.LineStyle.double;
                 * var cell = activeSheet.getCell(1, 1, GC.Spread.Sheets.SheetArea.viewport);
                 * cell.borderLeft(border);
                 */
                constructor(color?:  string,  style?:  GC.Spread.Sheets.LineStyle);
                /**
                 * Indicates the color of the border line. Use a known color name or HEX style color value. The default value is black.
                 * @example
                 * //This example sets the color property.
                 * var border = new GC.Spread.Sheets.LineBorder
                 * border.color = "#7FFFD4";
                 * border.style = GC.Spread.Sheets.LineStyle.double;
                 * var cell = activeSheet.getCell(1, 1, GC.Spread.Sheets.SheetArea.viewport);
                 * cell.borderLeft(border);
                 */
                color: string;
                /**
                 * Indicates the line style of the border line. The default value is empty.
                 * @example
                 * //This example sets the style property.
                 * var border = new GC.Spread.Sheets.LineBorder
                 * border.color = "#7FFFD4";
                 * border.style = GC.Spread.Sheets.LineStyle.double;
                 * var cell = activeSheet.getCell(1, 1, GC.Spread.Sheets.SheetArea.viewport);
                 * cell.borderLeft(border);
                 */
                style: GC.Spread.Sheets.LineStyle;
            }

            export class NameInfo{
                /**
                 * Represents a custom named expression that can be used by formulas.
                 * @class
                 * @param {string} name The custom expression name.
                 * @param {Object} expr The custom named expression.
                 * @param {number} row The base row of the expression.
                 * @param {number} column The base column of the expression.
                 * @param {string} comment The custom expression comment.
                 */
                constructor(name:  string,  expr:  GC.Spread.CalcEngine.Expression,  row:  number,  column:  number,  comment:  string);
                /**
                 * Gets the base column of the custom named expression.
                 * @returns {number} The base column.
                 */
                getColumn(): number;
                /**
                 * Gets the comment of the current NameInfo object.
                 * @returns {string} The name of the current NameInfo object.
                 */
                getComment(): string;
                /**
                 * Gets the expression.
                 * @returns {GC.Spread.CalcEngine.Expression} The expression.
                 */
                getExpression(): GC.Spread.CalcEngine.Expression;
                /**
                 * Gets the name of the current NameInfo object.
                 * @returns {string} The name of the current NameInfo object.
                 */
                getName(): string;
                /**
                 * Gets the base row of the custom named expression.
                 * @returns {number} The base row.
                 */
                getRow(): number;
            }

            export class Point{
                /**
                 * Represents an <i>x</i>- and <i>y</i>-coordinate pair in two-dimensional space.
                 * @class
                 * @param {number} x The <i>x</i>-coordinate.
                 * @param {number} y The <i>y</i>-coordinate.
                 * @example
                 * //This example creates a floating object.
                 * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1");
                 * customFloatingObject.x(10);
                 * customFloatingObject.y(10);
                 * customFloatingObject.width(60);
                 * customFloatingObject.height(64);
                 * var btn = document.createElement('button');
                 * btn.style.width = "60px";
                 * btn.style.height = "30px";
                 * btn.innerText = "button";
                 * customFloatingObject.content(btn);
                 * activeSheet.floatingObjects.add(customFloatingObject);
                 */
                constructor(x:  number,  y:  number);
                /**
                 * Clones a new point from the current point.
                 * @returns {GC.Spread.Sheets.Point} The cloned object.
                 */
                clone(): GC.Spread.Sheets.Point;
            }

            export class Range{
                /**
                 * Represents a range, which is described by the row index, column index, row count, and column count.
                 * @class
                 * @param {number} r The row index.
                 * @param {number} c The column index.
                 * @param {number} rc The row count.
                 * @param {number} cc The column count.
                 * @example
                 * var style = new GC.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * var rule = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                 * rule.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                 * rule.ranges([new GC.Spread.Sheets.Range(0,0,5,1)]);
                 * rule.operator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between);
                 * rule.style(style);
                 * rule.value1(2);
                 * rule.value2(100);
                 * activeSheet.conditionalFormats.addRule(rule);
                 * activeSheet.setValue(0,0,1,3);
                 * activeSheet.setValue(1,0,45,3);
                 */
                constructor(r:  number,  c:  number,  rc: number,  cc: number);
                /**
                 * The column index.
                 * @example
                 * var cellrange = new GC.Spread.Sheets.Range();
                 * cellrange.col = 0;
                 * cellrange.row = 1;
                 * cellrange.colCount = 1;
                 * cellrange.rowCount = 8;
                 * activeSheet.setValue(1, 0, 1);
                 * activeSheet.setValue(2, 0, -2);
                 * activeSheet.setValue(3, 0, -1);
                 * activeSheet.setValue(4, 0, 6);
                 * activeSheet.setValue(5, 0, 4);
                 * activeSheet.setValue(6, 0, -4);
                 * activeSheet.setValue(7, 0, 3);
                 * activeSheet.setValue(8, 0, 8);
                 * var setting = new GC.Spread.Sheets.Sparklines.SparklineSetting();
                 * setting.options.showMarkers = true;
                 * activeSheet.setSparkline(13, 0, cellrange, GC.Spread.Sheets.Sparklines.DataOrientation.vertical, GC.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 */
                col: number;
                /**
                 * The column count.
                 * @example
                 * var cellrange = new GC.Spread.Sheets.Range();
                 * cellrange.col = 0;
                 * cellrange.row = 1;
                 * cellrange.colCount = 1;
                 * cellrange.rowCount = 8;
                 * activeSheet.setValue(1, 0, 1);
                 * activeSheet.setValue(2, 0, -2);
                 * activeSheet.setValue(3, 0, -1);
                 * activeSheet.setValue(4, 0, 6);
                 * activeSheet.setValue(5, 0, 4);
                 * activeSheet.setValue(6, 0, -4);
                 * activeSheet.setValue(7, 0, 3);
                 * activeSheet.setValue(8, 0, 8);
                 * var setting = new GC.Spread.Sheets.Sparklines.SparklineSetting();
                 * setting.options.showMarkers = true;
                 * activeSheet.setSparkline(13, 0, cellrange, GC.Spread.Sheets.Sparklines.DataOrientation.vertical, GC.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 */
                colCount: number;
                /**
                 * The row index.
                 * @example
                 * var cellrange = new GC.Spread.Sheets.Range();
                 * cellrange.col = 0;
                 * cellrange.row = 1;
                 * cellrange.colCount = 1;
                 * cellrange.rowCount = 8;
                 * activeSheet.setValue(1, 0, 1);
                 * activeSheet.setValue(2, 0, -2);
                 * activeSheet.setValue(3, 0, -1);
                 * activeSheet.setValue(4, 0, 6);
                 * activeSheet.setValue(5, 0, 4);
                 * activeSheet.setValue(6, 0, -4);
                 * activeSheet.setValue(7, 0, 3);
                 * activeSheet.setValue(8, 0, 8);
                 * var setting = new GC.Spread.Sheets.Sparklines.SparklineSetting();
                 * setting.options.showMarkers = true;
                 * activeSheet.setSparkline(13, 0, cellrange, GC.Spread.Sheets.Sparklines.DataOrientation.vertical, GC.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 */
                row: number;
                /**
                 * The row count.
                 * @example
                 * var cellrange = new GC.Spread.Sheets.Range();
                 * cellrange.col = 0;
                 * cellrange.row = 1;
                 * cellrange.colCount = 1;
                 * cellrange.rowCount = 8;
                 * activeSheet.setValue(1, 0, 1);
                 * activeSheet.setValue(2, 0, -2);
                 * activeSheet.setValue(3, 0, -1);
                 * activeSheet.setValue(4, 0, 6);
                 * activeSheet.setValue(5, 0, 4);
                 * activeSheet.setValue(6, 0, -4);
                 * activeSheet.setValue(7, 0, 3);
                 * activeSheet.setValue(8, 0, 8);
                 * var setting = new GC.Spread.Sheets.Sparklines.SparklineSetting();
                 * setting.options.showMarkers = true;
                 * activeSheet.setSparkline(13, 0, cellrange, GC.Spread.Sheets.Sparklines.DataOrientation.vertical, GC.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 */
                rowCount: number;
                /**
                 * Gets whether the current range contains the specified cell.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {number} rowCount The row count.
                 * @param {number} colCount The column count.
                 * @returns {boolean} <c>true</c> if the range contains the cell; otherwise, <c>false</c>.
                 */
                contains(row:  number,  col:  number,  rowCount:  number,  colCount:  number): boolean;
                /**
                 * Gets whether the current range contains the specified range.
                 * @param {GC.Spread.Sheets.Range} range The cell range.
                 * @returns {boolean} <c>true</c> if the current range contains the specified cell range; otherwise, <c>false</c>.
                 */
                containsRange(range:  GC.Spread.Sheets.Range): boolean;
                /**
                 * Gets whether the current range is equal to the specified range.
                 * @param {GC.Spread.Sheets.Range} range The range to compare.
                 * @returns {boolean} <c>true</c> if the current range is equal to the specified range; otherwise, <c>false</c>.
                 */
                equals(range:  GC.Spread.Sheets.Range): boolean;
                /**
                 * Gets the intersection of two cell ranges.
                 * @param {GC.Spread.Sheets.Range} range The cell range.
                 * @param {number} maxRowCount The maximum row count.
                 * @param {number} maxColumnCount The maximum column count.
                 * @returns {GC.Spread.Sheets.Range} Returns null if there is no intersection, or the cell range of the intersection.
                 */
                getIntersect(range:  GC.Spread.Sheets.Range,  maxRowCount:  number,  maxColumnCount:  number): GC.Spread.Sheets.Range;
                /**
                 * Gets whether the current range intersects with the one specified by the row and column index and the row and column count.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {number} rowCount The row count.
                 * @param {number} colCount The column count.
                 * @returns {boolean} <c>true</c> if the specified range intersects with the current range; otherwise <c>false</c>.
                 */
                intersect(row:  number,  col:  number,  rowCount:  number,  colCount:  number): boolean;
                /**
                 * Offsets the location of the range by the specified coordinates.
                 * @param {number} x The offset along the <i>x</i>-axis.
                 * @param {number} y The offset along the <i>y</i>-axis.
                 * @returns {GC.Spread.Sheets.Range} The new location.
                 */
                offset(x:  number,  y:  number): GC.Spread.Sheets.Range;
                /**
                 * Joins this range with the specified range as a union.
                 * @param {GC.Spread.Sheets.Range} range The target range.
                 * @returns {GC.Spread.Sheets.Range} Returns the union of the ranges.
                 */
                union(range:  GC.Spread.Sheets.Range): GC.Spread.Sheets.Range;
            }

            export class Rect{
                /**
                 * Represents a rectangle with a special location, and its width and height in two-dimensional space.
                 * @class
                 * @param {number} x The <i>x</i>-coordinate of the top-left corner of the rectangle.
                 * @param {number} y The <i>y</i>-coordinate of the top-left corner of the rectangle.
                 * @param {number} w The width of the rectangle.
                 * @param {number} h The height of the rectangle.
                 */
                constructor(x:  number,  y:  number,  w:  number,  h:  number);
                /**
                 * The width of the rectangle.
                 */
                height: number;
                /**
                 * The height of the rectangle.
                 */
                width: number;
                /**
                 * The <i>x</i>-coordinate of the top-left corner of the rectangle.
                 */
                x: number;
                /**
                 * The <i>y</i>-coordinate of the top-left corner of the rectangle.
                 */
                y: number;
                /**
                 * Indicates whether the rectangle contains the specified <i>x</i>-coordinate and <i>y</i>-coordinate.
                 * @param {number} x The <i>x</i>-coordinate of the point to check.
                 * @param {number} y The <i>y</i>-coordinate of the point to check.
                 * @returns {boolean} <c>true</c> if (x, y) is contained by the rectangle; otherwise, <c>false</c>.
                 */
                contains(x:  number,  y:  number): boolean;
                /**
                 * Gets the rectangle that intersects with the current rectangle.
                 * @param {GC.Spread.Sheets.Rect} rect The rectangle.
                 * @returns {GC.Spread.Sheets.Rect} The intersecting rectangle. If the two rectangles do not intersect, returns null.
                 */
                getIntersectRect(x:  number,  y:  number,  width:  number,  height:  number): GC.Spread.Sheets.Rect;
                /**
                 * Indicates whether the specified rectangle intersects with the current rectangle.
                 * @param {number} x The <i>x</i>-coordinate of the top-left corner of the rectangle.
                 * @param {number} y The <i>y</i>-coordinate of the top-left corner of the rectangle.
                 * @param {number} w The width of the rectangle.
                 * @param {number} h The height of the rectangle.
                 * @returns {boolean} <c>true</c> if the specified rectangle intersects with the current rectangle; otherwise, <c>false</c>.
                 */
                intersect(x:  number,  y:  number,  width:  number,  height:  number): boolean;
                /**
                 * Indicates whether the specified rectangle intersects with the current rectangle.
                 * @param {GC.Spread.Sheets.Rect} rect The specified rectangle.
                 * @returns {boolean} <c>true</c> if the specified rectangle intersects with the current rectangle; otherwise, <c>false</c>.
                 */
                intersectRect(rect:  GC.Spread.Sheets.Rect): boolean;
            }

            export class Style{
                /**
                 * Represents the style for a cell, row, and column.
                 * @class
                 * @param {string} backColor The background color.
                 * @param {string} foreColor The foreground color.
                 * @param {GC.Spread.Sheets.HorizontalAlign} hAlign The horizontal alignment.
                 * @param {GC.Spread.Sheets.VerticalAlign} vAlign The vertical alignment.
                 * @param {string} font The font.
                 * @param {string} themeFont The font theme.
                 * @param {string|object} formatter The formatting object.
                 * @param {GC.Spread.Sheets.LineBorder} borderLeft The left border.
                 * @param {GC.Spread.Sheets.LineBorder} borderTop The top border.
                 * @param {GC.Spread.Sheets.LineBorder} borderRight The right border.
                 * @param {GC.Spread.Sheets.LineBorder} borderBottom The bottom border.
                 * @param {GC.Spread.Sheets.LineBorder} diagonalDown The diagonal with LeftTop to bottomRight.
                 * @param {GC.Spread.Sheets.LineBorder} diagonalUp The diagonal with topRight to bottomLeft.
                 * @param {boolean} locked Whether the cell, row, or column is locked.
                 * @param {number} textIndent The text indent amount.
                 * @param {boolean} wordWrap Whether words wrap within the cell or cells.
                 * @param {boolean} shrinkToFit Whether content shrinks to fit the cell or cells.
                 * @param {string} backgroundImage The background image to display.
                 * @param {GC.Spread.Sheets.CellTypes.Base} cellType The cell type.
                 * @param {GC.Spread.Sheets.ImageLayout} backgroundImageLayout The layout for the background image.
                 * @param {boolean} tabStop Whether the user can set focus to the cell using the Tab key.
                 * @param {GC.Spread.Sheets.TextDecorationType} textDecoration Specifies the decoration added to text.
                 * @param {GC.Spread.Sheets.ImeMode} imeMode Specifies the input method editor mode.
                 * @param {string} name Specifies the name.
                 * @param {string} parentName Specifies the name of the parent style.
                 * @param {string} watermark Specifies the watermark content.
                 * @param {string} cellPadding Specifies the cell padding.
                 * @param {Object} labelOptions Specifies the cell label options.
                 * @param {GC.Spread.Sheets.LabelAlignment} [labelOptions.alignment] The cell label position.
                 * @param {GC.Spread.Sheets.LabelVisibility} [labelOptions.visibility] The cell label visibility.
                 * @param {string} [labelOptions.font] The cell label font.
                 * @param {string} [labelOptions.foreColor] The cell label forecolor.
                 * @param {string} [labelOptions.margin] The cell label margin.
                 * @param {boolean} isVerticalText Whether to set the cell's text vertical
                 * @example
                 * //This example uses a style with rules.
                 * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                 * var style = new GC.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.foreColor = "black";
                 * var cell = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                 * cell.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                 * cell.operator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                 * cell.value1(5);
                 * cell.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                 * cell.style(style);
                 * activeSheet.conditionalFormats.addRule(cell);
                 * var style1 = new GC.Spread.Sheets.Style();
                 * style1.foreColor = "red";
                 * var top = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                 * top.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.top10Rule);
                 * top.type(GC.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top);
                 * top.rank(3);
                 * top.style(style1);
                 * top.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                 * top.stopIfTrue(true);
                 * activeSheet.conditionalFormats.addRule(top);
                 * @example
                 * //This example creates and sets parameters for the style.
                 * sheet.setValue(0,0, 1,3);
                 * sheet.setValue(1,0, 50,3);
                 * sheet.setValue(2,0, 100,3);
                 * sheet.setValue(3,0, 2,3);
                 * sheet.setValue(4,0, 60,3);
                 * sheet.setValue(5,0, 90,3);
                 * sheet.setValue(6,0, 3,3);
                 * sheet.setValue(7,0, 40,3);
                 * sheet.setValue(8,0, 70,3);
                 * sheet.setValue(9,0, 5,3);
                 * sheet.setValue(10,0, 35,3);
                 * var style = new GC.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.borderLeft =new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderTop = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderRight = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderBottom =  new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * sheet.conditionalFormats.addAverageRule(GC.Spread.Sheets.ConditionalFormatting.AverageConditionType.above, style, [new GC.Spread.Sheets.Range(0, 0, 10, 3)]);
                 */
                constructor(backColor?:  string,  foreColor?:  string,  hAlign?:  GC.Spread.Sheets.HorizontalAlign,  vAlign?:  GC.Spread.Sheets.VerticalAlign,  font?:  any,  themeFont?:  string,  formatter?:  any,  borderLeft?:  GC.Spread.Sheets.LineBorder,  borderTop?:  GC.Spread.Sheets.LineBorder,  borderRight?:  GC.Spread.Sheets.LineBorder,  borderBottom?:  GC.Spread.Sheets.LineBorder,  locked?:  boolean,  textIndent?:  number,  wordWrap?:  boolean,  shrinkToFit?:  boolean,  backgroundImage?:  any,  cellType?:  any,  backgroundImageLayout?:  GC.Spread.Sheets.ImageLayout,  tabStop?:  boolean,  textDecoration?:  GC.Spread.Sheets.TextDecorationType,  imeMode?:  GC.Spread.Sheets.ImeMode,  name?:  string,  parentName?:  string,  watermark?:  string,  cellPadding?:  string,  labelOptions?:  Object,  diagonalDown?:  GC.Spread.Sheets.LineBorder,  diagonalUp?:  GC.Spread.Sheets.LineBorder,  isVerticalText?:  boolean);
                /**
                 * Indicates the background color.
                 * @type {string}
                 * @example
                 * //This example sets the style backColor property.
                 * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                 * var style = new GC.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.foreColor = "black";
                 * var cell = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                 * cell.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                 * cell.operator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                 * cell.value1(5);
                 * cell.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                 * cell.style(style);
                 * activeSheet.conditionalFormats.addRule(cell);
                 * var style1 = new GC.Spread.Sheets.Style();
                 * style1.foreColor = "red";
                 * var top = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                 * top.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.top10Rule);
                 * top.type(GC.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top);
                 * top.rank(3);
                 * top.style(style1);
                 * top.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                 * top.stopIfTrue(true);
                 * activeSheet.conditionalFormats.addRule(top);
                 */
                backColor: string;
                /**
                 * Indicates the background image.
                 * @type {string}
                 * @example
                 * //This example sets the backgroundImage property.
                 * var style = new GC.Spread.Sheets.Style();
                 * style.backColor = "lightgreen";
                 * style.backgroundImage = "./css/images/quarter1.png";
                 * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
                 */
                backgroundImage: string;
                /**
                 * Indicates the background image layout.
                 * @type {GC.Spread.Sheets.ImageLayout}
                 * @example
                 * //This example sets the backgroundImageLayout property.
                 * var style = new GC.Spread.Sheets.Style();
                 * style.backColor = "lightgreen";
                 * style.backgroundImage = "./css/images/quarter1.png";
                 * style.backgroundImageLayout  = GC.Spread.Sheets.ImageLayout.center;
                 * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
                 */
                backgroundImageLayout: GC.Spread.Sheets.ImageLayout;
                /**
                 * Indicates the bottom border line.
                 * @type {GC.Spread.Sheets.LineBorder}
                 * @example
                 * //This example creates a border.
                 * var cellType = new GC.Spread.Sheets.CellTypes.Button();
                 * cellType.buttonBackColor("#FFFF00");
                 * cellType.text("this is a button");
                 * var style = new GC.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.borderLeft =new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderTop = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderRight = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderBottom = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.cellType = cellType
                 * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
                 */
                borderBottom: GC.Spread.Sheets.LineBorder;
                /**
                 * Indicates the left border line.
                 * @type {GC.Spread.Sheets.LineBorder}
                 * @example
                 * //This example creates a border.
                 * var cellType = new GC.Spread.Sheets.CellTypes.Button();
                 * cellType.buttonBackColor("#FFFF00");
                 * cellType.text("this is a button");
                 * var style = new GC.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.borderLeft =new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderTop = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderRight = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderBottom = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.cellType = cellType
                 * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
                 */
                borderLeft: GC.Spread.Sheets.LineBorder;
                /**
                 * Indicates the right border line.
                 * @type {GC.Spread.Sheets.LineBorder}
                 * @example
                 * //This example creates a border.
                 * var cellType = new GC.Spread.Sheets.CellTypes.Button();
                 * cellType.buttonBackColor("#FFFF00");
                 * cellType.text("this is a button");
                 * var style = new GC.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.borderLeft =new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderTop = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderRight = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderBottom = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.cellType = cellType
                 * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
                 */
                borderRight: GC.Spread.Sheets.LineBorder;
                /**
                 * Indicates the top border line.
                 * @type {GC.Spread.Sheets.LineBorder}
                 * @example
                 * //This example creates a border.
                 * var cellType = new GC.Spread.Sheets.CellTypes.Button();
                 * cellType.buttonBackColor("#FFFF00");
                 * cellType.text("this is a button");
                 * var style = new GC.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.borderLeft =new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderTop = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderRight = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderBottom = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.cellType = cellType
                 * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
                 */
                borderTop: GC.Spread.Sheets.LineBorder;
                /**
                 * Indicates the cell padding.
                 * @type {string}
                 * @example
                 * //This example sets the cell padding for the watermark.
                 * var type = new GC.Spread.Sheets.Style();
                 * type.watermark = "User name";
                 * type.cellPadding = "20";
                 * type.labelOptions = {alignment:GC.Spread.Sheets.LabelAlignment.topLeft, visibility: GC.Spread.Sheets.LabelVisibility.visible};
                 * activeSheet.setStyle(0, 1, type);
                 * activeSheet.getRange(0, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).height(60);
                 * activeSheet.getRange(-1, 1, -1, 1).width(150);
                 * var combo = new GC.Spread.Sheets.CellTypes.ComboBox();
                 * combo.items([{ text: "Oranges", value: "11k" }, { text: "Apples", value: "15k" }, { text: "Grape", value: "100k" }]);
                 * combo.editorValueType(GC.Spread.Sheets.CellTypes.EditorValueType.text);
                 * activeSheet.setCellType(2, 1, combo, GC.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(2, 1, GC.Spread.Sheets.SheetArea.viewport).watermark("ComboBox Cell Type").cellPadding('10 10 20 10');
                 * activeSheet.getCell(2, 1, GC.Spread.Sheets.SheetArea.viewport).labelOptions({alignment: GC.Spread.Sheets.LabelAlignment.bottomCenter, foreColor: 'yellowgreen', font: 'bold 15px Arial'});
                 * activeSheet.getRange(2, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).height(60);
                 */
                cellPadding: string;
                /**
                 * Indicates the cell type.
                 * @type {GC.Spread.Sheets.CellTypes.Base}
                 * @example
                 * //This example creates a style and applies it to a cell.
                 * var cellType = new GC.Spread.Sheets.CellTypes.Button();
                 * cellType.buttonBackColor("#FFFF00");
                 * cellType.text("this is a button");
                 * var style = new GC.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.borderLeft =new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderTop = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderRight = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderBottom = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.cellType = cellType
                 * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
                 */
                cellType: any;
                /**
                 * Indicates the diagonalDown border line.
                 * @type {GC.Spread.Sheets.LineBorder}
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GC.Spread.Sheets.SheetArea.viewport).diagonalDown(new GC.Spread.Sheets.LineBorder("blue", GC.Spread.Sheets.LineStyle.mediumDashed));
                 */
                diagonalDown: GC.Spread.Sheets.LineBorder;
                /**
                 * Indicates the diagonalUp border line.
                 * @type {GC.Spread.Sheets.LineBorder}
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GC.Spread.Sheets.SheetArea.viewport).diagonalUp(new GC.Spread.Sheets.LineBorder("blue", GC.Spread.Sheets.LineStyle.mediumDashed));
                 */
                diagonalUp: GC.Spread.Sheets.LineBorder;
                /**
                 * Indicates the font.
                 * @type {string}
                 * @example
                 * //This example sets the font property.
                 * var style = new GC.Spread.Sheets.Style();
                 * style.font = "8pt Arial";
                 * style.hAlign = GC.Spread.Sheets.HorizontalAlign.center;
                 * style.vAlign = GC.Spread.Sheets.VerticalAlign.center;
                 * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(1,1).value("B2");
                 */
                font: string;
                /**
                 * Indicates the foreground color.
                 * @type {string}
                 * @example
                 * //This example sets the foreColor property.
                 * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                 * var style = new GC.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.foreColor = "black";
                 * var cell = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                 * cell.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                 * cell.operator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                 * cell.value1(5);
                 * cell.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                 * cell.style(style);
                 * activeSheet.conditionalFormats.addRule(cell);
                 * var style1 = new GC.Spread.Sheets.Style();
                 * style1.foreColor = "red";
                 * var top = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                 * top.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.top10Rule);
                 * top.type(GC.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top);
                 * top.rank(3);
                 * top.style(style1);
                 * top.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                 * top.stopIfTrue(true);
                 * activeSheet.conditionalFormats.addRule(top);
                 */
                foreColor: string;
                /**
                 * Indicates the formatter.
                 * @type {string|GC.Spread.Formatter.GeneralFormatter}
                 * @example
                 * //This example uses the formatter property.
                 * var style = new GC.Spread.Sheets.Style();
                 * style.formatter = "0.000%";
                 * style.themeFont = "Body";
                 * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(1,1).value("11");
                 */
                formatter: any;
                /**
                 * Indicates the horizontal alignment.
                 * @type {GC.Spread.Sheets.HorizontalAlign}
                 * @example
                 * //This example sets the hAlign property.
                 * var style = new GC.Spread.Sheets.Style();
                 * style.font = "8pt Arial";
                 * style.hAlign = GC.Spread.Sheets.HorizontalAlign.center;
                 * style.vAlign = GC.Spread.Sheets.VerticalAlign.center;
                 * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(1,1).value("B2");
                 */
                hAlign: GC.Spread.Sheets.HorizontalAlign;
                /**
                 * Indicates the Input Method Editor (IME) mode.
                 * @type {GC.Spread.Sheets.ImeMode}
                 * @example
                 * //This example sets the IME mode.
                 * var style = new GC.Spread.Sheets.Style();
                 * style.imeMode = GC.Spread.Sheets.ImeMode.auto;
                 * activeSheet.setStyle(0, 0, style);
                 */
                imeMode: GC.Spread.Sheets.ImeMode;
                /**
                 * Indicates whether to set the text vertical.
                 * @type {number}
                 * @example
                 * //This example uses the rotate property.
                 * var style = new GC.Spread.Sheets.Style();
                 * style.isVerticalText = true;
                 * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
                 */
                isVerticalText: boolean;
                /**
                 * Indicates the cell label options.
                 * @property {GC.Spread.Sheets.LabelAlignment} [alignment] - The cell label position.
                 * @property {GC.Spread.Sheets.LabelVisibility} [visibility] - The cell label visibility.
                 * @property {string} [font] - The cell label font.
                 * @property {string} [foreColor] - The cell label forecolor.
                 * @property {string} [margin] - The cell label margin.
                 * @type {Object}
                 * @example
                 * //This example sets label options for the watermark.
                 * var type = new GC.Spread.Sheets.Style();
                 * type.watermark = "User name";
                 * type.cellPadding = "20";
                 * type.labelOptions = {alignment:GC.Spread.Sheets.LabelAlignment.topLeft, visibility: GC.Spread.Sheets.LabelVisibility.visible};
                 * activeSheet.setStyle(0, 1, type);
                 * activeSheet.getRange(0, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).height(60);
                 * activeSheet.getRange(-1, 1, -1, 1).width(150);
                 * var combo = new GC.Spread.Sheets.CellTypes.ComboBox();
                 * combo.items([{ text: "Oranges", value: "11k" }, { text: "Apples", value: "15k" }, { text: "Grape", value: "100k" }]);
                 * combo.editorValueType(GC.Spread.Sheets.CellTypes.EditorValueType.text);
                 * activeSheet.setCellType(2, 1, combo, GC.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(2, 1, GC.Spread.Sheets.SheetArea.viewport).watermark("ComboBox Cell Type").cellPadding('10 10 20 10');
                 * activeSheet.getCell(2, 1, GC.Spread.Sheets.SheetArea.viewport).labelOptions({alignment: GC.Spread.Sheets.LabelAlignment.bottomCenter, foreColor: 'yellowgreen', font: 'bold 15px Arial'});
                 * activeSheet.getRange(2, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).height(60);
                 */
                labelOptions: Object;
                /**
                 * Indicates whether a cell is marked as locked from editing.
                 * @type {boolean}
                 * @example
                 * //This example unlocks a single cell.
                 * activeSheet.options.isProtected = true;
                 * var style = new GC.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.borderLeft =new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderTop = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderRight = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderBottom = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.locked = false;
                 * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
                 */
                locked: boolean;
                /**
                 * Indicates the name.
                 * @type {string}
                 * @example
                 * //This example sets the style name.
                 * var namedStyle = new GC.Spread.Sheets.Style();
                 * namedStyle.name = "style1";
                 * namedStyle.backColor = "green";
                 * activeSheet.addNamedStyle(namedStyle);
                 * activeSheet.setStyleName(1, 1, "style1"); // cell(1,1)'s backColor is green.
                 * var namedStyle1 = new GC.Spread.Sheets.Style();
                 * namedStyle1.name = "style2";
                 * namedStyle1.parentName = "style1";
                 * namedStyle1.foreColor = "red";    // the namedStyle's foreColor is red.
                 * activeSheet.addNamedStyle(namedStyle1);
                 * activeSheet.setStyleName(2, 1, "style2");
                 */
                name: string;
                /**
                 * Indicates the name of the parent style.
                 * @type {string}
                 * @example
                 * //This example sets the parent name.
                 * var namedStyle = new GC.Spread.Sheets.Style();
                 * namedStyle.name = "style1";
                 * namedStyle.backColor = "green";
                 * activeSheet.addNamedStyle(namedStyle);
                 * activeSheet.setStyleName(1, 1, "style1"); // cell(1,1)'s backColor is green.
                 * var namedStyle1 = new GC.Spread.Sheets.Style();
                 * namedStyle1.name = "style2";
                 * namedStyle1.parentName = "style1";
                 * namedStyle1.foreColor = "red";    // the namedStyle's foreColor is red.
                 * activeSheet.addNamedStyle(namedStyle1);
                 * activeSheet.setStyleName(2, 1, "style2");
                 */
                parentName: string;
                /**
                 * Indicates whether to shrink to fit.
                 * @type {boolean}
                 * @example
                 * //This example sets the shrinkToFit property.
                 * var style = new GC.Spread.Sheets.Style();
                 * style.shrinkToFit = true;
                 * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(1,1).text("Shrink To Fit");
                 */
                shrinkToFit: boolean;
                /**
                 * Indicates whether the user can set focus to the cell using the Tab key.
                 * @type {boolean}
                 * @example
                 * //This example sets the tabStop property.
                 * var style = new GC.Spread.Sheets.Style();
                 * style.tabStop = false;
                 * style.backColor = "lightgreen";
                 * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
                 */
                tabStop: boolean;
                /**
                 * Indicates the decoration added to text.
                 * @type {GC.Spread.Sheets.TextDecorationType}
                 * @example
                 * //This example uses the textDecoration property.
                 * activeSheet.getCell(0, 0).textDecoration(GC.Spread.Sheets.TextDecorationType.underline);
                 * activeSheet.getRange(1, -1, 1, -1).textDecoration(GC.Spread.Sheets.TextDecorationType.overline | GC.Spread.Sheets.TextDecorationType.underline);
                 * activeSheet.getRange(-1, 1, -1, 1).textDecoration(GC.Spread.Sheets.TextDecorationType.overline | GC.Spread.Sheets.TextDecorationType.lineThrough | GC.Spread.Sheets.TextDecorationType.underline);
                 * var style = new GC.Spread.Sheets.Style();
                 * style.textDecoration = GC.Spread.Sheets.TextDecorationType.overline | GC.Spread.Sheets.TextDecorationType.underline;
                 * activeSheet.setStyle(1, 1, style, GC.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(0, 0).value("Test");
                 * activeSheet.getCell(1, 0).value("Test");
                 * activeSheet.getCell(0, 1).value("Test");
                 */
                textDecoration: GC.Spread.Sheets.TextDecorationType;
                /**
                 * Indicates the number of units of indentation for text in a cell, an integer value, where an increment of 1 represents 8 pixels.
                 * @type {number}
                 * @example
                 * //This example sets the textIndent property.
                 * var style = new GC.Spread.Sheets.Style();
                 * style.textIndent = 3;
                 * // Enter multiple lines with Alt+Enter
                 * style.wordWrap = true;
                 * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(1,1).text("Test");
                 */
                textIndent: number;
                /**
                 * Indicates the font theme.
                 * @type {string}
                 * @example
                 * //This example uses the themeFont property.
                 * var style = new GC.Spread.Sheets.Style();
                 * style.formatter = "0.000%";
                 * style.themeFont = "Body";
                 * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(1,1).value("11");
                 */
                themeFont: string;
                /**
                 * Indicates the vertical alignment.
                 * @type {GC.Spread.Sheets.VerticalAlign}
                 * @example
                 * //This example sets the vAlign property.
                 * var style = new GC.Spread.Sheets.Style();
                 * style.font = "8pt Arial";
                 * style.hAlign = GC.Spread.Sheets.HorizontalAlign.center;
                 * style.vAlign = GC.Spread.Sheets.VerticalAlign.center;
                 * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(1,1).value("B2");
                 */
                vAlign: GC.Spread.Sheets.VerticalAlign;
                /**
                 * Indicates the watermark content.
                 * @type {string}
                 * @example
                 * //The following examples add watermarks to cells, columns, and rows.
                 * var type = new GC.Spread.Sheets.Style();
                 * type.watermark = "User name";
                 * sheet.setStyle(0, 1, type);
                 * var type = new GC.Spread.Sheets.Style();
                 * type.watermark = "Password";
                 * sheet.setStyle(1, 1, type);
                 * @example
                 * var type = new GC.Spread.Sheets.Style();
                 * type.watermark = "The watermark.";
                 * activeSheet.setStyle(-1, 1, type);
                 * activeSheet.setStyle(1, -1, type);
                 * activeSheet.setStyle(2, 2, type);
                 */
                watermark: string;
                /**
                 * Indicates whether to wrap text.
                 * @type {boolean}
                 * @example
                 * //This example sets the wordWrap property.
                 * var style = new GC.Spread.Sheets.Style();
                 * style.textIndent = 3;
                 * // Enter multiple lines with Alt+Enter
                 * style.wordWrap = true;
                 * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(1,1).text("Test");
                 */
                wordWrap: boolean;
                /**
                 * Clones the current style.
                 * @returns {GC.Spread.Sheets.Style} The cloned style.
                 */
                clone(): GC.Spread.Sheets.Style;
            }

            export class Theme{
                /**
                 * Represents a color scheme.
                 * @class
                 * @param {string} name The name of the theme.
                 * @param {GC.Spread.Sheets.ColorScheme} colorScheme The base colors of the theme color.
                 * @param {string} headerFont The name of the heading font.
                 * @param {string} bodyFont The name of the body font.
                 * @example
                 * //This example creates a new SpreadTheme object.
                 * sheet.getCell(0, 0).backColor("accent 1");
                 * sheet.getCell(1, 0).backColor("accent 6");
                 * $("#btn").click(function () {
                 *     var custom = new GC.Spread.Sheets.Theme("Custom");
                 *     custom.colors().accent1("red");
                 *     custom.colors().accent6("green");
                 *     sheet.currentTheme(custom);
                 * })
                 */
                constructor(name:  string,  colorScheme:  ColorScheme,  headerFont:  string,  bodyFont:  string);
                /**
                 * Gets or sets the body font of the theme.
                 * @param {string} value The body font.
                 * @returns {string|GC.Spread.Sheets.Theme} If no value is set, returns the body font; otherwise, returns the theme.
                 */
                bodyFont(value?:  string): any;
                /**
                 * Gets or sets the base colors of the theme.
                 * @param {GC.Spread.Sheets.ColorScheme} value The base colors of the theme.
                 * @returns {GC.Spread.Sheets.ColorScheme|GC.Spread.Sheets.Theme} If no value is set, returns the base colors of the theme; otherwise, returns the theme.
                 */
                colors(value?:  GC.Spread.Sheets.ColorScheme): any;
                /**
                 * Gets or sets the heading font of the theme.
                 * @param {string} value The heading font.
                 * @returns {string|GC.Spread.Sheets.Theme} If no value is set, returns the heading font; otherwise, returns the theme.
                 */
                headerFont(value?:  string): any;
                /**
                 * Gets or sets the name of the theme.
                 * @param {string} value The theme name.
                 * @returns {string|GC.Spread.Sheets.Theme} If no value is set, returns the theme name; otherwise, returns the theme.
                 */
                name(value?:  string): any;
            }

            export class ThemeColors{
                /**
                 * Represents the theme color of built-in themes.
                 * @class
                 * @example
                 * //This example creates a custom theme.
                 * var custom = new GC.Spread.Sheets.Theme("CustomTheme");
                 * custom.colors().accent1("red");
                 * custom.colors().accent6("green");
                 * custom.colors().textColor1("orange");
                 * activeSheet.currentTheme(custom);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("accent 1 30");
                 */
                constructor();
                /**
                 * The theme color of the Apex theme.
                 * @example
                 * //This example uses the Apex theme.
                 * activeSheet.currentTheme("Apex");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Apex: ColorScheme;
                /**
                 * The theme color of the Aspect theme.
                 * @example
                 * //This example uses the Aspect theme.
                 * activeSheet.currentTheme("Aspect");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Aspect: ColorScheme;
                /**
                 * The theme color of the Civic theme.
                 * @example
                 * //This example uses the Civic theme.
                 * activeSheet.currentTheme("Civic");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Civic: ColorScheme;
                /**
                 * The theme color of the Concourse theme.
                 * @example
                 * //This example uses the Concourse theme.
                 * activeSheet.currentTheme("Concourse");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Concourse: ColorScheme;
                /**
                 * The theme color of the Default theme.
                 * @example
                 * //This example sets the Default theme.
                 * activeSheet.currentTheme("Default");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Default: ColorScheme;
                /**
                 * The theme color of the Equity theme.
                 * @example
                 * //This example sets the Equity theme.
                 * activeSheet.currentTheme("Equity");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Equity: ColorScheme;
                /**
                 * The theme color of the Flow theme.
                 * @example
                 * //This example sets the Flow theme.
                 * activeSheet.currentTheme("Flow");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Flow: ColorScheme;
                /**
                 * The theme color of the Foundry theme.
                 * @example
                 * //This example sets the Foundry theme.
                 * activeSheet.currentTheme("Foundry");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Foundry: ColorScheme;
                /**
                 * The theme color of the Median theme.
                 * @example
                 * //This example sets the Median theme.
                 * activeSheet.currentTheme("Median");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Median: ColorScheme;
                /**
                 * The theme color of the Metro theme.
                 * @example
                 * //This example sets the Metro theme.
                 * activeSheet.currentTheme("Metro");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Metro: ColorScheme;
                /**
                 * The theme color of the Module theme.
                 * @example
                 * //This example sets the Module theme.
                 * activeSheet.currentTheme("Module");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Module: ColorScheme;
                /**
                 * The theme color of the Office theme.
                 * @example
                 * //This example sets the Office theme.
                 * activeSheet.currentTheme("Office");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Office: ColorScheme;
                /**
                 * The theme color of the Office 2007 theme.
                 * @example
                 * //This example uses the Office2007 theme.
                 * activeSheet.currentTheme("Office2007");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Office2007: ColorScheme;
                /**
                 * The theme color of the Opulent theme.
                 * @example
                 * //This example sets the Opulent theme.
                 * activeSheet.currentTheme("Opulent");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Opulent: ColorScheme;
                /**
                 * The theme color of the Oriel theme.
                 * @example
                 * //This example sets the Oriel theme.
                 * activeSheet.currentTheme("Oriel");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Oriel: ColorScheme;
                /**
                 * The theme color of the Origin theme.
                 * @example
                 * //This example sets the Origin theme.
                 * activeSheet.currentTheme("Origin");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Origin: ColorScheme;
                /**
                 * The theme color of the Paper theme.
                 * @example
                 * //This example sets the Paper theme.
                 * activeSheet.currentTheme("Paper");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Paper: ColorScheme;
                /**
                 * The theme color of the Solstice theme.
                 * @example
                 * //This example sets the Solstice theme.
                 * activeSheet.currentTheme("Solstice");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Solstice: ColorScheme;
                /**
                 * The theme color of the Technic theme.
                 * @example
                 * //This example sets the Technic theme.
                 * activeSheet.currentTheme("Technic");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Technic: ColorScheme;
                /**
                 * The theme color of the Trek theme.
                 * @example
                 * //This example sets the Trek theme.
                 * activeSheet.currentTheme("Trek");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Trek: ColorScheme;
                /**
                 * The theme color of the Urban theme.
                 * @example
                 * //This example sets the Urban theme.
                 * activeSheet.currentTheme("Urban");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Urban: ColorScheme;
                /**
                 * The theme color of the Verve theme.
                 * @example
                 * //This example sets the Verve theme.
                 * activeSheet.currentTheme("Verve");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Verve: ColorScheme;
            }

            export class Themes{
                /**
                 * Represents all built-in themes.
                 * @class
                 */
                constructor();
                /**
                 * Indicates the Apex theme.
                 */
                Apex: Theme;
                /**
                 * Indicates the Aspect theme.
                 */
                Aspect: Theme;
                /**
                 * Indicates the Civic theme.
                 */
                Civic: Theme;
                /**
                 * Indicates the Concourse theme.
                 */
                Concourse: Theme;
                /**
                 * Indicates the Default theme.
                 */
                Default: Theme;
                /**
                 * Indicates the Equity theme.
                 */
                Equity: Theme;
                /**
                 * Indicates the Flow theme.
                 */
                Flow: Theme;
                /**
                 * Indicates the Foundry theme.
                 */
                Foundry: Theme;
                /**
                 * Indicates the Median theme.
                 */
                Median: Theme;
                /**
                 * Indicates the Metro theme.
                 */
                Metro: Theme;
                /**
                 * Indicates the Module theme.
                 */
                Module: Theme;
                /**
                 * Indicates the Office theme.
                 */
                Office: Theme;
                /**
                 * Indicates the Office 2007 theme.
                 */
                Office2007: Theme;
                /**
                 * Indicates the Opulent theme.
                 */
                Opulent: Theme;
                /**
                 * Indicates the Oriel theme.
                 */
                Oriel: Theme;
                /**
                 * Indicates the Origin theme.
                 */
                Origin: Theme;
                /**
                 * Indicates the Paper theme.
                 */
                Paper: Theme;
                /**
                 * Indicates the Solstice theme.
                 */
                Solstice: Theme;
                /**
                 * Indicates the Technic theme.
                 */
                Technic: Theme;
                /**
                 * Indicates the Trek theme.
                 */
                Trek: Theme;
                /**
                 * Indicates the Urban theme.
                 */
                Urban: Theme;
                /**
                 * Indicates the Verve theme.
                 */
                Verve: Theme;
            }

            export class Workbook{
                /**
                 * Represents a spreadsheet with the specified hosted DOM element and options setting.
                 * @class
                 * @param {Object} host - The host DOM element.
                 * @param {Object} [options] - The initialization options.<br />
                 * @param {number} [options.sheetCount] - The number of sheets.<br />
                 * @param {string} [options.font] - The tab strip font.<br />
                 * @param {boolean} [options.allowUserDragMerge] - Whether to allow the user to drag merge cells.<br />
                 * @param {boolean} [options.allowUserDragDrop] - Whether to allow the user to drag and drop range data.<br />
                 * @param {boolean} [options.allowUserDragFill] - Whether to allow the user to drag fill a range.<br />
                 * @param {boolean} [options.allowUserZoom] - Whether to zoom the display by scrolling the mouse wheel while pressing the Ctrl key.<br />
                 * @param {boolean} [options.allowUserResize] - Whether to allow the user to resize columns and rows.<br />
                 * @param {boolean} [options.allowUndo] - Whether to allow the user to undo edits.<br />
                 * @param {boolean} [options.allowSheetReorder] - Whether the user can reorder the sheets in the Spread component.<br />
                 * @param {boolean} [options.allowContextMenu] -  Whether to allow the user to open the built-in context menu.<br />
                 * @param {boolean} [options.allowUserDeselect] -  Whether to allow the user to can use deselect in selection.<br />
                 * @param {GC.Spread.Sheets.Fill.AutoFillType} [options.defaultDragFillType] - The default fill type.<br />
                 * @param {boolean} [options.showDragFillSmartTag] - Whether to display the drag fill dialog.<br />
                 * @param {boolean} [options.showHorizontalScrollbar] - Whether to display the horizontal scroll bar.<br />
                 * @param {boolean} [options.showVerticalScrollbar] - Whether to display the vertical scroll bar.<br />
                 * @param {boolean} [options.scrollbarShowMax] - Whether the displayed scroll bars are based on the entire number of columns and rows in the sheet.<br />
                 * @param {boolean} [options.scrollbarMaxAlign] - Whether the scroll bar aligns with the last row and column of the active sheet.<br />
                 * @param {boolean} [options.tabStripVisible] - Whether to display the sheet tab strip.<br />
                 * @param {number} [options.tabStripRatio] - The width of the tab strip expressed as a percentage of the overall horizontal scroll bar width.<br />
                 * @param {boolean} [options.tabEditable] - Whether to allow the user to edit the sheet tab strip.<br />
                 * @param {boolean} [options.newTabVisible] - Whether the spreadsheet displays the special tab to let users insert new sheets.<br />
                 * @param {boolean} [options.tabNavigationVisible] - Whether to display the sheet tab navigation.<br />
                 * @param {boolean} [options.cutCopyIndicatorVisible] - Whether to display an indicator when copying or cutting the selected item.<br />
                 * @param {string} [options.cutCopyIndicatorBorderColor] - The border color for the indicator displayed when the user cuts or copies the selection.<br />
                 * @param {string} [options.backColor] - A color string used to represent the background color of the Spread component, such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.<br />
                 * @param {string} [options.backgroundImage] - The background image of the Spread component.<br />
                 * @param {GC.Spread.Sheets.ImageLayout} [options.backgroundImageLayout] - The background image layout for the Spread component.<br />
                 * @param {string} [options.grayAreaBackColor] - A color string used to represent the background color of the gray area , such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.<br />
                 * @param {GC.Spread.Sheets.ShowResizeTip} [options.showResizeTip] - How to display the resize tip.<br />
                 * @param {boolean} [options.showDragDropTip] -Whether to display the drag-drop tip.<br />
                 * @param {boolean} [options.showDragFillTip] - Whether to display the drag-fill tip.<br />
                 * @param {GC.Spread.Sheets.ShowScrollTip} [options.showScrollTip] - How to display the scroll tip.<br />
                 * @param {boolean} [options.scrollIgnoreHidden] - Whether the scroll bar ignores hidden rows or columns.<br />
                 * @param {boolean} [options.highlightInvalidData] - Whether to highlight invalid data.<br />
                 * @param {boolean} [options.useTouchLayout] - Whether to use touch layout to present the Spread component.<br />
                 * @param {boolean} [options.hideSelection] - Whether to display the selection highlighting when the Spread component does not have focus.<br />
                 * @param {GC.Spread.Sheets.ResizeZeroIndicator} [options.resizeZeroIndicator] - The drawing policy when the row or column is resized to zero.<br />
                 * @param {boolean} [options.allowUserEditFormula] - Whether the user can edit formulas in a cell in the spreadsheet.<br />
                 * @param {boolean} [options.enableFormulaTextbox] - Whether to enable the formula text box in the spreadsheet.<br />
                 * @param {GC.Spread.Sheets.AutoFitType} [options.autoFitType] - Whether content will be formatted to fit in cells or in cells and headers.<br />
                 * @param {GC.Spread.Sheets.ReferenceStyle} [options.referenceStyle] - the style for cell and range references in cell formulas on this sheet.
                 * @param {boolean} [options.calcOnDemand] - Whether to calculate formulas only when they are demanded.
                 * @param {boolean} [options.allowCopyPasteExcelStyle] - Whether the user can copy style from Spread Sheets then paste to Excel, or copy style from Excel then paste to Spread Sheets.
                 * @param {boolean} [options.allowExtendPasteRange] - Whether extend paste range if the paste range is not enough for pasting.
                 * @param {GC.Spread.Sheets.CopyPasteHeaderOptions} [options.copyPasteHeaderOptions] - Which headers are included when data is copied to or pasted.
                 * @example
                 * var workbook = new GC.Spread.Sheets.Workbook(document.getElementById("ss"), {sheetCount:3, font:"12pt Arial"});
                 * var workbook = new GC.Spread.Sheets.Workbook(document.getElementById("ss"), {sheetcount:3, newTabVisible:false});
                 * var workbook = new GC.Spread.Sheets.Workbook(document.getElementById("ss"), { sheetCount: 3, tabEditable: false });
                 * var workbook = new GC.Spread.Sheets.Workbook(document.getElementById("ss"), {sheetCount:3, tabStripVisible:false});
                 * var workbook = new GC.Spread.Sheets.Workbook(document.getElementById("ss"), {sheetCount:3, allowUserResize:false});
                 * var workbook = new GC.Spread.Sheets.Workbook(document.getElementById("ss"), { sheetCount: 3, allowUserZoom: false});
                 */
                constructor(host?:  any,  options?:  any);
                /**
                 * ContextMenu for the spread.
                 * @type {GC.Spread.Sheets.ContextMenu.ContextMenu}
                 * @example
                 * //This example shows how to get contextMenu's menuData.
                 * var menuData = spread.contextMenu.menuData;
                 */
                contextMenu: GC.Spread.Sheets.ContextMenu.ContextMenu;
                /**
                 * Represents the name of the Spread control.
                 * @type {string}
                 * @example
                 * spread.name = "Spread1";
                 */
                name: string;
                /**
                 * Represents the options of the Spread control.
                 * @type {Object}
                 * @property {boolean} allowUserDragMerge - Whether to allow the user to drag merge cells.<br />
                 * @property {boolean} allowUserDragDrop - Whether to allow the user to drag and drop range data.<br />
                 * @property {boolean} allowUserDragFill - Whether to allow the user to drag fill a range.<br />
                 * @property {boolean} allowUserZoom - Whether to zoom the display by scrolling the mouse wheel while pressing the Ctrl key.<br />
                 * @property {boolean} allowUserResize - Whether to allow the user to resize columns and rows.<br />
                 * @property {boolean} allowUndo - Whether to allow the user to undo edits.<br />
                 * @property {boolean} allowSheetReorder - Whether the user can reorder the sheets in the Spread component.<br />
                 * @property {boolean} allowContextMenu - Whether to allow the user to open the built-in context menu. <br />
                 * @property {boolean} allowUserDeselect -  Whether to allow the user to can use deselect in selection.<br />
                 * @property {GC.Spread.Sheets.Fill.AutoFillType} defaultDragFillType - The default fill type.<br />
                 * @property {boolean} showDragFillSmartTag - Whether to display the drag fill dialog.<br />
                 * @property {boolean} showHorizontalScrollbar - Whether to display the horizontal scroll bar.<br />
                 * @property {boolean} showVerticalScrollbar - Whether to display the vertical scroll bar.<br />
                 * @property {boolean} scrollbarShowMax - Whether the displayed scroll bars are based on the entire number of columns and rows in the sheet.<br />
                 * @property {boolean} scrollbarMaxAlign - Whether the scroll bar aligns with the last row and column of the active sheet.<br />
                 * @property {boolean} tabStripVisible - Whether to display the sheet tab strip.<br />
                 * @property {number} tabStripRatio - The width of the tab strip expressed as a percentage of the overall horizontal scroll bar width.<br />
                 * @property {boolean} tabEditable - Whether to allow the user to edit the sheet tab strip.<br />
                 * @property {boolean} newTabVisible - Whether the spreadsheet displays the special tab to let users insert new sheets.<br />
                 * @property {boolean} tabNavigationVisible - Whether to display the sheet tab navigation.<br />
                 * @property {boolean} cutCopyIndicatorVisible - Whether to display an indicator when copying or cutting the selected item.<br />
                 * @property {string} cutCopyIndicatorBorderColor - The border color for the indicator displayed when the user cuts or copies the selection.<br />
                 * @property {string} backColor - A color string used to represent the background color of the Spread component, such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.<br />
                 * @property {string} backgroundImage - The background image of the Spread component.<br />
                 * @property {GC.Spread.Sheets.ImageLayout} backgroundImageLayout - The background image layout for the Spread component.<br />
                 * @property {string} grayAreaBackColor - A color string used to represent the background color of the gray area , such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.<br />
                 * @property {GC.Spread.Sheets.ShowResizeTip} showResizeTip - How to display the resize tip.<br />
                 * @property {boolean} showDragDropTip -Whether to display the drag-drop tip.<br />
                 * @property {boolean} showDragFillTip - Whether to display the drag-fill tip.<br />
                 * @property {GC.Spread.Sheets.ShowScrollTip} showScrollTip - How to display the scroll tip.<br />
                 * @property {boolean} scrollIgnoreHidden - Whether the scroll bar ignores hidden rows or columns.<br />
                 * @property {boolean} highlightInvalidData - Whether to highlight invalid data.<br />
                 * @property {boolean} useTouchLayout - Whether to use touch layout to present the Spread component.<br />
                 * @property {boolean} hideSelection - Whether to display the selection highlighting when the Spread component does not have focus.<br />
                 * @property {GC.Spread.Sheets.ResizeZeroIndicator} resizeZeroIndicator - The drawing policy when the row or column is resized to zero.<br />
                 * @property {boolean} allowUserEditFormula - Whether the user can edit formulas in a cell in the spreadsheet.<br />
                 * @property {boolean} enableFormulaTextbox - Whether to enable the formula text box in the spreadsheet.<br />
                 * @property {GC.Spread.Sheets.AutoFitType} autoFitType - Whether content will be formatted to fit in cells or in cells and headers.<br />
                 * @property {GC.Spread.Sheets.ReferenceStyle} referenceStyle - the style for cell and range references in cell formulas on this sheet.
                 * @property {boolean} calcOnDemand - Whether to calculate formulas only when they are demanded.
                 * @property {boolean} allowCopyPasteExcelStyle - Whether the user can copy style from Spread Sheets then paste to Excel, or copy style from Excel then paste to Spread Sheets.
                 * @property {boolean} allowExtendPasteRange - Whether extend paste range if the paste range is not enough for pasting.
                 * @property {GC.Spread.Sheets.CopyPasteHeaderOptions} copyPasteHeaderOptions - Which headers are included when data is copied to or pasted.
                 * @example
                 * var workbook = new GC.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:5,showHorizontalScrollbar:false});
                 * workbook.options.allowUserDragDrop = false;
                 * workbook.options.allowUserZoom = false;
                 */
                options: IWorkbookOptions;
                /**
                 * Represents the sheet collection.
                 * @type {Array.<GC.Spread.Sheets.Worksheet>}
                 */
                sheets: GC.Spread.Sheets.Worksheet[];
                /**
                 * Represents the touch toolstrip.
                 * @type {GC.Spread.Sheets.Touch.TouchToolStrip}
                 */
                touchToolStrip: GC.Spread.Sheets.Touch.TouchToolStrip;
                /**
                 * Adds a custom function.
                 * @param {GC.Spread.CalcEngine.Functions.Function} fn The function to add.
                 */
                addCustomFunction(fn:  GC.Spread.CalcEngine.Functions.Function): void;
                /**
                 * Adds a custom name.
                 * @param {string} name The custom name.
                 * @param {string} formula The formula.
                 * @param {number} baseRow The row index.
                 * @param {number} baseCol The column index.
                 * @param {string} comment The custom comment.
                 */
                addCustomName(name:  string,  formula:  string,  baseRow:  number,  baseCol:  number,  comment:  string): void;
                /**
                 * Adds a style to the Workbook named styles collection.
                 * @param {GC.Spread.Sheets.Style} style The style to be added.
                 */
                addNamedStyle(style:  GC.Spread.Sheets.Style): void;
                /**
                 * Inserts a sheet at the specific index.
                 * @param {number} index The index at which to add a sheet.
                 * @param {GC.Spread.Sheets.Worksheet} sheet The sheet to be added.
                 * @example
                 * //This example adds a sheet to the spreadsheet.
                 * spread.addSheet(0,new GC.Spread.Sheets.Worksheet("custom"));
                 */
                addSheet(index:  number,  sheet?:  GC.Spread.Sheets.Worksheet): void;
                /**
                 * Adds a SparklineEx to the SparklineEx collection.
                 * @param {GC.Spread.Sheets.Sparklines.SparklineEx} sparklineEx The SparklineEx to be added.
                 */
                addSparklineEx(sparklineEx:  GC.Spread.Sheets.Sparklines.SparklineEx): void;
                /**
                 * Binds an event to the Workbook.
                 * @param {string} type The event type.
                 * @param {Object} data Specifies additional data to pass along to the function.
                 * @param {Function} fn Specifies the function to run when the event occurs.
                 * @example
                 * //This example binds events to functions.
                 * sheet.setActiveCell(5,5);
                 * alert(sheet.getActiveColumnIndex());
                 * alert(sheet.getActiveRowIndex());
                 * spread.bind(GC.Spread.Sheets.Events.EnterCell, function (event, data) {
                 *     alert(data.col);
                 *     alert(data.row);
                 *   });
                 * spread.bind(GC.Spread.Sheets.Events.LeaveCell, function (event, data) {
                 *     alert(data.col);
                 *     alert(data.row);
                 *   });
                 */
                bind(type:  any,  data?:  any,  fn?:  any): void;
                /**
                 * Clears all custom functions.
                 */
                clearCustomFunctions(): void;
                /**
                 * Clears custom names.
                 */
                clearCustomNames(): void;
                /**
                 * Clears all sheets in the control.
                 * @example
                 * //This example uses the clearSheets method.
                 * spread.clearSheets();
                 */
                clearSheets(): void;
                /**
                 * Gets the command manager.
                 * @returns {GC.Spread.Commands.CommandManager} The command manager.
                 * @example
                 * //This example executes a command that performs a specified action.
                 * spread.options.allowUndo = true;
                 * spread.commandManager().execute({cmd: "outlineRow", sheetName: "Sheet1", index: 3, count: 5});
                 */
                commandManager(): GC.Spread.Commands.CommandManager;
                /**
                 * Destroys the workbook and all sheets it contains.
                 * @example
                 * //This example destroys the workbook instance.
                 * spread.destroy();
                 */
                destroy(): void;
                /**
                 * Makes the Workbook component get focus or lose focus.
                 * @param {boolean} focusIn <c>false</c> makes the Workbook component lose the focus; otherwise, get focus.
                 * @example
                 * //This example sets focus to the Spread control.
                 * $("#button1").click(function () {
                 * spread.focus(true);
                 *    });
                 */
                focus(focusIn?:  boolean): void;
                /**
                 * Loads the object state from the specified JSON string.
                 * @param {Object} workbookData The spreadsheet data from deserialization.
                 * @param {Object} [deserializationOptions] - The deserialization options.
                 * @param {boolean} [deserializationOptions.ignoreStyle] - Whether to ignore the style when converting json to the workbook.
                 * @param {boolean} [deserializationOptions.ignoreFormula] - Whether to ignore the formula when converting json to the workbook.
                 * @param {boolean} [deserializationOptions.frozenColumnsAsRowHeaders] - Whether to treat the frozen columns as row headers when converting json to the workbook.
                 * @param {boolean} [deserializationOptions.frozenRowsAsColumnHeaders] - Whether to treat the frozen rows as column headers when converting json to the workbook.
                 * @param {boolean} [deserializationOptions.doNotRecalculateAfterLoad] - Whether to prevent recalculation after loading the json data.
                 * @example
                 * //This example uses the fromJSON method.
                 * activeSheet.getCell(0,0).value(123);
                 * var jsonStr = null;
                 * //export
                 * jsonStr = JSON.stringify(spread.toJSON(false));
                 * //import
                 * spread.fromJSON(JSON.parse(jsonStr));
                 * alert(jsonStr);
                 */
                fromJSON(workbookData:  Object,  deserializationOptions?:  Object): void;
                /**
                 * Gets the active sheet.
                 * @returns {GC.Spread.Sheets.Worksheet} The active sheet instance.
                 */
                getActiveSheet(): GC.Spread.Sheets.Worksheet;
                /**
                 * Gets the active sheet index of the control.
                 * @returns {number} The active sheet index.
                 * @example
                 * //This example uses the getActiveSheetIndex method.
                 * var index = spread.getActiveSheetIndex();
                 * alert(index);
                 */
                getActiveSheetIndex(): number;
                /**
                 * Gets a custom function.
                 * @param {string} name The custom function name.
                 * @returns {GC.Spread.CalcEngine.Functions.Function} The custom function.
                 */
                getCustomFunction(name:  string): void;
                /**
                 * Gets the specified custom name information.
                 * @param {string} name The custom name.
                 * @returns {GC.Spread.Sheets.NameInfo} The information for the specified custom name.
                 */
                getCustomName(name:  string): GC.Spread.Sheets.NameInfo;
                /**
                 * Gets all custom name information.
                 * @returns {Array} The type GC.Spread.Sheets.NameInfo stored in an array.
                 */
                getCustomNames(): GC.Spread.Sheets.NameInfo[];
                /**
                 * Gets the host element of the current Workbook instance.
                 * @returns {HTMLElement} host The host element of the current Workbook instance.
                 */
                getHost(): HTMLElement;
                /**
                 * Gets a style from the Workbook named styles collection which has the specified name.
                 * @param {string} name The name of the style to return.
                 * @returns {GC.Spread.Sheets.Style} Returns the specified named style.
                 */
                getNamedStyle(name:  string): GC.Spread.Sheets.Style;
                /**
                 * Gets named styles from the Workbook.
                 * @returns {Array} The GC.Spread.Sheets.Style array of named styles.
                 */
                getNamedStyles(): GC.Spread.Sheets.Style[];
                /**
                 * Gets the specified sheet.
                 * @param {number} index The index of the sheet to return.
                 * @returns {GC.Spread.Sheets.Worksheet} The specified sheet.
                 * @example
                 * //This example gets the sheet and sets the cell forecolor.
                 * var sheet1 = spread.getSheet(1);
                 * sheet1.getCell(0,0).value("A1").foreColor("red");
                 */
                getSheet(index:  number): GC.Spread.Sheets.Worksheet;
                /**
                 * Gets the number of sheets.
                 * @returns {number} The number of sheets.
                 * @example
                 * //This example uses the getSheetCount method.
                 * var index = spread.getSheetCount();
                 * alert(index);
                 */
                getSheetCount(): number;
                /**
                 * Gets the sheet with the specified name.
                 * @param {string} name The sheet name.
                 * @returns {GC.Spread.Sheets.Worksheet} The sheet with the specified name.
                 * @example
                 * //This example gets the sheet and sets the cell forecolor.
                 * var sheet1 = spread.getSheetFromName("Sheet2");
                 * sheet1.getCell(0,0).value("A1").foreColor("red");
                 */
                getSheetFromName(name:  string): GC.Spread.Sheets.Worksheet;
                /**
                 * Gets the sheet index with the specified name.
                 * @param {string} name The sheet name.
                 * @returns {number} The sheet index.
                 * @example
                 * //This example uses the getSheetIndex method.
                 * var sheet1 = spread.getSheetIndex("Sheet2");
                 * alert(sheet1);
                 */
                getSheetIndex(name:  string): number;
                /**
                 * Performs a hit test.
                 * @param {number} x The <i>x</i>-coordinate, x relative to spread horizontal axis.
                 * @param {number} y The <i>y</i>-coordinate, y relative to spread vertical axis.
                 * @returns {Object} The hit test information. If selecting the worksheet, the worksheet information is returned. The information contains x, y, and worksheetHitInfo;
                 * If selecting the sheetsTabStrip, the sheetsTabStrip information is returned. This information contains x, y, and tabStripHitInfo;
                 * If selecting the horizontalScrollbar, the horizontalScrollbar information is returned. This information contains x, y, and horizontalScrollBarHitInfo;
                 * If selecting the verticalScrollbar, the verticalScrollbar information is returned. This information contains x, y, and verticalScrollBarHitInfo;
                 * If selecting the footerCorner, the footerCorner information is returned. This information contains x, y, and footerCornerHitInfo.
                 * @example
                 * //This example uses the hitTest method.
                 *       window.onload = function(){
                 *           var spread = new GC.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 *           var activeeSheet = spread.getActiveSheet();
                 *           $("#ss").click(function (e) {
                 *               //Acquire cell index from mouse-clicked point of regular cells which are neither fixed rows/columns nor row/column headers.
                 *               var offset = $("#ss").offset();
                 *               var x = e.pageX - offset.left;
                 *               var y = e.pageY - offset.top;
                 *               var target = spread.hitTest(x, y);
                 *               if(target.worksheetHitInfo) {
                 *                   if(target.worksheetHitInfo.hitTestType === 0) {
                 *                       str = 'corner';
                 *                   } else if (target.worksheetHitInfo.hitTestType === 1) {
                 *                       str = 'colHeader';
                 *                   } else if (target.worksheetHitInfo.hitTestType === 2) {
                 *                       str = 'rowHeader';
                 *                   } else {
                 *                       str = 'viewport';
                 *                   }
                 *               } else if(target.tabStripHitInfo) {
                 *                   if(target.tabStripHitInfo.navButton){
                 *                       str = target.tabStripHitInfo.navButton;
                 *                   } else if(target.tabStripHitInfo.sheetTab) {
                 *                       str = target.tabStripHitInfo.sheetTab.sheetName;
                 *                   } else if(target.tabStripHitInfo.resize === true) {
                 *                       str = "resize";
                 *                   } else {
                 *                       str = "blank";
                 *                   }
                 *               } else if(target.horizontalScrollBarHitInfo) {
                 *                   str = target.horizontalScrollBarHitInfo.element;
                 *               } else if(target.verticalScrollBarHitInfo) {
                 *                   str = target.verticalScrollBarHitInfo.element;
                 *               } else if(target.footerCornerHitInfo) {
                 *                   str = target.footerCornerHitInfo.element;
                 *               }
                 *         alert(str);
                 * });
                 * }
                 */
                hitTest(x:  number,  y:  number): IWorkbookHitTestInformation;
                /**
                 * Updates the control layout information.
                 * @example
                 * //This example updates the layout.
                 * spread.invalidateLayout();
                 * spread.repaint();
                 */
                invalidateLayout(): void;
                /**
                 * Get if spread paint is suspended.
                 */
                isPaintSuspended(): boolean;
                /**
                 * Gets or sets the next control used by GC.Spread.Sheets.Actions.selectNextControl and GC.Spread.Sheets.Actions.moveToNextCellThenControl.
                 * @param {HTMLElement} value The next control. The control must have a focus method.
                 * @returns {HTMLElement|GC.Spread.Sheets.Workbook} If no value is set, returns the next control; otherwise, returns the spreadsheet.
                 */
                nextControl(value?:  HTMLElement): any;
                /**
                 * Gets or sets the previous control used by GC.Spread.Sheets.Actions.selectPreviousControl and GC.Spread.Sheets.Actions.moveToPreviousCellThenControl.
                 * @param {HTMLElement} value The previous control. The control must have a focus method.
                 * @returns {HTMLElement|GC.Spread.Sheets.Workbook} If no value is set, returns the previous control; otherwise, returns the spreadsheet.
                 */
                previousControl(value?:  HTMLElement): any;
                /**
                 *Prints the specified sheet.
                 *@param {number} sheetIndex The sheet index. If the sheet index is ignored, prints all visible sheets.
                 */
                print(sheetIndex?:  number): void;
                /**
                 * Manually refreshes the layout and rendering of the Workbook object.
                 * @example
                 * //This example uses the refresh method.
                 * spread.refresh();
                 */
                refresh(): void;
                /**
                 * Removes a custom function.
                 * @param {string} name The custom function name.
                 */
                removeCustomFunction(name:  string): void;
                /**
                 * Removes the specified custom name.
                 * @param {string} name The custom name.
                 * @example
                 * //This example uses the removeCustomName method.
                 * activeSheet.setValue(0, 0, 1);
                 * activeSheet.setValue(0, 1, 2);
                 * activeSheet.setValue(0, 2, 3);
                 * spread.addCustomName("customName1","=12", 0, 0);
                 * activeSheet.setFormula(1, 0, "customName1");
                 * //spread.removeCustomName("customName1");
                 */
                removeCustomName(name:  string): void;
                /**
                 * Removes a style from the Workbook named styles collection which has the specified name.
                 * @param {string} name The name of the style to remove.
                 * @example
                 * var namedStyle = new GC.Spread.Sheets.Style();
                 * namedStyle.name = "style1";
                 * namedStyle.backColor = "green";
                 * spread.addNamedStyle(namedStyle);
                 * activeSheet.setStyleName(1, 1, "style1"); // cell(1,1)'s backColor is  green.
                 * activeSheet.setStyleName(2, 1, "style1");
                 * var style = spread.getNamedStyle("style1");
                 * style.foreColor = "red";    // the namedStyle's foreColor is red.
                 * activeSheet.repaint(); // the foreColor of the cell(1,1) and cell(2,1) is red.
                 * activeSheet.getCell(1,1).value("test");
                 * $("#button1").click(function () {
                 *      spread.removeNamedStyle("style1");
                 * });
                 */
                removeNamedStyle(name:  string): void;
                /**
                 * Removes the specified sheet.
                 * @param {number} index The index of the sheet to remove.
                 * @example
                 * //This example removes a sheet from the spreadsheet.
                 * spread.setSheetCount(5);
                 * spread.removeSheet(0);
                 */
                removeSheet(index:  number): void;
                /**
                 * Removes a SparklineEx from the SparklineEx collection.
                 * @param {string} name The name of the SparklineEx to remove.
                 */
                removeSparklineEx(name:  string): void;
                /**
                 * Repaints the Workbook control.
                 * @example
                 * //This example updates the layout.
                 * spread.invalidateLayout();
                 * spread.repaint();
                 */
                repaint(): void;
                /**
                 * Resumes the calculation service.
                 * @param {boolean} recalcAll Specifies whether to recalculate all formulas.
                 * @example
                 * //This example uses the resumeCalcService method.
                 * spread.suspendCalcService(false);
                 * activeSheet.setValue(0,0,1);
                 * activeSheet.setValue(0,1,2);
                 * activeSheet.setValue(0,2,10);
                 * activeSheet.getCell(1,1).formula("=SUM(A1:C1)");
                 * spread.resumeCalcService(true);
                 */
                resumeCalcService(ignoreDirty:  boolean): void;
                /**
                 * Resumes the event.
                 * @example
                 * //This example suspends and resumes the event.
                 *  activeSheet.bind(GC.Spread.Sheets.Events.CellChanged, function (sender, args) {
                 *     if (args.propertyName === "value") {
                 *         alert(activeSheet.getValue(args.row, args.col));
                 *     }
                 * });
                 * spread.suspendEvent();
                 * activeSheet.setValue(0, 0, "111");
                 * spread.resumeEvent();
                 * activeSheet.setValue(1, 1, "222");
                 */
                resumeEvent(): void;
                /**
                 * Resumes the paint of active sheet and tab strip.
                 */
                resumePaint(): void;
                /**
                 *Exports the specified sheet to PDF.
                 *@param {function} successCallback Call this function after successfully export. function (blob) {}.
                 *@param {function} errorCallback Call this function if an error occurs. The exception parameter object structure { errorCode: GC.Spread.Sheets.PDF.ErrorCode, errorMessage: string}.
                 *@param {Object} [options] The options for export PDF.
                 *@param {string} [options.creator] The name of the application (for example, Adobe FrameMaker\xae) that created the original document from which it was converted.
                 *@param {string} [options.title] The document\u2019s title.
                 *@param {string} [options.author] The name of the person who created the document.
                 *@param {string} [options.keywords] Keywords associated with the document.
                 *@param {string} [options.subject] The subject of the document.
                 *@param {number} sheetIndex The sheet index. If the sheet index is ignored, exports all visible sheets.
                 */
                savePDF(successCallback:  Function,  errorCallback:  Function,  options?:  Object,  sheetIndex?:  number): void;
                /**
                 * Searches the text in the cells in the specified sheet for the specified string with the specified criteria.
                 * @param {GC.Spread.Sheets.Search.SearchCondition} searchCondition The search conditions.
                 * @returns {GC.Spread.Sheets.Search.SearchResult} The search result.
                 * @example
                 * //This example searches the active sheet using the specified search condition.
                 * activeSheet.getCell(2,3).value("testSearch");
                 * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                 * searchCondition.searchString = "testSearch";
                 * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                 * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                 * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                 * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                 * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.ignoreCase| GC.Spread.Sheets.Search.SearchFlags.useWildCards;
                 * var searchresult= spread.search(searchCondition);
                 * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" +
                 * searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundSheetIndex+"]";
                 * alert(str);
                 */
                search(searchCondition:  GC.Spread.Sheets.Search.SearchCondition): GC.Spread.Sheets.Search.SearchResult;
                /**
                 * Sets the active sheet by name.
                 * @param {string} name The name of the sheet to make the active sheet.
                 * @example
                 * //This example sets the active sheet.
                 * spread.setSheetCount(3);
                 * spread.setActiveSheet("Sheet2");
                 */
                setActiveSheet(name:  string): void;
                /**
                 * Sets the active sheet index for the control.
                 * @param {number} value The active sheet index.
                 * @example
                 * //This example uses the setActiveSheetIndex method.
                 * spread.setActiveSheetIndex(1);
                 */
                setActiveSheetIndex(value:  number): void;
                /**
                 * Sets the number of sheets.
                 * @param {number} count The number of sheets.
                 * @example
                 * spread.setSheetCount(5);
                 */
                setSheetCount(count:  number): void;
                /**
                 * Gets or sets the index of the first sheet to display in the spreadsheet.
                 * @param {number} value The index of the first sheet to display in the spreadsheet.
                 * @returns {number|GC.Spread.Sheets.Workbook} If no value is set, returns the index of the first sheet displayed in the spreadsheet; otherwise, returns the spreadsheet.
                 */
                startSheetIndex(value?:  number): any;
                /**
                 * Suspends the calculation service.
                 * @param {boolean} ignoreDirty Specifies whether to invalidate the dependency cells.
                 * @example
                 * //This example uses the suspendCalcService method.
                 * spread.suspendCalcService(false);
                 * activeSheet.setValue(0,0,1);
                 * activeSheet.setValue(0,1,2);
                 * activeSheet.setValue(0,2,10);
                 * activeSheet.getCell(1,1).formula("=SUM(A1:C1)");
                 * spread.resumeCalcService(true);
                 */
                suspendCalcService(ignoreDirty:  boolean): void;
                /**
                 * Suspends the event.
                 * @example
                 * //This example suspends and resumes the event.
                 * activeSheet.bind(GC.Spread.Sheets.Events.CellChanged, function (sender, args) {
                 *     if (args.propertyName === "value") {
                 *         alert(activeSheet.getValue(args.row, args.col));
                 *     }
                 * });
                 * spread.suspendEvent();
                 * activeSheet.setValue(0, 0, "111");
                 * spread.resumeEvent();
                 * activeSheet.setValue(1, 1, "222");
                 */
                suspendEvent(): void;
                /**
                 * Suspends the paint of active sheet and tab strip.
                 */
                suspendPaint(): void;
                /**
                 * Saves the object state to a JSON string.
                 * @param {Object} serializationOption - The serialization options.
                 * @param {boolean} [serializationOption.includeBindingSource] - Whether to include the binding source when converting the workbook to json.
                 * @param {boolean} [serializationOption.ignoreStyle] - Whether to ignore the style when converting the workbook to json.
                 * @param {boolean} [serializationOption.ignoreFormula] - Whether to ignore the formula when converting the workbook to json.
                 * @param {boolean} [serializationOption.rowHeadersAsFrozenColumns] - Whether to treat the row headers as frozen columns when converting the workbook to json.
                 * @param {boolean} [serializationOption.columnHeadersAsFrozenRows] - Whether to treat the column headers as frozen rows when converting the workbook to json.
                 * @returns {Object} The spreadsheet data.
                 * @example
                 * activeSheet.getCell(0,0).value(123);
                 * var jsonStr = null;
                 * //export
                 * jsonStr = JSON.stringify(spread.toJSON(false));
                 * //import
                 * spread.fromJSON(JSON.parse(jsonStr));
                 * alert(jsonStr);
                 */
                toJSON(serializationOption?:  Object): Object;
                /**
                 * Removes the binding of an event to Workbook.
                 * @param {string} type The event type.
                 * @param {Function} fn Specifies the function to run when the event occurs.
                 * @example
                 * //This example removes the event binding.
                 * activeSheet.bind(GC.Spread.Sheets.Events.CellChanged, function (sender, args) {
                 *     if (args.propertyName === "value") {
                 *         alert(activeSheet.getValue(args.row, args.col));
                 *     }
                 * });
                 * activeSheet.setValue(0, 0, "111");
                 * spread.unbind(GC.Spread.Sheets.Events.CellChanged);
                 * //spread.unbindAll(); //cancel monitoring of all events.
                 * activeSheet.setValue(1, 0, "222");
                 * activeSheet.setValue(2, 0, "333");
                 * activeSheet.setValue(3, 0, "444");
                 */
                unbind(type:  any,  fn?:  any): void;
                /**
                 * Removes the binding of all events to Workbook.
                 * @example
                 * //This example removes the event binding. Uncomment the unbindAll method to remove all event binding.
                 * activeSheet.bind(GC.Spread.Sheets.Events.CellChanged, function (sender, args) {
                 *     if (args.propertyName === "value") {
                 *         alert(activeSheet.getValue(args.row, args.col));
                 *     }
                 * });
                 * activeSheet.setValue(0, 0, "111");
                 * spread.unbind(GC.Spread.Sheets.Events.CellChanged);
                 * //spread.unbindAll(); //cancel monitoring of all events.
                 * activeSheet.setValue(1, 0, "222");
                 * activeSheet.setValue(2, 0, "333");
                 * activeSheet.setValue(3, 0, "444");
                 */
                unbindAll(): void;
                /**
                 * Gets the undo manager.
                 * @returns {GC.Spread.Commands.UndoManager} The undo manager.
                 */
                undoManager(): GC.Spread.Commands.UndoManager;
            }

            export class Worksheet{
                /**
                 * Represents a worksheet.
                 * @class
                 * @param {string} name The name of the Worksheet.
                 */
                constructor(name:  string);
                /**
                 * Indicates whether to generate columns automatically while binding data context.
                 * @type {boolean}
                 * @example
                 * //This example sets a data source for the sheet.
                 *  var test = [
                 *        { "Series0": 2, "Series1": 1 },
                 *        { "Series0": 4, "Series1": 2 },
                 *        { "Series0": 3, "Series1": 4 }
                 *             ];
                 * activeSheet.autoGenerateColumns = true;
                 * activeSheet.setDataSource(test, true);
                 */
                autoGenerateColumns: boolean;
                /**
                 * Chart manager for the sheet.
                 * @type {GC.Spread.Sheets.Charts.ChartCollection}
                 * @example
                 * //This example shows how to add a chart.
                 * var dataRange = "A1:D4";
                 * var chart = activeSheet.charts.add('Chart1', GC.Spread.Sheets.Charts.ChartType.columnClustered, 250, 20, 600, 400, dataRange);
                 */
                charts: GC.Spread.Sheets.Charts.ChartCollection;
                /**
                 * Indicates the column range group.
                 * @type {GC.Spread.Sheets.Outlines.Outline}
                 */
                columnOutlines: GC.Spread.Sheets.Outlines.Outline;
                /**
                 * Comment manager for the sheet.
                 * @type {GC.Spread.Sheets.Comments.CommentManager}
                 */
                comments: GC.Spread.Sheets.Comments.CommentManager;
                /**
                 * Conditional format manager for the sheet.
                 * @type {GC.Spread.Sheets.ConditionalFormatting.ConditionalFormats}
                 * @example
                 * //This example creates a rule.
                 * var style = new GC.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * var rule = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                 * rule.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                 * rule.ranges([new GC.Spread.Sheets.Range(0,0,5,1)]);
                 * rule.operator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between);
                 * rule.style(style);
                 * rule.value1(2);
                 * rule.value2(100);
                 * activeSheet.conditionalFormats.addRule(rule);
                 * activeSheet.setValue(0,0,1,3);
                 * activeSheet.setValue(1,0,45,3);
                 * var ruletest = activeSheet.conditionalFormats.getRules();
                 * alert(ruletest[0].style().backColor);
                 */
                conditionalFormats: ConditionalFormatting.ConditionalFormats;
                /**
                 * Indicates the default row height and column width of the sheet.
                 * @type {Object}
                 * @example
                 * //This example sets the default row height and column width.
                 * activeSheet.suspendPaint();
                 * activeSheet.defaults.rowHeight = 40;
                 * activeSheet.defaults.colWidth = 30;
                 * activeSheet.resumePaint();
                 */
                defaults: GC.Spread.Sheets.ISheetDefaultOption;
                /**
                 * FloatingObject manager for the sheet.
                 * @type {GC.Spread.Sheets.FloatingObjects.FloatingObjectCollection}
                 * @example
                 * //This example creates a floating object.
                 * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                 * var btn = document.createElement('button');
                 * btn.style.width = "60px";
                 * btn.style.height = "30px";
                 * btn.innerText = "button";
                 * customFloatingObject.content(btn);
                 * activeSheet.floatingObjects.add(customFloatingObject);
                 */
                floatingObjects: GC.Spread.Sheets.FloatingObjects.FloatingObjectCollection;
                /**
                 * Indicates the options of the sheet.
                 * @type {Object}
                 * @property {boolean} allowCellOverflow - Indicates whether data can overflow into adjacent empty cells.
                 * @property {string} sheetTabColor - A color string used to represent the sheet tab color, such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.
                 * @property {string} frozenlineColor - A color string used to represent the frozen line color, such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.
                 * @property {GC.Spread.Sheets.ClipboardPasteOptions} clipBoardOptions - The clipboard option.
                 * @property {Object} gridline - The grid line's options.
                 * @property {string} gridline.color - The grid line color
                 * @property {boolean} gridline.showVerticalGridline - Whether to show the vertical grid line.
                 * @property {boolean} gridline.showHorizontalGridline - Whether to show the horizontal grid line.
                 * @property {boolean} rowHeaderVisible - Indicates whether the row header is visible.
                 * @property {boolean} colHeaderVisible - Indicates whether the column header is visible.
                 * @property {GC.Spread.Sheets.HeaderAutoText} rowHeaderAutoText - Indicates whether the row header displays letters or numbers or is blank.
                 * @property {GC.Spread.Sheets.HeaderAutoText} colHeaderAutoText - Indicates whether the column header displays letters or numbers or is blank.
                 * @property {number} rowHeaderAutoTextIndex - Specifies which row header column displays the automatic text when there are multiple row header columns.
                 * @property {number} colHeaderAutoTextIndex - Specifies which column header row displays the automatic text when there are multiple column header rows.
                 * @property {boolean} isProtected - Indicates whether cells on this sheet that are marked as protected cannot be edited.
                 * @property {Object} protectionOptions - A value that indicates the elements that you want users to be able to change.
                 * @property {boolean} [protectionOptions.allowSelectLockedCells] - True or undefined if the user can select locked cells.
                 * @property {boolean} [protectionOptions.allowSelectUnlockedCells] - True or undefined if the user can select unlocked cells.
                 * @property {boolean} [protectionOptions.allowSort] - True if the user can sort ranges.
                 * @property {boolean} [protectionOptions.allowFilter] - True if the user can filter ranges.
                 * @property {boolean} [protectionOptions.allowEditObjects] - True if the user can edit floating objects.
                 * @property {boolean} [protectionOptions.allowResizeRows] - True if the user can resize rows.
                 * @property {boolean} [protectionOptions.allowResizeColumns] - True if the user can resize columns.
                 * @property {boolean} [protectionOptions.allowDragInsertRows] - True if the user can drag to insert rows.
                 * @property {boolean} [protectionOptions.allowDragInsertColumns] - True if the user can drag to insert columns.
                 * @property {boolean} [protectionOptions.allowInsertRows] - True if the user can insert rows.
                 * @property {boolean} [protectionOptions.allowInsertColumns] - True if the user can insert columns.
                 * @property {boolean} [protectionOptions.allowDeleteRows] - True if the user can delete rows.
                 * @property {boolean} [protectionOptions.allowDeleteColumns] - True if the user can delete columns.
                 * @property {string} selectionBackColor - The selection's background color for the sheet.
                 * @property {string} selectionBorderColor -  The selection's border color for the sheet.
                 * @property {Object} sheetAreaOffset - The sheetAreaOffset's options.
                 * @property {number} sheetAreaOffset.left - The offset left of sheet from host.
                 * @property {number} sheetAreaOffset.top - The offset top of sheet from host.
                 * @example
                 * sheet.setRowCount(2,GC.Spread.Sheets.SheetArea.colHeader);
                 * sheet.setColumnCount(2,GC.Spread.Sheets.SheetArea.rowHeader);
                 * sheet.setValue(0, 2,"Column",GC.Spread.Sheets.SheetArea.colHeader);
                 * sheet.options.colHeaderAutoTextIndex = 1;
                 * sheet.options.colHeaderAutoText = GC.Spread.Sheets.HeaderAutoText.numbers;
                 */
                options: GC.Spread.Sheets.IWorksheetOptions;
                /**
                 * Gets the outline column for the sheet.
                 * @returns {GC.Spread.Sheets.OutlineColumn.OutlineColumn}
                 */
                outlineColumn: GC.Spread.Sheets.OutlineColumn.OutlineColumn;
                /**
                 * Picture manager for the sheet.
                 * @type {GC.Spread.Sheets.FloatingObjects.FloatingObjectCollection}
                 * @example
                 * //This example adds a picture.
                 * activeSheet.pictures.add("f2","Event.png",2,2,10,10);
                 * var picture = activeSheet.pictures.get("f2");
                 * picture.pictureStretch(GC.Spread.Sheets.ImageLayout.center);
                 * picture.backColor("Blue");
                 * picture.borderWidth(2);
                 * picture.borderColor("Red");
                 * picture.borderStyle("dotted");
                 * picture.borderRadius(5);
                 */
                pictures: GC.Spread.Sheets.FloatingObjects.FloatingObjectCollection;
                /**
                 * Indicates the row range group.
                 * @type {GC.Spread.Sheets.Outlines.Outline}
                 */
                rowOutlines: GC.Spread.Sheets.Outlines.Outline;
                /**
                 * Shape manager for the sheet.
                 * @type {GC.Spread.Sheets.Shapes.ShapeCollection}
                 * @example
                 * //This example shows how to add a shape.
                 * var shape = activeSheet.shapes.add("shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 50, 100, 150);
                 */
                shapes: GC.Spread.Sheets.Shapes.ShapeCollection;
                /** The slicer manager.
                 * @type {GC.Spread.Sheets.Slicers.SlicerCollection}
                 * @example
                 * //This example adds a slicer.
                 * //create a table
                 * datas = [
                 *     ["1", "NewYork", "1968/6/8", "80", "180"],
                 *     ["4", "NewYork", "1972/7/3", "72", "168"],
                 *     ["4", "NewYork", "1964/3/2", "71", "179"],
                 *     ["5", "Washington", "1972/8/8","80", "171"],
                 *     ["6", "Washington", "1986/2/2", "89", "161"],
                 *     ["7", "Washington", "2012/2/15", "71", "240"]];
                 * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                 * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                 * table.setColumnName(0, dataColumns[0]);
                 * table.setColumnName(1, dataColumns[1]);
                 * table.setColumnName(2, dataColumns[2]);
                 * table.setColumnName(3, dataColumns[3]);
                 * table.setColumnName(4, dataColumns[4]);
                 * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.light4();
                 * //add a slicer to the sheet and return the slicer instance.
                 * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Height");
                 *  //change the slicer properties.
                 * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                 * slicer.disableResizingAndMoving(true);
                 * slicer.style(style1);
                 */
                slicers: GC.Spread.Sheets.Slicers.SlicerCollection;
                /** The table manager.
                 * @type {GC.Spread.Sheets.Tables.TableManager}
                 * @example
                 * //This example creates a table.
                 * activeSheet.tables.add("Table1", 0, 0, 3, 3, GC.Spread.Sheets.Tables.TableThemes.dark1);
                 * activeSheet.getCell(0,0).text("Name");
                 * activeSheet.getCell(0,1).text("Value");
                 * activeSheet.getCell(0,2).text("T/F");
                 * activeSheet.getCell(1,0).text("AW");
                 * activeSheet.getCell(1,1).text("5");
                 * activeSheet.getCell(1,2).text("T");
                 */
                tables: GC.Spread.Sheets.Tables.TableManager;
                /**
                 * Adds the column or columns to the data model at the specified index.
                 * @param {number} col Column index at which to add the new columns.
                 * @param {number} count The number of columns to add.
                 * @example
                 * //This example adds columns.
                 * sheet.setValue(0, 0, "value");
                 * sheet.addRows(0, 2);
                 * sheet.addColumns(0, 2);
                 * sheet.setRowHeight(0, 50.0,GC.Spread.Sheets.SheetArea.viewport);
                 * sheet.setColumnWidth(0, 150.0,GC.Spread.Sheets.SheetArea.viewport);
                 * sheet.getRange(0, -1, 1, -1,GC.Spread.Sheets.SheetArea.viewport).backColor("Gray");
                 * sheet.getRange(-1, 0, -1, 1,GC.Spread.Sheets.SheetArea.viewport).backColor ("Brown");
                 */
                addColumns(col:  number,  count:  number): void;
                /**
                 * Adds a custom function.
                 * @param {GC.Spread.CalcEngine.Functions.Function} fn The function to add.
                 */
                addCustomFunction(fn:  GC.Spread.CalcEngine.Functions.Function): void;
                /**
                 * Adds a custom name.
                 * @param {string} name The custom name.
                 * @param {string} formula The formula.
                 * @param {number} baseRow The row index.
                 * @param {number} baseCol The column index.
                 * @param {string} comment The comment.
                 * @example
                 * //This example creates custom names.
                 * sheet.setValue(0, 0, 1);
                 * sheet.setValue(0, 1, 2);
                 * sheet.setValue(0, 2, 3);
                 * sheet.addCustomName("customName1","=12", 0, 0);
                 * sheet.addCustomName("customName2","Average(20,45)", 0, 0);
                 * sheet.addCustomName("customName3", "=$A$1:$C$1", 0, 0);
                 * sheet.setFormula(1, 0, "customName1");
                 * sheet.setFormula(1, 1, "customName2");
                 * sheet.setFormula(1, 2, "sum(customName3)");
                 */
                addCustomName(name:  string,  formula:  string,  baseRow:  number,  baseCol:  number,  comment:  string): void;
                /**
                 * Adds a style to the Worksheet named styles collection.
                 * @param {GC.Spread.Sheets.Style} style The style to be added.
                 * @example
                 * var namedStyle = new GC.Spread.Sheets.Style();
                 * namedStyle.name = "style1";
                 * namedStyle.backColor = "green";
                 * activeSheet.addNamedStyle(namedStyle);
                 * activeSheet.setStyleName(1, 1, "style1"); // cell(1,1)'s backColor is  green.
                 * activeSheet.setStyleName(2, 1, "style1");
                 * var style = activeSheet.getNamedStyle("style1");
                 * style.foreColor = "red";    // the namedStyle's foreColor is red.
                 * activeSheet.repaint(); // the foreColor of the cell(1,1) and cell(2,1) is red.
                 * activeSheet.getCell(1,1).value("test");
                 * $("#button1").click(function () {
                 * activeSheet.removeNamedStyle("style1");
                 *     });
                 */
                addNamedStyle(style:  GC.Spread.Sheets.Style): void;
                /**
                 * Adds rows in this worksheet.
                 * @param {number} row The index of the starting row.
                 * @param {number} count The number of rows to add.
                 * @example
                 * //This example adds rows.
                 * sheet.setValue(0, 0, "value");
                 * sheet.addRows(0, 2);
                 * sheet.addColumns(0, 2);
                 * sheet.setRowHeight(0, 50.0,GC.Spread.Sheets.SheetArea.viewport);
                 * sheet.setColumnWidth(0, 150.0,GC.Spread.Sheets.SheetArea.viewport);
                 * sheet.getRange(0, -1, 1, -1,GC.Spread.Sheets.SheetArea.viewport).backColor("Gray");
                 * sheet.getRange(-1, 0, -1, 1,GC.Spread.Sheets.SheetArea.viewport).backColor ("Brown");
                 */
                addRows(row:  number,  count:  number): void;
                /**
                 * Adds a cell or cells to the selection.
                 * @param {number} row The row index of the first cell to add.
                 * @param {number} column The column index of the first cell to add.
                 * @param {number} rowCount The number of rows to add.
                 * @param {number} columnCount The number of columns to add.
                 * @example
                 * //This example adds a selection and uses the selection in a rule.
                 * sheet.setValue(0,0, 1,3);
                 * sheet.setValue(1,0, 50,3);
                 * sheet.setValue(2,0, 100,3);
                 * sheet.setValue(3,0, 2,3);
                 * sheet.setValue(4,0, 60,3);
                 * sheet.setValue(5,0, 90,3);
                 * sheet.setValue(6,0, 3,3);
                 * sheet.setValue(7,0, 40,3);
                 * sheet.setValue(8,0, 70,3);
                 * sheet.setValue(9,0, 5,3);
                 * sheet.setValue(10,0, 35,3);
                 * sheet.addSelection(0,0,11,1);
                 * sheet.conditionalFormats.add3ScaleRule(1, 10, "red", 0, 50, "blue",2, 100, "yellow", sheet.getSelections());
                 */
                addSelection(row:  number,  column:  number,  rowCount:  number,  columnCount:  number): void;
                /**
                 * Adds a span of cells to this sheet in the specified sheet area.
                 * @param {number} row The row index of the cell at which to start the span.
                 * @param {number} column The column index of the cell at which to start the span.
                 * @param {number} rowCount The number of rows to span.
                 * @param {number} colCount The number of columns to span.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @example
                 * //This example creates cell spans.
                 * sheet.setRowCount(4,1);
                 * sheet.setColumnCount(4,2);
                 * sheet.addSpan(0,0,3,3,GC.Spread.Sheets.SheetArea.colHeader);
                 * sheet.addSpan(0,0,3,3,GC.Spread.Sheets.SheetArea.rowHeader);
                 * sheet.addSpan(0,0,3,3,GC.Spread.Sheets.SheetArea.viewport);
                 */
                addSpan(row:  number,  col:  number,  rowCount:  number,  colCount:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea): void;
                /**
                 * Automatically fits the viewport column.
                 * @param {number} column The column index.
                 * @example
                 * //This example sets the column width based on the text.
                 * activeSheet.setValue(0, 1, "testing");
                 * activeSheet.autoFitColumn(1);
                 */
                autoFitColumn(column:  number): void;
                /**
                 * Automatically fits the viewport row.
                 * @param {number} row The row index.
                 * @example
                 * //This example sets the row height based on the text.
                 * activeSheet.setValue(0, 1, "testing\r\nmultiple\r\nlines");
                 * activeSheet.getCell(0,1).wordWrap(true);
                 * activeSheet.autoFitRow(0);
                 */
                autoFitRow(row:  number): void;
                /**
                 * Binds an event to the sheet.
                 * @param {string} type The event type.
                 * @param {Object} data Optional. Specifies additional data to pass along to the function.
                 * @param {Function} fn Specifies the function to run when the event occurs.
                 * @example
                 * //This example binds events.
                 * sheet.bind(GC.Spread.Sheets.Events.LeftColumnChanged,function(event,data)
                 *   {
                 *     var str = "----------------------------------------\n";
                 *     var title = "Event [LeftColumnChanged ] Fired";
                 *     str = str.substr(0, 4) + title + str.substr(4 + title.length);
                 *     if (typeof data == "object") {
                 *         for (var key in data) {
                 *             str += key + " : " + data[key] + "\n";
                 *           }
                 *       } else {
                 *         str += data + "\n";
                 *       }
                 *       alert(str);
                 *   });
                 * sheet.bind(GC.Spread.Sheets.Events.TopRowChanged,function(event,data)
                 *   {
                 *         var str = "----------------------------------------\n";
                 *         var title = "Event [TopRowChanged] Fired";
                 *         str = str.substr(0, 4) + title + str.substr(4 + title.length);
                 *         if (typeof data == "object") {
                 *             for (var key in data) {
                 *                 str += key + " : " + data[key] + "\n";
                 *             }
                 *         } else {
                 *             str += data + "\n";
                 *         }
                 *         alert(str);
                 *     });
                 */
                bind(type:  any,  data?:  any,  fn?:  any): void;
                /**
                 * Binds the column using the specified data field.
                 * @param {number} index The column index.
                 * @param {string|Object} column Column information with data field. If its type is string, it is regarded as name.
                 * @example
                 * var test = [
                 * {"Series0":2,"Series1":1},
                 * {"Series0":4,"Series1":2},
                 * {"Series0":3,"Series1":4}
                 * ];
                 * sheet.setDataSource(test);
                 * sheet.bindColumn(1,"Series0");
                 * sheet.bindColumn(0,"Series1");
                 */
                bindColumn(index:  number,  column:  any): void;
                /**
                 * Binds the columns using the specified data fields.
                 * @param {Array} columns The array of column information with data fields. If an item's type is string, the item is regarded as name.
                 * @example
                 * var datasource = [
                 *                  { name: "Alice", age: 27, birthday: "1985/08/31", position: "PM" },
                 *                  { name: "Aimee", age: 28, birthday: "1984/07/31", position: "TL" },
                 *                  { name: "Charles", age: 29, birthday: "1983/03/31", position: "QC" },
                 *             ];
                 * var colInfos = [
                 *                 { name: "name", displayName: "Name", size: 70 },
                 *                 { name: "age", displayName: "Age", size: 40, resizable: false },
                 *                 { name: "birthday", displayName: "Birthday", formatter: "d/M/yy", size: 120 },
                 *                 { name: "position", displayName: "Position", size: 50, visible: false }
                 *             ];
                 * activeSheet.autoGenerateColumns = true;
                 * activeSheet.setDataSource(datasource);
                 * activeSheet.bindColumns(colInfos);
                 */
                bindColumns(columns:  any[]): void;
                /**
                 * Clears the specified area.
                 * @param {number} row The start row index.
                 * @param {number} column The start column index.
                 * @param {number} rowCount The number of rows to clear.
                 * @param {number} columnCount The number of columns to clear.
                 * @param {GC.Spread.Sheets.SheetArea} area The area to clear.
                 * @param {GC.Spread.Sheets.StorageType} storageType The clear type.
                 * @example
                 * //This example clears the data from the specified range.
                 * activeSheet.getCell(0,0).value("A1");
                 * activeSheet.clear(0,0,3,3,GC.Spread.Sheets.SheetArea.viewport,GC.Spread.Sheets.StorageType.data);
                 */
                clear(row:  number,  column:  number,  rowCount:  number,  colCount:  number,  area:  GC.Spread.Sheets.SheetArea,  storageType:  GC.Spread.Sheets.StorageType): void;
                /**
                 * Clears all custom functions.
                 * @example
                 * //This example clears the custom functions from the active sheet.
                 * activeSheet.clearCustomFunctions();
                 */
                clearCustomFunctions(): void;
                /**
                 * Clears custom names.
                 * @example
                 * //This example creates custom names and then clears them.
                 * activeSheet.setValue(0, 0, 1);
                 * activeSheet.setValue(0, 1, 2);
                 * activeSheet.setValue(0, 2, 3);
                 * activeSheet.addCustomName("customName1","=12", 0, 0);
                 * activeSheet.addCustomName("customName2","Average(20,45)", 0, 0);
                 * activeSheet.addCustomName("customName3", "=$A$1:$C$1", 0, 0);
                 * activeSheet.setFormula(1, 0, "customName1");
                 * activeSheet.setFormula(1, 1, "customName2");
                 * activeSheet.setFormula(1, 2, "sum(customName3)");
                 * activeSheet.clearCustomNames();
                 */
                clearCustomNames(): void;
                /**
                 * Clears the dirty, insert, and delete status from the current worksheet.
                 */
                clearPendingChanges(): void;
                /**
                 * Clears the selection.
                 * @example
                 * //This example clears the selection.
                 * sheet.addSelection(4, 0, 2, 2);
                 * sheet.clearSelection();
                 */
                clearSelection(): any;
                /**
                 * Copies data from one range to another.
                 * @param {number} fromRow The source row.
                 * @param {number} fromColumn The source column.
                 * @param {number} toRow The target row.
                 * @param {number} toColumn The target column.
                 * @param {number} rowCount The row count.
                 * @param {number} columnCount The column count.
                 * @param {GC.Spread.Sheets.CopyToOptions} option The copy option.
                 * @example
                 * //This example copies data to the specified location.
                 * activeSheet.getCell(0,0).value("1");
                 * activeSheet.copyTo(0,0,1,1,2,2,GC.Spread.Sheets.CopyToOptions.value);
                 */
                copyTo(fromRow:  number,  fromColumn:  number,  toRow:  number,  toColumn:  number,  rowCount:  number,  columnCount:  number,  option:  GC.Spread.Sheets.CopyToOptions): void;
                /**
                 * Gets or sets the current theme for the sheet.
                 * @param {string|GC.Spread.Common.Theme} value The theme name or the theme.
                 * @returns {GC.Spread.Common.Theme|GC.Spread.Sheets.Worksheet} If no value is set, returns the current theme; otherwise, returns the worksheet.
                 * @example
                 * //This example sets a theme.
                 * sheet.currentTheme("Civic");
                 */
                currentTheme(value?:  any): any;
                /**
                 * Deletes the columns in this sheet at the specified index.
                 * @param {number} col The index of the first column to delete.
                 * @param {number} count The number of columns to delete.
                 * @example
                 * activeSheet.getCell(0,0).value("A1");
                 * activeSheet.getCell(0,4).value("Test")
                 * activeSheet.deleteColumns(0,2);
                 * activeSheet.deleteRows(3,1);
                 */
                deleteColumns(col:  number,  count:  number): void;
                /**
                 * Deletes the rows in this worksheet at the specified index.
                 * @param {number} row The index of the first row to delete.
                 * @param {number} count The number of rows to delete.
                 * @example
                 * activeSheet.getCell(0,0).value("A1");
                 * activeSheet.getCell(0,4).value("Test")
                 * activeSheet.deleteColumns(0,2);
                 * activeSheet.deleteRows(3,1);
                 */
                deleteRows(row:  number,  count:  number): void;
                /**
                 * Returns the editor's status.
                 * @returns {GC.Spread.Sheets.EditorStatus} The editor status.
                 */
                editorStatus(): GC.Spread.Sheets.EditorStatus;
                /**
                 * Stops editing the active cell.
                 * @param {boolean} ignoreValueChange If set to <c>true</c>, does not apply the edited text to the cell.
                 * @returns {boolean} <c>true</c> when able to stop cell editing successfully; otherwise, <c>false</c>.
                 * @example
                 * //This example removes the text "123" when typing in a cell.
                 * activeSheet.bind(GC.Spread.Sheets.Events.EditChange, function (sender,args) {
                 *                 if (args.editingText === "123") {
                 *                     activeSheet.endEdit(true);
                 *                }
                 *             });
                 */
                endEdit(ignoreValueChange?:  boolean): boolean;
                /**
                 * Fills the specified range automatically.
                 * @param {GC.Spread.Sheets.Range} startRange The fill start range.
                 * @param {GC.Spread.Sheets.Range} wholeRange The entire range to fill.
                 * @param {object} options The range fill information.
                 * @param {GC.Spread.Sheets.Fill.FillType} [options.fillType] - Specifies how to fill the specified range.
                 *      GC.Spread.Sheets.Fill.FillType.direction:<br />
                 *              Fills the specified range in the specified direction.<br />
                 *      GC.Spread.Sheets.Fill.FillType.linear:<br />
                 *              Fills the specified range using a linear trend when the source value type is number.<br />
                 *              The next value is generated by the step and stop values.<br />
                 *              The next value is computed by adding the step value to the current cell value.<br />
                 *      GC.Spread.Sheets.Fill.FillType.growth:<br />
                 *              Fills the specified range using a growth trend when the source value type is number.<br />
                 *              The next value is generated by the step and stop values.<br />
                 *              The next value is computed by multiplying the step value with the current cell.<br />
                 *      GC.Spread.Sheets.Fill.FillType.date:<br />
                 *              Fills the specified range when the source value type is date.<br />
                 *              The next value is generated by adding the step value to the current value.<br />
                 *              The step value is affected by the fill date unit.<br />
                 *      GC.Spread.Sheets.Fill.FillType.auto:<br />
                 *              Fills the specified range automatically.<br />
                 *              When the value is a string, the value is copied to other cells.<br />
                 *              When the value is a number, the new value is generated by the TREND formula.<br />
                 * @param {GC.Spread.Sheets.Fill.FillSeries} [options.series] - The fill series.
                 * @param {GC.Spread.Sheets.Fill.FillDirection} [options.direction] - direction The fill direction.
                 * @param {number} [options.step] step - The fill step value.
                 * @param {number|Date} [options.stop] stop - The fill stop value.
                 * @param {GC.Spread.Sheets.Fill.FillDateUnit} [options.unit] - unit The fill date unit.
                 * @example
                 * activeSheet.setValue(0, 0, 5);
                 * var start = new GC.Spread.Sheets.Range(0, 0, 1, 1);
                 * var r3 = new GC.Spread.Sheets.Range(0, 0, 4, 1);
                 * activeSheet.fillAuto(start,r3, {fillType:GC.Spread.Sheets.Fill.FillType.auto, series:GC.Spread.Sheets.Fill.FillSeries.column, direction:GC.Spread.Sheets.Fill.FillDirection.down});
                 */
                fillAuto(startRange:  GC.Spread.Sheets.Range,  wholeRange:  GC.Spread.Sheets.Range,  options:  Object): void;
                /**
                 * Loads the object state from the specified JSON string.
                 * @param {Object} sheetSettings The sheet data from deserialization.
                 * @example
                 * //This example uses the fromJSON method.
                 * activeSheet.getCell(0,0).value(123);
                 * var jsonStr = null;
                 * //export
                 * jsonStr = JSON.stringify(activeSheet.toJSON());
                 * //import
                 * activeSheet.fromJSON(JSON.parse(jsonStr));
                 * alert(jsonStr);
                 */
                fromJSON(sheetSettings:  Object): void;
                /**
                 * Gets or sets the number of frozen columns of the sheet.
                 * @param {number} colCount The number of columns to freeze.
                 * @returns {number|GC.Spread.Sheets.Worksheet} If no value is set, returns the number of frozen columns; otherwise, returns the worksheet.
                 * @example
                 * sheet.frozenColumnCount(1);
                 */
                frozenColumnCount(colCount?:  number): any;
                /**
                 * Gets or sets the number of frozen rows of the sheet.
                 * @param {number} rowCount The number of rows to freeze.
                 * @returns {number|GC.Spread.Sheets.Worksheet} If no value is set, returns the number of frozen rows; otherwise, returns the worksheet.
                 * @example
                 * sheet.frozenRowCount(1);
                 */
                frozenRowCount(rowCount?:  number): any;
                /**
                 * Gets or sets the number of trailing frozen columns of the sheet.
                 * @param {number} colCount The number of columns to freeze at the right side of the sheet.
                 * @returns {number|GC.Spread.Sheets.Worksheet} If no value is set, returns the number of trailing frozen columns; otherwise, returns the worksheet.
                 * @example
                 * sheet.frozenTrailingColumnCount(1);
                 */
                frozenTrailingColumnCount(colCount?:  number): any;
                /**
                 * Gets or sets the number of trailing frozen rows of the sheet.
                 * @param {number} rowCount The number of rows to freeze at the bottom of the sheet.
                 * @returns {number|GC.Spread.Sheets.Worksheet} If no value is set, returns the number of trailing frozen rows; otherwise, returns the worksheet.
                 * @example
                 * sheet.frozenTrailingRowCount(1);
                 */
                frozenTrailingRowCount(rowCount?:  number): any;
                /**
                 * Gets the active column index for this sheet.
                 * @returns {number} The column index of the active cell.
                 * @example
                 * //This example gets the active column.
                 * sheet.setActiveCell(5,5);
                 * alert(sheet.getActiveColumnIndex());
                 * alert(sheet.getActiveRowIndex());
                 * spread.bind(GC.Spread.Sheets.Events.EnterCell, function (event, data) {
                 *     alert(data.col);
                 *     alert(data.row);
                 *   });
                 * spread.bind(GC.Spread.Sheets.Events.LeaveCell, function (event, data) {
                 *     alert(data.col);
                 *     alert(data.row);
                 *   });
                 */
                getActiveColumnIndex(): number;
                /**
                 * Gets the active row index for this sheet.
                 * @returns {number} The row index of the active cell.
                 * @example
                 * //This example gets the active row.
                 * sheet.setActiveCell(5,5);
                 * alert(sheet.getActiveColumnIndex());
                 * alert(sheet.getActiveRowIndex());
                 * spread.bind(GC.Spread.Sheets.Events.EnterCell, function (event, data) {
                 *     alert(data.col);
                 *     alert(data.row);
                 *   });
                 * spread.bind(GC.Spread.Sheets.Events.LeaveCell, function (event, data) {
                 *     alert(data.col);
                 *     alert(data.row);
                 *   });
                 */
                getActiveRowIndex(): number;
                /**
                 * Gets the actual style information for a specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} column The column index.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @param {boolean} sheetStyleOnly If <c>true</c>, the row filter and the conditional format style are not applied to the return style;
                 * otherwise, the return style only contains the cell's inherited style.
                 * @returns {GC.Spread.Sheets.Style} Returns the cell style of the specified cell.
                 * @example
                 * //This example uses the getActualStyle method.
                 * var style = new GC.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.borderLeft =new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderTop = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderRight = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderBottom = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
                 * var cstyle = activeSheet.getActualStyle(1,1,GC.Spread.Sheets.SheetArea.viewport, true);
                 * alert(cstyle.backColor);
                 */
                getActualStyle(row:  number,  column:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea,  sheetStyleOnly?:  boolean): GC.Spread.Sheets.Style;
                /**
                 * Gets an object array from a specified range of cells.
                 * @param {number} row The row index.
                 * @param {number} column The column index.
                 * @param {number} rowCount The row count.
                 * @param {number} colCount The column count.
                 * @param {boolean} getFormula If <c>true</c>, return formulas; otherwise, return values.
                 * @returns {Array} The object array from the specified range of cells.
                 * @example
                 * //This example uses the getArray method.
                 * //set value
                 * var array = [[1,2,3],[4,5],[6,7,8,9]];
                 * activeSheet.setArray(1, 2, array);
                 * //set formula
                 * var array = [["=1+1","=2+2","=3+3"],["=4+4","=5+5"],["=6+6","=7+7","=8+8","=9+9"]];
                 * activeSheet.setArray(1, 2, array, true);
                 * //get value
                 * var newArray = activeSheet.getArray(1, 2, 3, 4);
                 * //getformula
                 * var newArray = activeSheet.getArray(1, 2, 3, 4, true);
                 * //alert(newArray[0]);
                 */
                getArray(row:  number,  column:  number,  rowCount:  number,  columnCount:  number,  getFormula?:  boolean): any[];
                /**
                 * Gets the binding path of cell-level binding from the specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @returns {string} Returns the binding path of the cell for cell-level binding.
                 * @example
                 * //This example uses the getBindingPath method.
                 * var person = {name: "Wang feng", age: 25, address: {postcode: "710075"}};
                 * var source = new GC.Spread.Sheets.Bindings.CellBindingSource(person);
                 * activeSheet.setBindingPath(0, 0, "name");
                 * activeSheet.setBindingPath(1, 1, "age");
                 * activeSheet.setBindingPath(3, 3, "address.postcode");
                 * activeSheet.setDataSource(source);
                 * alert(activeSheet.getBindingPath(0, 0, GC.Spread.Sheets.SheetArea.viewport));
                 */
                getBindingPath(row:  number,  col:  number): string;
                /**
                 * Gets the specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @returns {GC.Spread.Sheets.CellRange} The cell.
                 * @example
                 * //This example gets the cell.
                 * activeSheet.getCell(1,1).text("cell object");
                 */
                getCell(row:  number,  col:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea): GC.Spread.Sheets.CellRange;
                /**
                 * Gets the rectangle of the cell.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {number} rowViewportIndex Index of the row of the viewport: -1 represents column header area, 0 represents frozen row area, 1 represents viewport area, 2 represents trailing frozen row area.
                 * @param {number} colViewportIndex Index of the column of the viewport: -1 represents row header area, 0 represents frozen column area, 1 represents viewport area, 2 represents trailing frozen column area.
                 * @returns {GC.Spread.Sheets.Rect} Object that contains the size and location of the cell rectangle.
                 * @example
                 * //This example uses the getCellRect method.
                 * activeSheet.bind(GC.Spread.Sheets.Events.CellClick, function (e, info) {
                 *                if (info.sheetArea === GC.Spread.Sheets.SheetArea.viewport) {
                 *                    alert("Clicked cell index (" + info.row + "," + info.col + ")");
                 *                    //Acquire the coordinate information of regular cells which exist at the specified index position
                 *                    var cellRect = activeSheet.getCellRect(info.row, info.col);
                 *                    alert("X coordinate:" + cellRect.x);
                 *                    alert("Y coordinate:" + cellRect.y);
                 *                    alert("Cell width:" + cellRect.width);
                 *                    alert("Cell height:" + cellRect.height);
                 *                }
                 *            });
                 */
                getCellRect(row:  number,  col:  number,  rowViewportIndex?:  number,  colViewportIndex?:  number): GC.Spread.Sheets.Rect;
                /**
                 * Gets the cell type.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @returns {GC.Spread.Sheets.CellTypes.Base} Returns the cell type for the specified cell.
                 * @example
                 * //This example gets the cell type.
                 * var cellType = new GC.Spread.Sheets.CellTypes.Button();
                 * cellType.buttonBackColor("#FFFF00");
                 * cellType.text("this is a button");
                 * activeSheet.getCell(0, 2).cellType(cellType);
                 * var cellType = activeSheet.getCellType(0,2,GC.Spread.Sheets.SheetArea.viewport)
                 * if (cellType instanceof GC.Spread.Sheets.CellTypes.Button) {
                 *       alert("This is a ButtonCellType");
                 * }
                 */
                getCellType(row:  number,  col:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea): GC.Spread.Sheets.CellTypes.Base;
                /**
                 * Gets the column count in the specified sheet area.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @returns {number} The number of columns.
                 * @example
                 * //This example gets the number of columns.
                 * var count = activeSheet.getColumnCount(GC.Spread.Sheets.SheetArea.viewport);
                 * alert(count);
                 */
                getColumnCount(sheetArea?:  GC.Spread.Sheets.SheetArea): number;
                /**
                 * Gets whether a forced page break is inserted before the specified column on this sheet when printing.
                 * @param {number} column The column index.
                 * @returns {boolean} <c>true</c> if a forced page break is inserted before the specified column; otherwise, <c>false</c>.
                 */
                getColumnPageBreak(column:  number): boolean;
                /**
                 * Gets a value that indicates whether the user can resize a specified column in the specified sheet area.
                 * @param {number} col The column index.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @returns {boolean} <c>true</c> if the user can resize the specified column; otherwise, <c>false</c>.
                 * @example
                 * //This example gets whether the column is resizable.
                 * sheet.setRowCount(10);
                 * sheet.setColumnCount(7);
                 * sheet.setValue(0, 0,"Western");
                 * sheet.setValue(0, 1,"Western");
                 * sheet.setValue(0, 2,"Western");
                 * sheet.setValue(1, 0,"A");
                 * sheet.setValue(1, 1,"B");
                 * sheet.setValue(1, 2,"C");
                 * sheet.setColumnResizable(0,true, GC.Spread.Sheets.SheetArea.colHeader);
                 * sheet.setRowResizable(0,true, GC.Spread.Sheets.SheetArea.rowHeader);
                 * alert( sheet.getColumnResizable(0));
                 * alert( sheet.getRowResizable(0, GC.Spread.Sheets.SheetArea.rowHeader));
                 */
                getColumnResizable(col:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea): boolean;
                /**
                 * Gets whether a column in the specified sheet area is displayed.
                 * @param {number} col The column index.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @returns {boolean} <c>true</c> if the column is visible in the sheet area; otherwise, <c>false</c>.
                 * @example
                 * //This example returns the visible and width settings for a column.
                 * var visible = activeSheet.getColumnVisible(1, GC.Spread.Sheets.SheetArea.viewport);
                 * var width = activeSheet.getColumnWidth(1, GC.Spread.Sheets.SheetArea.viewport);
                 * alert(visible);
                 * alert(width);
                 */
                getColumnVisible(col:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea): boolean;
                /**
                 * Gets the width in pixels for the specified column in the specified sheet area.
                 * @param {number} col The column index.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to viewport.
                 * @returns {number} The column width in pixels.
                 * @example
                 * //This example returns the visible and width settings for a column.
                 * var visible = activeSheet.getColumnVisible(1, GC.Spread.Sheets.SheetArea.viewport);
                 * var width = activeSheet.getColumnWidth(1, GC.Spread.Sheets.SheetArea.viewport);
                 * alert(visible);
                 * alert(width);
                 */
                getColumnWidth(col:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea): number;
                /**
                 * Gets delimited text from a range.
                 * @param {number} row The start row.
                 * @param {number} column The start column.
                 * @param {number} rowCount The row count.
                 * @param {number} columnCount The column count.
                 * @param {string} rowDelimiter The row delimiter that is appended to the end of the row.
                 * @param {string} columnDelimiter The column delimiter that is appended to the end of the column.
                 * @returns {string} The text from the range with the specified delimiters.
                 */
                getCsv(row:  number,  column:  number,  rowCount:  number,  columnCount:  number,  rowDelimiter:  string,  columnDelimiter:  string): string;
                /**
                 * Gets a custom function.
                 * @param {string} fnName The custom function name.
                 * @returns {GC.Spread.CalcEngine.Functions.Function} The custom function.
                 */
                getCustomFunction(name:  string): void;
                /**
                 * Gets the specified custom name information.
                 * @param {string} fnName The custom name.
                 * @returns {GC.Spread.Sheets.NameInfo} The information for the specified custom name.
                 * @example
                 * //This example gets the custom name and formula.
                 * activeSheet.setValue(0, 0, 1);
                 * activeSheet.setValue(0, 1, 2);
                 * activeSheet.setValue(0, 2, 3);
                 * activeSheet.addCustomName("customName1", "=12", 0, 0);
                 * activeSheet.addCustomName("customName2", "Average(20,45)", 0, 0);
                 * activeSheet.addCustomName("customName3", "=$A$1:$C$1");
                 * activeSheet.setFormula(1, 0, "customName1");
                 * activeSheet.setFormula(1, 1, "customName2");
                 * activeSheet.setFormula(1, 2, "sum(customName3)");
                 * $("#button1").click(function () {
                 *     var cname = activeSheet.getCustomName("customName2");
                 *     if (cname instanceof GC.Spread.Sheets.NameInfo) {
                 *         //get CustomName
                 *         var name = cname.getName();
                 *         //get Expression
                 *         var expression = cname.getExpression();
                 *         //get Expression String
                 *         var expStr = GC.Spread.Sheets.CalcEngine.expressionToFormula(activeSheet, expression, 0, 0);
                 *         alert("Name:" + name + ";Expression: =" + expStr);
                 *     }
                 * });
                 */
                getCustomName(name:  string): GC.Spread.Sheets.NameInfo;
                /**
                 * Gets all custom name information.
                 * @returns {Array} The type GC.Spread.Sheets.NameInfo stored in an array.
                 */
                getCustomNames(): GC.Spread.Sheets.NameInfo[];
                /**
                 * Gets the column name at the specified position.
                 * @param {number} column The column index for which the name is requested.
                 * @returns {string} The column name for data binding.
                 * @example
                 * //This example returns the name for the specified bound column.
                 * var test = [
                 *         {"Series0":2,"Series1":1},
                 *         {"Series0":4,"Series1":2},
                 *         {"Series0":3,"Series1":4}
                 *     ];
                 * activeSheet.setDataSource(test);
                 * activeSheet.bindColumn(1,"Series0");
                 * activeSheet.bindColumn(0,"Series1");
                 * var colname = activeSheet.getDataColumnName(0);
                 * alert(colname);
                 */
                getDataColumnName(column:  number): string;
                /**
                 * Gets the data item.
                 * @param {number} row The row index.
                 * @returns {Object} The row data.
                 * @example
                 * //This example uses the getDataItem method.
                 * var test = [
                 *       { "Series0": 2, "Series1": 1 },
                 *       { "Series0": 4, "Series1": 2 },
                 *       { "Series0": 3, "Series1": 4 }
                 *            ];
                 *            activeSheet.autoGenerateColumns = true;
                 *            activeSheet.setDataSource(test, false);
                 *            alert(JSON.stringify(activeSheet.getDataItem(0)));
                 */
                getDataItem(row:  number): any;
                /**
                 * Gets the data source that populates the sheet.
                 * @function
                 * @returns {Object} Returns the data source.
                 * @example
                 * var test = [
                 *         {"Series0":2,"Series1":1},
                 *         {"Series0":4,"Series1":2},
                 *         {"Series0":3,"Series1":4}
                 *     ];
                 * activeSheet.setDataSource(test);
                 * alert(activeSheet.getDataSource);
                 */
                getDataSource(): any;
                /**
                 * Gets the cell data validator.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @returns {GC.Spread.Sheets.DataValidation.DefaultDataValidator} Returns the cell data validator for the specified cell.
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GC.Spread.Sheets.DataValidation.createListValidator("1,2,3");
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Value must be 1,2 or 3");
                 * dv.inputTitle("tip");
                 * activeSheet.setDataValidator(1,1,1,1,dv,GC.Spread.Sheets.SheetArea.viewport);
                 * alert(activeSheet.getDataValidator(1,1).getValidList(activeSheet,1,1));
                 */
                getDataValidator(row:  number,  col:  number,  sheetArea:  GC.Spread.Sheets.SheetArea): GC.Spread.Sheets.DataValidation.DefaultDataValidator;
                /**
                 * Gets the default style information for the sheet.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @returns {GC.Spread.Sheets.Style} Returns the sheet's default style.
                 * @example
                 * //This example uses the getDefaultStyle method.
                 * var defaultStyle = new GC.Spread.Sheets.Style();
                 * defaultStyle.backColor = "LemonChiffon";
                 * defaultStyle.foreColor = "Red";
                 * defaultStyle.borderLeft = new GC.Spread.Sheets.LineBorder("Green");
                 * defaultStyle.borderTop = new GC.Spread.Sheets.LineBorder("Green");
                 * defaultStyle.borderRight = new GC.Spread.Sheets.LineBorder("Green");
                 * defaultStyle.borderBottom = new GC.Spread.Sheets.LineBorder("Green");
                 * activeSheet.setDefaultStyle(defaultStyle, GC.Spread.Sheets.SheetArea.viewport);
                 * var cstyle = activeSheet.getDefaultStyle(GC.Spread.Sheets.SheetArea.viewport);
                 * alert(cstyle.backColor);
                 */
                getDefaultStyle(sheetArea?:  GC.Spread.Sheets.SheetArea): GC.Spread.Sheets.Style;
                /**
                 * Gets the deleted row collection.
                 * @return {Array} The deleted rows collection. the item in array contains two properties, row.row: specifies deleted row index, row.originalItem: specifies deleted data item.
                 */
                getDeletedRows(): any[];
                /**
                 * Gets the dirty cell collection.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {number} rowCount The number of rows in the range of dirty cells.
                 * @param {number} colCount The number of columns in the range of dirty cells.
                 * @return {Array} The dirty cells.
                 */
                getDirtyCells(row:  number,  col:  number,  rowCount:  number,  colCount:  number): GC.Spread.Sheets.IDirtyCellInfo[];
                /**
                 * Gets the dirty row collection.
                 * @returns {Array} The dirty rows collection, the item in array contains three properties, row.row: specifies row index, row.item: specifies data item of current row, row.originalItem: specifies original data item of the row.
                 */
                getDirtyRows(): any[];
                /**
                 * Gets the cell formatter.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @returns {Object} Returns the cell formatter string or object for the specified cell.
                 * @example
                 * //This example returns the format object for the active sheet.
                 * activeSheet.getCell(0, 1).formatter("M");
                 * activeSheet.setValue(0, 1, new Date(2011, 2, 9));
                 * var style = activeSheet.getFormatter(0,1,GC.Spread.Sheets.SheetArea.viewport);
                 * alert(style);
                 */
                getFormatter(row:  number,  col:  number,  sheetArea:  GC.Spread.Sheets.SheetArea): Object;
                /**
                 * Gets the formula in the specified cell in this sheet.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @returns {string} Returns the formula string.
                 * @example
                 * //This example returns the formula in the specified cell.
                 * activeSheet.setValue(0,0,1);
                 * activeSheet.setValue(0,1,2);
                 * activeSheet.setValue(0,2,10);
                 * activeSheet.getCell(1,1).formula("=SUM(A1:C1)");
                 * var formula = activeSheet.getFormula(1,1);
                 * alert(formula);
                 */
                getFormula(row:  number,  col:  number): string;
                /**
                 * Gets the formula detail information in the specified cell in this sheet.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @returns {object} formulaInfo - Returns the formula information about the cell.
                 * formulaInfo.hasFormula {boolean} Indicates whether there is a formula in the cell.
                 * formulaInfo.isArrayFormula {boolean} Indicates whether the formula is an array formula.
                 * formulaInfo.formula {string} The formula string.
                 * formulaInfo.formulaWithCulture {string} The formula string with culture.
                 * @example
                 * activeSheet.setValue(0,0,1);
                 * activeSheet.setValue(0,1,2);
                 * activeSheet.setValue(0,2,10);
                 * activeSheet.getCell(1,1).formula("=SUM(A1:C1)");
                 * var test = activeSheet.getFormulaInformation(1,1, GC.Spread.Sheets.SheetArea.viewport);
                 * alert(test.formula);
                 */
                getFormulaInformation(row:  number,  col:  number): IFormulaInformation;
                /**
                 * Gets the inserted row collection.
                 * @returns {Array} The inserted rows collection, the item in array contains two properties, row.row: specifies insert row index, row.item: specifies insert data item.
                 */
                getInsertRows(): any[];
                /**
                 * Gets a style from the Worksheet named styles collection which has the specified name.
                 * @param {string} name The name of the style to return.
                 * @returns {GC.Spread.Sheets.Style} Returns the specified named style.
                 */
                getNamedStyle(name:  string): GC.Spread.Sheets.Style;
                /**
                 * Gets named styles from the Worksheet.
                 * @returns {Array} The GC.Spread.Sheets.Style array of named styles.
                 */
                getNamedStyles(): GC.Spread.Sheets.Style[];
                /**
                 * Gets the parent Spread object of the current sheet.
                 * @returns {GC.Spread.Sheets.Workbook} Returns the parent Spread object of the current sheet.
                 */
                getParent(): GC.Spread.Sheets.Workbook;
                /**
                 * Gets a range of cells in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {number} rowCount The row count of the range. If you do not provide this parameter, it defaults to <b>1</b>.
                 * @param {number} colCount The column count of the range. If you do not provide this parameter, it defaults to <b>1</b>.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @returns {GC.Spread.Sheets.CellRange} The cellRange.
                 * If row is -1 and rowCount is -1, the range represents columns. For example, sheet.getRange(-1,4,-1,6) returns the columns "E:J".
                 * If col is -1 and colCount is -1, the range represents rows. For example, sheet.getRange(4,-1,6,-1) returns the rows "5:10".
                 */
                getRange(row:  number,  col:  number,  rowCount?:  number,  colCount?:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea): GC.Spread.Sheets.CellRange;
                /**
                 * Gets the row count in the specified sheet area.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @returns {number} The number of rows.
                 * @example
                 * //This example gets the row count.
                 * var count = activeSheet.getRowCount(GC.Spread.Sheets.SheetArea.viewport);
                 * alert(count);
                 */
                getRowCount(sheetArea?:  GC.Spread.Sheets.SheetArea): number;
                /**
                 * Gets the height in pixels for the specified row in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @returns {number} The row height in pixels.
                 * @example
                 * //This example returns the height for the specified row.
                 * var rheight = activeSheet.getRowHeight(1,GC.Spread.Sheets.SheetArea.viewport);
                 * alert(rheight);
                 */
                getRowHeight(row:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea): number;
                /**
                 * Gets whether a forced page break is inserted before the specified row on this sheet when printing.
                 * @param {number} row The row index.
                 * @returns {boolean} <c>true</c> if a forced page break is inserted before the specified row; otherwise, <c>false</c>.
                 */
                getRowPageBreak(row:  number): boolean;
                /**
                 * Gets a value that indicates whether users can resize the specified row in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @returns {boolean} <c>true</c> if the users can resize the specified row; otherwise, <c>false</c>.
                 * @example
                 * //This example gets whether the row is resizable.
                 * sheet.setRowCount(10);
                 * sheet.setColumnCount(7);
                 * sheet.setValue(0, 0,"Western");
                 * sheet.setValue(0, 1,"Western");
                 * sheet.setValue(0, 2,"Western");
                 * sheet.setValue(1, 0,"A");
                 * sheet.setValue(1, 1,"B");
                 * sheet.setValue(1, 2,"C");
                 * sheet.setColumnResizable(0,true, GC.Spread.Sheets.SheetArea.colHeader);
                 * sheet.setRowResizable(0,true, GC.Spread.Sheets.SheetArea.rowHeader);
                 * alert( sheet.getColumnResizable(0));
                 * alert( sheet.getRowResizable(0, GC.Spread.Sheets.SheetArea.rowHeader));
                 */
                getRowResizable(row:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea): boolean;
                /**
                 * Gets whether the control displays the specified row.
                 * @param {number} row The row index.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @returns {boolean} <c>true</c> if the row is visible in the sheet area; otherwise, <c>false</c>.
                 * @example
                 * //This example returns the visible setting for the specified row.
                 * rvisible = activeSheet.getRowVisible(1,GC.Spread.Sheets.SheetArea.viewport);
                 * alert(rvisible);
                 */
                getRowVisible(row:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea): boolean;
                /**
                 * Gets the selections in the current sheet.
                 * @returns {Array.<GC.Spread.Sheets.Range>} The type GC.Spread.Sheets.Range is stored in an Array.
                 */
                getSelections(): GC.Spread.Sheets.Range[];
                /**
                 * Gets the spans in the specified range in the specified sheet area.
                 * @param {GC.Spread.Sheets.Range} range The cell range.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @returns {Array} An array that contains span information whose item type is GC.Spread.Sheets.Range.
                 */
                getSpans(range:  GC.Spread.Sheets.Range): GC.Spread.Sheets.Range[];
                /**
                 *  Gets the sparkline for the specified cell.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @returns {GC.Spread.Sheets.Sparkline} The sparkline for the cell.
                 * @example
                 * //This example creates and gets a sparkline.
                 * var cellr = new GC.Spread.Sheets.Range(0, 0, 1, 5);
                 * var ex = new GC.Spread.Sheets.Sparklines.SparklineSetting();
                 * ex.options.SeriesColor  = "Aquamarine";
                 * sheet.setValue(0, 0, 2);
                 * sheet.setValue(0, 1, 5);
                 * sheet.setValue(0, 2, 4);
                 * sheet.setValue(0, 3, -1);
                 * sheet.setValue(0, 4, 3);
                 * sheet.setSparkline(0, 5, cellr, GC.Spread.Sheets.Sparklines.DataOrientation.horizontal, GC.Spread.Sheets.Sparklines.SparklineType.column, ex);
                 * alert(sheet.getSparkline(0, 5).toString());
                 * //sheet.removeSparkline(0, 5);
                 */
                getSparkline(row:  number,  column:  number): GC.Spread.Sheets.Sparklines.Sparkline;
                /**
                 * Gets the style information for a specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} column The column index.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @returns {GC.Spread.Sheets.Style} Returns the cell style of the specified cell.
                 * @example
                 * //This example uses the getStyle method.
                 * var style = new GC.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.borderLeft =new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderTop = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderRight = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderBottom = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
                 * var cstyle = activeSheet.getStyle(1,1,GC.Spread.Sheets.SheetArea.viewport, true);
                 * alert(cstyle.backColor);
                 */
                getStyle(row:  number,  column:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea): GC.Spread.Sheets.Style;
                /**
                 * Gets the name of the style for a specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} column The column index.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @returns {string} Returns the name string for the style.
                 * @example
                 * //This example uses the getStyleName method.
                 * var namedStyle = new GC.Spread.Sheets.Style();
                 * namedStyle.name = "style1";
                 * namedStyle.backColor = "green";
                 * activeSheet.addNamedStyle(namedStyle);
                 * activeSheet.setStyleName(1, 1, "style1"); // cell(1,1)'s backColor is  green.
                 * activeSheet.setStyleName(2, 1, "style1");
                 * alert(activeSheet.getStyleName(1,1,GC.Spread.Sheets.SheetArea.viewport));
                 */
                getStyleName(row:  number,  column:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea): string;
                /**
                 * Gets the tag value from the specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @returns {Object} Returns the tag value of the cell.
                 * @example
                 * //This example adds and gets a cell tag.
                 * activeSheet.getRange(1, -1, 1, -1).tag("row tag");
                 * alert(activeSheet.getTag(1,-1,GC.Spread.Sheets.SheetArea.viewport));
                 */
                getTag(row:  number,  col:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea): any;
                /**
                 * Gets the formatted text in the cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @returns {string} Returns the formatted text of the cell.
                 * @example
                 * activeSheet.getText(1, 0);
                 */
                getText(row:  number,  col:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea): string;
                /**
                 * Gets the unformatted data from the specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @param {GC.Spread.Sheets.ValueType} valueType - Indicate the return value type is normal text or rich text, default is normal text.
                 * @returns {Object} Returns the value of the cell.
                 * @example
                 * activeSheet.getValue(1, 1, GC.Spread.Sheets.SheetArea.viewport, GC.Spread.Sheets.ValueType.richText);
                 */
                getValue(row:  number,  col:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea,  valueType?:  GC.Spread.Sheets.ValueType): any;
                /**
                 * Gets the index of the bottom row in the viewport.
                 * @param {number} rowViewportIndex The index of the viewport.
                 * @returns {number} The index of the bottom row in the viewport.
                 * @example
                 * //This example returns the indices for the bottom and top rows and left and right columns in the current sheet view.
                 * var brow = activeSheet.getViewportBottomRow(1);
                 * var lcol = activeSheet.getViewportLeftColumn(1);
                 * var rcol = activeSheet.getViewportRightColumn(1);
                 * var trow = activeSheet.getViewportTopRow(1);
                 * alert(brow);
                 * alert(lcol);
                 * alert(rcol);
                 * alert(trow);
                 */
                getViewportBottomRow(rowViewportIndex:  number): number;
                /**
                 * Gets the height of the specified viewport row for the active sheet.
                 * @param {number} rowViewportIndex The index of the row viewport.
                 * @returns {number} The height of the viewport.
                 * @example
                 * //This example uses the getViewportHeight method.
                 * alert(activeSheet.getViewportHeight(1));
                 */
                getViewportHeight(rowViewportIndex:  number): number;
                /**
                 * Gets the index of the left column in the viewport.
                 * @param {number} columnViewportIndex The index of the viewport.
                 * @returns {number} The index of the left column in the viewport.
                 * @example
                 * //This example returns the indices for the bottom and top rows and left and right columns in the current sheet view.
                 * var brow = activeSheet.getViewportBottomRow(1);
                 * var lcol = activeSheet.getViewportLeftColumn(1);
                 * var rcol = activeSheet.getViewportRightColumn(1);
                 * var trow = activeSheet.getViewportTopRow(1);
                 * alert(brow);
                 * alert(lcol);
                 * alert(rcol);
                 * alert(trow);
                 */
                getViewportLeftColumn(columnViewportIndex:  number): number;
                /**
                 * Gets the index of the right column in the viewport.
                 * @param {number} columnViewportIndex The index of the viewport.
                 * @returns {number} The index of the right column in the viewport.
                 * @example
                 * //This example returns the indices for the bottom and top rows and left and right columns in the current sheet view.
                 * var brow = activeSheet.getViewportBottomRow(1);
                 * var lcol = activeSheet.getViewportLeftColumn(1);
                 * var rcol = activeSheet.getViewportRightColumn(1);
                 * var trow = activeSheet.getViewportTopRow(1);
                 * alert(brow);
                 * alert(lcol);
                 * alert(rcol);
                 * alert(trow);
                 */
                getViewportRightColumn(columnViewportIndex:  number): number;
                /**
                 * Gets the index of the top row in the viewport.
                 * @param {number} rowViewportIndex The index of the viewport.
                 * @returns {number} The index of the top row in the viewport.
                 * @example
                 * //This example returns the indices for the bottom and top rows and left and right columns in the current sheet view.
                 * var brow = activeSheet.getViewportBottomRow(1);
                 * var lcol = activeSheet.getViewportLeftColumn(1);
                 * var rcol = activeSheet.getViewportRightColumn(1);
                 * var trow = activeSheet.getViewportTopRow(1);
                 * alert(brow);
                 * alert(lcol);
                 * alert(rcol);
                 * alert(trow);
                 */
                getViewportTopRow(rowViewportIndex:  number): number;
                /**
                 * Gets the width of the specified viewport column for the active sheet.
                 * @param {number} columnViewportIndex The index of the column viewport.
                 * @returns {number} The width of the viewport
                 * @example
                 * //This example uses the getViewportWidth method.
                 * alert(activeSheet.getViewportWidth(1));
                 */
                getViewportWidth(columnViewportIndex:  number): number;
                /**
                 * Groups the sparklines.
                 * @param {Array.<GC.Spread.Sheets.Sparklines.Sparkline>} sparklines The sparklines to group.
                 * @returns {GC.Spread.Sheets.Sparklines.SparklineGroup} The sparkline group.
                 * @example
                 * //This example groups a sparkline.
                 * sheet.setValue(0, 0, "Data Range is A2-A9");
                 * sheet.setValue(1, 0, 1);
                 * sheet.setValue(2, 0, -2);
                 * sheet.setValue(3, 0, -1);
                 * sheet.setValue(4, 0, 6);
                 * sheet.setValue(5, 0, 4);
                 * sheet.setValue(6, 0, -4);
                 * sheet.setValue(7, 0, 3);
                 * sheet.setValue(8, 0, 8);
                 * var data = new GC.Spread.Sheets.Range(1, 0, 8, 1);
                 * var setting = new GC.Spread.Sheets.Sparklines.SparklineSetting();
                 * var s1=  sheet.setSparkline(13, 0, data
                 *         , GC.Spread.Sheets.Sparklines.DataOrientation.vertical
                 *         , GC.Spread.Sheets.Sparklines.SparklineType.line
                 *         , setting
                 *         );
                 * var s2 =sheet.setSparkline(13, 3, data
                 *         , GC.Spread.Sheets.Sparklines.DataOrientation.vertical
                 *         , GC.Spread.Sheets.Sparklines.SparklineType.column
                 *         , setting
                 *         );
                 * var s3=  sheet.setSparkline(13, 6, data
                 *         , GC.Spread.Sheets.Sparklines.DataOrientation.vertical
                 *         , GC.Spread.Sheets.Sparklines.SparklineType.winloss
                 *         , setting
                 *         );
                 * var group = sheet.groupSparkline([s1,s2,s3]);
                 */
                groupSparkline(sparklines:  Sparklines.Sparkline[]): GC.Spread.Sheets.Sparklines.SparklineGroup;
                /**
                 * Gets whether there is a dirty, insert, or delete status for the specified range.
                 * @returns {boolean} <c>true</c> if any of the rows or cells in the range are dirty, or have been inserted or deleted; otherwise, <c>false</c>.
                 */
                hasPendingChanges(): boolean;
                /**
                 * Performs a hit test.
                 * @param {number} x The <i>x</i>-coordinate.
                 * @param {number} y The <i>y</i>-coordinate.
                 * @returns {Object} The hit test information.
                 */
                hitTest(x:  number,  y:  number): IHitTestInformation;
                /**
                 * Invalidates the sheet layout.
                 * @example
                 * //This example updates the layout.
                 * activeSheet.columnOutlines.group(0, 1);
                 * activeSheet.invalidateLayout();
                 * activeSheet.repaint();
                 */
                invalidateLayout(): void;
                /**
                 * Gets whether recording the dirty data is suspended.
                 * @example
                 * //This example uses the isDirtySuspended method.
                 * var customers = [
                 *                { ID: 0, Name: 'A', Info1: 'Info0' },
                 *                { ID: 1, Name: 'B', Info1: 'Info1' },
                 *                { ID: 2, Name: 'C', Info1: 'Info2' },
                 *             ];
                 * activeSheet.setDataSource(customers);
                 * activeSheet.suspendDirty();
                 * alert(activeSheet.isDirtySuspended());
                 * activeSheet.resumeDirty();
                 * alert(activeSheet.isDirtySuspended());
                 */
                isDirtySuspended(): boolean;
                /**
                 * Gets whether the sheet is in edit mode.
                 * @returns {boolean} <c>true</c> if the sheet is in edit mode; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the isEditing method.
                 * alert(activeSheet.isEditing());
                 */
                isEditing(): boolean;
                /**
                 * Get if sheet paint is suspended.
                 */
                isPaintSuspended(): boolean;
                /**
                 * Determines whether the cell value is valid.
                 * @param {number} row The row index.
                 * @param {number} column The column index.
                 * @param {Object} value The cell value.
                 * @returns {boolean} <c>true</c> if the value is valid; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the isValid method.
                 * alert(activeSheet.isValid(0, 0, 10));
                 */
                isValid(row:  number,  column:  number,  value:  Object): boolean;
                /**
                 * Moves data from one range to another.
                 * @param {number} fromRow The source row.
                 * @param {number} fromColumn The source column.
                 * @param {number} toRow The target row.
                 * @param {number} toColumn The target column.
                 * @param {number} rowCount The row count.
                 * @param {number} columnCount The column count.
                 * @param {GC.Spread.Sheets.CopyToOptions} option The copy option.
                 * @example
                 * //This example moves the data to the specified location.
                 * activeSheet.getCell(0,0).value("A1");
                 * activeSheet.getCell(1,1).value("Test")
                 * activeSheet.moveTo(0,0,3,3,2,2,GC.Spread.Sheets.CopyToOptions.value);
                 */
                moveTo(fromRow:  number,  fromColumn:  number,  toRow:  number,  toColumn:  number,  rowCount:  number,  columnCount:  number,  option:  GC.Spread.Sheets.CopyToOptions): void;
                /**
                 * Gets or sets the name of the worksheet.
                 * @param {string} The name of the worksheet.
                 * @returns {string|GC.Spread.Sheets.Worksheet} If no value is set, returns the worksheet name; otherwise, returns the worksheet.
                 * @example
                 * spread.sheets[0].name("The first sheet");
                 * spread.sheets[1].name( "The second sheet");
                 */
                name(value?:  string): any;
                /**
                 * Gets or sets the print information for the sheet.
                 * @param {GC.Spread.Sheets.Print.PrintInfo} value The print information for the sheet.
                 * @returns {GC.Spread.Sheets.Print.PrintInfo | GC.Spread.Sheets.Worksheet} If no value is set, returns the print information for the sheet; otherwise, returns the sheet.
                 */
                printInfo(value?:  GC.Spread.Sheets.Print.PrintInfo): any;
                /**
                 * Recalculates all the formulas in the sheet.
                 * @param {boolean} refreshAll Specifies whether to rebuild all fromula reference, custom name and custom functions.
                 * @example
                 * //This example uses the recalcAll method.
                 * activeSheet.setValue(0,0,1);
                 * activeSheet.setValue(0,1,2);
                 * activeSheet.setValue(0,2,10);
                 * activeSheet.getCell(1,1).formula("=SUM(A1:C1)");
                 * activeSheet.recalcAll();
                 */
                recalcAll(refreshAll?:  boolean): void;
                /**
                 * Removes a custom function.
                 * @param {string} fnName The custom function name.
                 * @example
                 * //This example uses the removeCustomFunction method.
                 * // Add Custom function
                 * // Type =myfunc(1)
                 * // in a cell to see the result
                 * function myfunc() {}
                 * myfunc.prototype = new GC.Spread.CalcEngine.Functions.Function("myfunc", 0, 0, {name: "myfunc",description: "This is my first function"});
                 * myfunc.prototype.evaluate = function (args) {
                 *     return 100;
                 * }
                 * spread.addCustomFunction(new myfunc());
                 * //spread.removeCustomFunction("myfunc");
                 */
                removeCustomFunction(name:  string): void;
                /**
                 * Removes the specified custom name.
                 * @param {string} fnName The custom name.
                 * @example
                 * //This example uses the removeCustomName method.
                 * activeSheet.setValue(0, 0, 1);
                 * activeSheet.setValue(0, 1, 2);
                 * activeSheet.setValue(0, 2, 3);
                 * activeSheet.addCustomName("customName1","=12", 0, 0);
                 * activeSheet.addCustomName("customName2","Average(20,45)", 0, 0);
                 * activeSheet.addCustomName("customName3", "=$A$1:$C$1", 0, 0);
                 * activeSheet.setFormula(1, 0, "customName1");
                 * activeSheet.setFormula(1, 1, "customName2");
                 * activeSheet.setFormula(1, 2, "sum(customName3)");
                 * //activeSheet.removeCustomName("customName3");
                 */
                removeCustomName(name:  string): void;
                /**
                 * Removes a style from the Worksheet named styles collection which has the specified name.
                 * @param {string} name The name of the style to remove.
                 */
                removeNamedStyle(name:  string): void;
                /**
                 * Removes the span that contains a specified anchor cell in the specified sheet area.
                 * @param {number} row The row index of the anchor cell for the span (at which spanned cells start).
                 * @param {number} col The column index of the anchor cell for the span (at which spanned cells start).
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @example
                 * activeSheet.addSpan(0,0,3,3,GC.Spread.Sheets.SheetArea.viewport);
                 * //activeSheet.removeSpan(0, 0, GC.Spread.Sheets.SheetArea.viewport);
                 */
                removeSpan(row:  number,  col:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea): void;
                /**
                 * Removes the sparkline for the specified cell.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @example
                 * //This example removes a sparkline.
                 * var cellr = new GC.Spread.Sheets.Range(0, 0, 1, 5);
                 * var ex = new GC.Spread.Sheets.Sparklines.SparklineSetting();
                 * ex.options.SeriesColor  = "Aquamarine";
                 * sheet.setValue(0, 0, 2);
                 * sheet.setValue(0, 1, 5);
                 * sheet.setValue(0, 2, 4);
                 * sheet.setValue(0, 3, -1);
                 * sheet.setValue(0, 4, 3);
                 * sheet.setSparkline(0, 5, cellr, GC.Spread.Sheets.Sparklines.DataOrientation.horizontal, GC.Spread.Sheets.Sparklines.SparklineType.column, ex);
                 * alert(sheet.getSparkline(0, 5).toString());
                 * //sheet.removeSparkline(0, 5);
                 */
                removeSparkline(row:  number,  col:  number): void;
                /**
                 * Repaints the specified rectangle.
                 * @param {GC.Spread.Sheets.Rect} clipRect The rectangle to repaint.
                 * @example
                 * //This example causes a repaint.
                 * var cellrange =new GC.Spread.Sheets.Range(0, 0, 5, 1);
                 * var hideRowFilter =new GC.Spread.Sheets.Filter.HideRowFilter(cellrange);
                 * sheet.rowFilter(hideRowFilter);
                 * sheet.resumePaint();
                 * sheet.repaint();
                 */
                repaint(clipRect?:  GC.Spread.Sheets.Rect): void;
                /**
                 * Resets the sheet.
                 * @example
                 * //This example uses the reset method.
                 * activeSheet.reset();
                 */
                reset(): void;
                /**
                 * Resumes the calculation service.
                 * @param {boolean} recalcAll Specifies whether to recalculate all formulas.
                 * @example
                 * //This example uses the resumeCalcService method.
                 * activeSheet.suspendCalcService(false);
                 * activeSheet.setValue(0,0,1);
                 * activeSheet.setValue(0,1,2);
                 * activeSheet.setValue(0,2,10);
                 * activeSheet.getCell(1,1).formula("=SUM(A1:C1)");
                 * activeSheet.resumeCalcService(true);
                 */
                resumeCalcService(recalcAll?:  boolean): void;
                /**
                 * Resumes recording the dirty data.
                 * @example
                 * //This example uses the resumeDirty method.
                 *  var customers = [
                 *                { ID: 0, Name: 'A', Info1: 'Info0' },
                 *                { ID: 1, Name: 'B', Info1: 'Info1' },
                 *                { ID: 2, Name: 'C', Info1: 'Info2' },
                 *             ];
                 * activeSheet.setDataSource(customers);
                 * activeSheet.suspendDirty();
                 * alert(activeSheet.isDirtySuspended());
                 * activeSheet.resumeDirty();
                 * alert(activeSheet.isDirtySuspended());
                 */
                resumeDirty(): void;
                /**
                 * Resumes the event.
                 * @example
                 * //This example suspends and resumes the event.
                 *  activeSheet.bind(GC.Spread.Sheets.Events.CellChanged, function (sender, args) {
                 *     if (args.propertyName === "value") {
                 *         alert(activeSheet.getValue(args.row, args.col));
                 *     }
                 * });
                 * activeSheet.suspendEvent();
                 * activeSheet.setValue(0, 0, "111");
                 * activeSheet.resumeEvent();
                 * activeSheet.setValue(1, 1, "222");
                 */
                resumeEvent(): void;
                /**
                 * Resumes the paint.
                 */
                resumePaint(): void;
                /**
                 * Gets or sets the row filter for the sheet.
                 * @param {GC.Spread.Sheets.Filter.RowFilterBase} value The row filter for the sheet.
                 * @returns {GC.Spread.Sheets.Filter.RowFilterBase} The row filter for the sheet.
                 * @example
                 * //This example creates a row filter.
                 * sheet.rowFilter(new GC.Spread.Sheets.Filter.HideRowFilter(new GC.Spread.Sheets.Range(1,1,10,3)));
                 */
                rowFilter(value?:  GC.Spread.Sheets.Filter.RowFilterBase): GC.Spread.Sheets.Filter.RowFilterBase;
                /**
                 * Searches the specified content.
                 * @param {GC.Spread.Sheets.Search.SearchCondition} searchCondition The search condition.
                 * @returns {GC.Spread.Sheets.Search.SearchResult} The search result.
                 * @example
                 * //This example uses the search method.
                 * activeSheet.getCell(2,3).value("testSearch");
                 * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                 * searchCondition.searchString = "testSearch";
                 * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                 * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                 * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                 * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                 * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.ignoreCase| GC.Spread.Sheets.Search.SearchFlags.useWildCards;
                 * var searchresult= activeSheet.search(searchCondition);
                 * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" +
                 * searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundSheetIndex+"]";
                 * alert(str);
                 */
                search(searchCondition:  GC.Spread.Sheets.Search.SearchCondition): GC.Spread.Sheets.Search.SearchResult;
                /**
                 * Gets or sets whether users can select ranges of items on a sheet.
                 * @param {GC.Spread.Sheets.SelectionPolicy} value Whether users can select single items, ranges, or a combination of both.
                 * @returns {GC.Spread.Sheets.SelectionPolicy|GC.Spread.Sheets.Worksheet} If no value is set, returns the selection policy setting; otherwise, returns the sheet.
                 * @example
                 * //This example uses the selectionPolicy method.
                 * activeSheet.selectionUnit(GC.Spread.Sheets.SelectionUnit.row);
                 * activeSheet.selectionPolicy(GC.Spread.Sheets.SelectionPolicy.range);
                 */
                selectionPolicy(value?:  GC.Spread.Sheets.SelectionPolicy): any;
                /**
                 * Gets or sets whether users can select cells, rows, or columns on a sheet.
                 * @param {GC.Spread.Sheets.SelectionUnit} value Whether users can select cells, rows, or columns.
                 * @returns {GC.Spread.Sheets.SelectionUnit|GC.Spread.Sheets.Worksheet} If no value is set, returns the selection unit setting; otherwise, returns the sheet.
                 * @example
                 * //This example uses the selectionUnit method.
                 * activeSheet.selectionUnit(GC.Spread.Sheets.SelectionUnit.row);
                 * activeSheet.selectionPolicy(GC.Spread.Sheets.SelectionPolicy.range);
                 */
                selectionUnit(value?:  GC.Spread.Sheets.SelectionUnit): any;
                /**
                 * Sets the active cell for this sheet.
                 * @param {number} row The row index of the cell.
                 * @param {number} col The column index of the cell.
                 * @example
                 * //This example sets the active cell.
                 * sheet.setActiveCell(5,5);
                 * alert(sheet.getActiveColumnIndex());
                 * alert(sheet.getActiveRowIndex());
                 * spread.bind(GC.Spread.Sheets.Events.EnterCell, function (event, data) {
                 *     alert(data.col);
                 *     alert(data.row);
                 *   });
                 * spread.bind(GC.Spread.Sheets.Events.LeaveCell, function (event, data) {
                 *     alert(data.col);
                 *     alert(data.row);
                 *   });
                 */
                setActiveCell(row:  number,  col:  number,  rowViewportIndex?:  number,  colViewportIndex?:  number): void;
                /**
                 * Sets the values in the specified two-dimensional array of objects into the specified range of cells on this sheet.
                 * @param {number} row The row index.
                 * @param {number} column The column index.
                 * @param {Array} array The array from which to set values.
                 * @param {boolean} setFormula If <c>true</c>, set formulas; otherwise, set values.
                 * @example
                 * //This example uses the setArray method.
                 * //set value
                 * var array = [[1,2,3],[4,5],[6,7,8,9]];
                 * activeSheet.setArray(1, 2, array);
                 * //set formula
                 * var array = [["=1+1","=2+2","=3+3"],["=4+4","=5+5"],["=6+6","=7+7","=8+8","=9+9"]];
                 * activeSheet.setArray(1, 2, array, true);
                 * //get value
                 * var newArray = activeSheet.getArray(1, 2, 3, 4);
                 * //getformula
                 * var newArray = activeSheet.getArray(1, 2, 3, 4, true);
                 * //alert(newArray[0]);
                 */
                setArray(row:  number,  column:  number,  array:  any[],  setFormula?:  boolean): void;
                /**
                 * Sets a formula in a specified cell in the specified sheet area.
                 * @param {number} row The start row index.
                 * @param {number} col The start column index.
                 * @param {number} rowCount The number of rows in range.
                 * @param {number} colCount The number of columns in range.
                 * @param {string} value The array formula to place in the specified range.
                 * @example
                 * //This example uses the setArrayFormula method.
                 * activeSheet.getCell(1,1).value(3);
                 * activeSheet.getCell(2,1).value(1);
                 * activeSheet.getCell(3,1).value(3);
                 * activeSheet.getCell(4,1).value(7);
                 * activeSheet.getCell(1,2).value(7);
                 * activeSheet.getCell(2,2).value(7);
                 * activeSheet.getCell(3,2).value(7);
                 * activeSheet.getCell(4,2).value(7);
                 * spread.allowUserEditFormula(true);
                 * activeSheet.setArrayFormula(0, 3, 4, 1, "B2:B5*C2:C5");
                 */
                setArrayFormula(row:  number,  col:  number,  rowCount:  number,  colCount:  number,  value:  string): void;
                /**
                 * Sets the binding path for cell-level binding in a specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {string} path The binding path for the cell binding source.
                 * @example
                 * //This example binds a cell.
                 * var test = {name: "John", gender: "male"};
                 * sheet.setBindingPath(0, 0, "name");
                 * sheet.setBindingPath(0, 1, "gender");
                 * sheet.setDataSource(new GC.Spread.Sheets.Bindings.CellBindingSource(test));
                 */
                setBindingPath(row:  number,  col:  number,  path:  string): void;
                /**
                 * Sets the cell type.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GC.Spread.Sheets.CellTypes.Base} value The cell type.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @example
                 * //This example uses the setCellType method.
                 * var cellType = new GC.Spread.Sheets.CellTypes.Button();
                 * cellType.buttonBackColor("#FFFF00");
                 * cellType.text("this is a button");
                 * activeSheet.setCellType(1,1,cellType);
                 * spread.bind(GC.Spread.Sheets.Events.ButtonClicked, function (e, args) {
                 *     var sheet = args.sheet, row = args.row, col = args.col;
                 *     var cellType = activeSheet.getCellType(row, col);
                 *     if (cellType instanceof GC.Spread.Sheets.CellTypes.Button) {
                 *         alert("Button Clicked");
                 *     }
                 * });
                 */
                setCellType(row:  number,  col:  number,  value:  GC.Spread.Sheets.CellTypes.Base,  sheetArea?:  GC.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the column count in the specified sheet area.
                 * @param {number} colCount The column count.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @example
                 * //This example sets the number of columns.
                 * sheet.setRowCount(4,1);
                 * sheet.setColumnCount(4,2);
                 * sheet.addSpan(0,0,3,3,GC.Spread.Sheets.SheetArea.colHeader);
                 * sheet.addSpan(0,0,3,3,GC.Spread.Sheets.SheetArea.rowHeader);
                 * sheet.addSpan(0,0,3,3,GC.Spread.Sheets.SheetArea.viewport);
                 */
                setColumnCount(colCount:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea): void;
                /**
                 * Sets whether a forced page break is inserted before the specified column on this sheet when printing.
                 * @param {number} column The column index.
                 * @param {boolean} value Set to <c>true</c> to force a page break before the specified column on this sheet when printing.
                 * @example
                 * //This example sets the page break.
                 * activeSheet.setColumnPageBreak(5, true);
                 */
                setColumnPageBreak(column:  number,  value:  boolean): void;
                /**
                 * Sets whether users can resize the specified column in the specified sheet area.
                 * @param {number} col The column index.
                 * @param {boolean} value Set to <c>true</c> to allow users to resize the column.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @example
                 * //This example sets the setColumnResizable method.
                 * sheet.setRowResizable(3,false,GC.Spread.Sheets.SheetArea.viewport);
                 * sheet.setColumnResizable(3,false,GC.Spread.Sheets.SheetArea.viewport);
                 * sheet.getRange(1,-1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).resizable(false);
                 * sheet.getRange(-1, 1, -1, 1, GC.Spread.Sheets.SheetArea.viewport).resizable(false);
                 */
                setColumnResizable(col:  number,  value:  boolean,  sheetArea?:  GC.Spread.Sheets.SheetArea): void;
                /**
                 * Sets whether a column in the specified sheet area is displayed.
                 * @param {number} col The column index.
                 * @param {boolean} value Whether to display the column.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @example
                 * //This example sets the specified column to be hidden.
                 * activeSheet.setColumnVisible(2,false,GC.Spread.Sheets.SheetArea.viewport);
                 */
                setColumnVisible(col:  number,  value:  boolean,  sheetArea?:  GC.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the width in pixels for the specified column in the specified sheet area.
                 * @param {number} col The column index.
                 * @param {number} value The width in pixels.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to viewport.
                 * @example
                 * //This example sets the column width.
                 * sheet.setValue(0, 0, "value");
                 * sheet.addRows(0, 2);
                 * sheet.addColumns(0, 2);
                 * sheet.setRowHeight(0, 50.0,GC.Spread.Sheets.SheetArea.viewport);
                 * sheet.setColumnWidth(0, 150.0,GC.Spread.Sheets.SheetArea.viewport);
                 * sheet.getRange(0, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).backColor("Gray");
                 * sheet.getRange(-1, 0, -1, 1, GC.Spread.Sheets.SheetArea.viewport).backColor ("Brown");
                 */
                setColumnWidth(col:  number,  value:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea): void;
                /**
                 * Sets delimited text (CSV) in the sheet.
                 * @param {number} row The start row.
                 * @param {number} column The start column.
                 * @param {string} text The delimited text.
                 * @param {string} rowDelimiter The row delimiter.
                 * @param {string} columnDelimiter The column delimiter.
                 */
                setCsv(row:  number,  column:  number,  text:  string,  rowDelimiter:  string,  columnDelimiter:  string): void;
                /**
                 * Sets the data source that populates the sheet.
                 * @param {Object} data The data source.
                 * @param {boolean} reset <c>true</c> if the sheet is reset; otherwise, <c>false</c>.
                 * @example
                 * var test = [
                 *        { "Series0": 2, "Series1": 1 },
                 *        { "Series0": 4, "Series1": 2 },
                 *        { "Series0": 3, "Series1": 4 }
                 *             ];
                 * activeSheet.autoGenerateColumns = true;
                 * activeSheet.setDataSource(test, true);
                 */
                setDataSource(data:  any,  reset?:  boolean): void;
                /**
                 * Sets the cell data validator.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {number} rowCount The row count.
                 * @param {number} colCount The column count.
                 * @param {GC.Spread.Sheets.DataValidation.DefaultDataValidator} value The data validator.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GC.Spread.Sheets.DataValidation.createListValidator("1,2,3");
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Value must be 1,2 or 3");
                 * dv.inputTitle("tip");
                 * activeSheet.setDataValidator(1,1,1,1,dv,GC.Spread.Sheets.SheetArea.viewport);
                 * alert(activeSheet.getDataValidator(1,1).getValidList(activeSheet,1,1));
                 */
                setDataValidator(row:  number,  col:  number,  rowCount:  number,  colCount:  number,  value:  GC.Spread.Sheets.DataValidation.DefaultDataValidator,  sheetArea?:  GC.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the cell data validator.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GC.Spread.Sheets.DataValidation.DefaultDataValidator} value The data validator.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GC.Spread.Sheets.DataValidation.createListValidator("1,2,3");
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Value must be 1,2 or 3");
                 * dv.inputTitle("tip");
                 * activeSheet.setDataValidator(1,1,dv,GC.Spread.Sheets.SheetArea.viewport);
                 * alert(activeSheet.getDataValidator(1,1).getValidList(activeSheet,1,1));
                 */
                setDataValidator(row:  number,  col:  number,  value:  GC.Spread.Sheets.DataValidation.DefaultDataValidator,  sheetArea?:  GC.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the default style information for the sheet.
                 * @param {GC.Spread.Sheets.Style} style The style to set.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 */
                setDefaultStyle(style:  GC.Spread.Sheets.Style,  sheetArea?:  GC.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the cell formatter.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {Object} value The formatter string or object.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @example
                 * //This example sets the format object for the active sheet.
                 * activeSheet.setValue(2, 3, new Date(2011, 2, 9));
                 * activeSheet.setFormatter(2,3,"M",GC.Spread.Sheets.SheetArea.viewport);
                 */
                setFormatter(row:  number,  col:  number,  value:  Object,  sheetArea:  GC.Spread.Sheets.SheetArea): void;
                /**
                 * Sets a formula in a specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {string} value The formula to place in the specified cell.
                 * @example
                 * //This example sets the formula for the specified cell.
                 * activeSheet.setValue(0, 2, 3);
                 * activeSheet.setFormula(1,1,"C1+D1",GC.Spread.Sheets.SheetArea.viewport);
                 */
                setFormula(row:  number,  col:  number,  value:  string): void;
                /**
                 * Sets the row count in the specified sheet area.
                 * @param {number} rowCount The row count.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @example
                 * //This example sets the row count.
                 * sheet.setRowCount(4,1);
                 * sheet.setColumnCount(4,2);
                 * sheet.addSpan(0,0,3,3,GC.Spread.Sheets.SheetArea.colHeader);
                 * sheet.addSpan(0,0,3,3,GC.Spread.Sheets.SheetArea.rowHeader);
                 * sheet.addSpan(0,0,3,3,GC.Spread.Sheets.SheetArea.viewport);
                 */
                setRowCount(rowCount:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the height in pixels for the specified row in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} value The height in pixels.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @example
                 * //This example sets the row height.
                 * sheet.setValue(0, 0, "value");
                 * sheet.addRows(0, 2);
                 * sheet.addColumns(0, 2);
                 * sheet.setRowHeight(0, 50.0,GC.Spread.Sheets.SheetArea.viewport);
                 * sheet.setColumnWidth(0, 150.0,GC.Spread.Sheets.SheetArea.viewport);
                 * sheet.getRange(0, -1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).backColor("Gray");
                 * sheet.getRange(-1, 0, -1, 1, GC.Spread.Sheets.SheetArea.viewport).backColor ("Brown");
                 */
                setRowHeight(row:  number,  value:  number,  sheetArea?:  GC.Spread.Sheets.SheetArea): void;
                /**
                 * Sets whether a forced page break is inserted before the specified row on this sheet when printing.
                 * @param {number} row The row index.
                 * @param {boolean} value Set to <c>true</c> to force a page break before the specified row on this sheet when printing.
                 * @example
                 * activeSheet.setRowPageBreak(3, true);
                 */
                setRowPageBreak(row:  number,  value:  boolean): void;
                /**
                 * Sets whether users can resize the specified row in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {boolean} value Set to <c>true</c> to let the users resize the specified row.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @example
                 * //This example prevents certain rows and columns from being resized.
                 * sheet.setRowResizable(3,false,GC.Spread.Sheets.SheetArea.viewport);
                 * sheet.setColumnResizable(3,false,GC.Spread.Sheets.SheetArea.viewport);
                 * sheet.getRange(1,-1, 1, -1, GC.Spread.Sheets.SheetArea.viewport).resizable(false);
                 * sheet.getRange(-1, 1, -1, 1, GC.Spread.Sheets.SheetArea.viewport).resizable(false);
                 */
                setRowResizable(row:  number,  value:  boolean,  sheetArea?:  GC.Spread.Sheets.SheetArea): void;
                /**
                 * Sets whether the control displays the specified row in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {boolean} value Set to <c>true</c> to display the specified row.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @example
                 * //This example sets the specified row to be hidden.
                 * activeSheet.setRowVisible(1,false,GC.Spread.Sheets.SheetArea.viewport);
                 */
                setRowVisible(row:  number,  value:  boolean,  sheetArea?:  GC.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the selection to a cell or a range and sets the active cell to the first cell.
                 * @param {number} row The row index of the first cell to add.
                 * @param {number} column The column index of the first cell to add.
                 * @param {number} rowCount The number of rows to add.
                 * @param {number} columnCount The number of columns to add.
                 * @example
                 * //This example selects a range of cells.
                 * sheet.setValue(0,0, 1,3);
                 * sheet.setValue(1,0, 50,3);
                 * sheet.setValue(2,0, 100,3);
                 * sheet.setValue(3,0, 2,3);
                 * sheet.setValue(4,0, 60,3);
                 * sheet.setValue(5,0, 90,3);
                 * sheet.setValue(6,0, 3,3);
                 * sheet.setValue(7,0, 40,3);
                 * sheet.setValue(8,0, 70,3);
                 * sheet.setValue(9,0, 5,3);
                 * sheet.setValue(10,0, 35,3);
                 * sheet.setSelection(0,0,11,1);
                 * sheet.conditionalFormats.add3ScaleRule(1, 10, "red", 0, 50, "blue",2, 100, "yellow", sheet.getSelections());
                 */
                setSelection(row:  number,  column:  number,  rowCount:  number,  columnCount:  number): void;
                /**
                 * Sets the sparkline for a cell.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GC.Spread.Sheets.Range | string} dataRange The data range.
                 * @param {GC.Spread.Sheets.Sparklines.DataOrientation} dataOrientation The data orientation.
                 * @param {GC.Spread.Sheets.Sparklines.SparklineType} sparklineType The sparkline type.
                 * @param {GC.Spread.Sheets.Sparklines.SparklineSetting} sparklineSetting The sparkline setting.
                 * @param {GC.Spread.Sheets.Range | string} dateAxisRange The date axis range.
                 * @param {GC.Spread.Sheets.Sparklines.DataOrientation} dateAxisOrientation The date axis range orientation.
                 * @returns {GC.Spread.Sheets.Sparklines.Sparkline} The sparkline.
                 * @example
                 * //This example creates a sparkline for the specified range.
                 * var data = new GC.Spread.Sheets.Range(1, 0, 8, 1);
                 * var setting = new GC.Spread.Sheets.Sparklines.SparklineSetting();
                 * setting.options.showMarkers = true;
                 * setting.options.lineWeight = 3;
                 * setting.options.displayXAxis = true;
                 * setting.options.showFirst = true;
                 * setting.options.showLast = true;
                 * setting.options.showLow = true;
                 * setting.options.showHigh = true;
                 * setting.options.showNegative = true;
                 * setting.options.seriesColor = "Text 2 1";
                 * setting.options.firstMarkerColor = "Text 2 3";
                 * setting.options.negativeColor = "Accent 2 1";
                 * setting.options.markersColor = "Accent 3 1";
                 * setting.options.lowMarkerColor = "Accent 4 1";
                 * setting.options.highMarkerColor = "Accent 6 1";
                 * setting.options.lastMarkerColor = "Accent 6 6";
                 * setting.options.axisColor ="Text 1 1";
                 * sheet.addSpan(13, 0, 4, 3, null);
                 * sheet.setSparkline(13, 0, data, GC.Spread.Sheets.Sparklines.DataOrientation.Vertical, GC.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 * sheet.setValue(1, 0, 1);
                 * sheet.setValue(2, 0, -2);
                 * sheet.setValue(3, 0, -1);
                 * sheet.setValue(4, 0, 6);
                 * sheet.setValue(5, 0, 4);
                 * sheet.setValue(6, 0, -4);
                 * sheet.setValue(7, 0, 3);
                 * sheet.setValue(8, 0, 8);
                 */
                setSparkline(row:  number,  col:  number,  dataRange:  GC.Spread.Sheets.Range | string,  dataOrientation:  GC.Spread.Sheets.Sparklines.DataOrientation,  sparklineType:  GC.Spread.Sheets.Sparklines.SparklineType,  sparklineSetting:  GC.Spread.Sheets.Sparklines.SparklineSetting,  dateAxisRange?:  GC.Spread.Sheets.Range | string,  dateAxisOrientation?:  GC.Spread.Sheets.Sparklines.DataOrientation): GC.Spread.Sheets.Sparklines.Sparkline;
                /**
                 * Sets the style information for a specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} column The column index.
                 * @param {GC.Spread.Sheets.Style} value The cell style.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @example
                 * //This example uses the setStyle method.
                 * var style = new GC.Spread.Sheets.Style();
                 * style.backColor = "lightgreen";
                 * style.backgroundImage = "./css/images/quarter1.png";
                 * activeSheet.setStyle(1,1,style,GC.Spread.Sheets.SheetArea.viewport);
                 */
                setStyle(row:  number,  col:  number,  value:  GC.Spread.Sheets.Style,  sheetArea?:  GC.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the specified style name for a specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} column The column index.
                 * @param {string} value The name of the style to set.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @example
                 * var namedStyle = new GC.Spread.Sheets.Style();
                 * namedStyle.name = "style1";
                 * namedStyle.backColor = "green";
                 * activeSheet.addNamedStyle(namedStyle);
                 * activeSheet.setStyleName(1, 1, "style1"); // cell(1,1)'s backColor is  green.
                 * activeSheet.setStyleName(2, 1, "style1");
                 */
                setStyleName(row:  number,  column:  number,  value:  string,  sheetArea?:  GC.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the tag value for the specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {Object} tag The tag value to set for the specified cell.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @example
                 * activeSheet.setTag(1,1,"test");
                 */
                setTag(row:  number,  col:  number,  tag:  any,  sheetArea?:  GC.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the formatted text in the cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {string} value The text for the specified cell.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @example
                 * activeSheet.setText(1, 0, "10");
                 */
                setText(row:  number,  col:  number,  value:  string,  sheetArea?:  GC.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the value for the specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {Object} value The value to set for the specified cell. if the value is rich text format, should include a richText field which type is a rich text style array.
                 * @param {GC.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @param {boolean} ignoreRecalc Whether to ignore recalculation.
                 * @example
                 * //This example uses the setValue method.
                 * sheet.setValue(0,2,"ColumnHeader", GC.Spread.Sheets.SheetArea.colHeader);
                 * sheet.setValue(2,0,{richText:[{style:{font:'bold 24px Arial'},text:'SpreadJS'}]}, GC.Spread.Sheets.SheetArea.rowHeader);
                 * sheet.setValue(1, 1, {richText:[{style:{vertAlign: GC.Spread.Sheets.VertAlign.subscript},text:'SpreadJS'}]}, GC.Spread.Sheets.SheetArea.viewport);
                 */
                setValue(row:  number,  col:  number,  value:  any,  sheetArea?:  GC.Spread.Sheets.SheetArea): void;
                /**
                 * Moves the view of a cell to the specified position in the viewport.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GC.Spread.Sheets.VerticalPosition} verticalPosition The vertical position in which to display the cell.
                 * @param {GC.Spread.Sheets.HorizontalPosition} horizontalPosition The horizontal position in which to display the cell.
                 * @example
                 * //This example uses the showCell method.
                 * //Set cell (3,3) as the active cell
                 * activeSheet.setActiveCell(3, 3);
                 * //Display the active cell at top left
                 * activeSheet.showCell(3, 3, GC.Spread.Sheets.VerticalPosition.top, GC.Spread.Sheets.HorizontalPosition.left);
                 */
                showCell(row:  number,  col:  number,  verticalPosition:  GC.Spread.Sheets.VerticalPosition,  horizontalPosition:  GC.Spread.Sheets.HorizontalPosition): void;
                /**
                 * Moves the view of a column to the specified position in the viewport.
                 * @param {number} col The column index.
                 * @param {GC.Spread.Sheets.HorizontalPosition} horizontalPosition The horizontal position in which to display the column.
                 * @example
                 * activeSheet.showColumn(9, GC.Spread.Sheets.HorizontalPosition.left);
                 */
                showColumn(col:  number,  horizontalPosition:  GC.Spread.Sheets.HorizontalPosition): void;
                /**
                 * Gets or sets whether the column outline (range group) is visible.
                 * @param {boolean} value Whether to display the column outline.
                 * @returns {boolean | GC.Spread.Sheets.Worksheet} If no value is set, returns a value that indicates whether the column outline is displayed on this sheet; otherwise, returns the worksheet.
                 * @example
                 * //This example uses the showColumnOutline method.
                 * activeSheet.showColumnOutline(false);
                 */
                showColumnOutline(value?:  boolean): any;
                /**
                 * Moves the view of a row to the specified position in the viewport.
                 * @param {number} row The row index.
                 * @param {GC.Spread.Sheets.VerticalPosition} verticalPosition The vertical position in which to display the row.
                 * @example
                 * activeSheet.showRow(9, GC.Spread.Sheets.VerticalPosition.top);
                 */
                showRow(row:  number,  verticalPosition:  GC.Spread.Sheets.VerticalPosition): void;
                /**
                 * Gets or sets whether the row outline (range group) is visible.
                 * @param {boolean} value Whether to display the row outline.
                 * @returns {boolean | GC.Spread.Sheets.Worksheet} If no value is set, returns a value that indicates whether the row outline is displayed on this sheet; otherwise, returns the worksheet.
                 * @example
                 * //This example uses the showRowOutline method.
                 * activeSheet.showRowOutline(false);
                 */
                showRowOutline(value?:  boolean): any;
                /**
                 * Sorts a range of cells in this sheet in the data model.
                 * @param {number} row The index of the starting row of the block of cells to sort.
                 * @param {number} column The index of the starting column of the block of cells to sort.
                 * @param {number} rowCount The number of rows in the block of cells.
                 * @param {number} columnCount The number of columns in the block of cells.
                 * @param {boolean} byRows Set to <c>true</c> to sort by rows, and <c>false</c> to sort by columns.
                 * @param {Object} sortInfo The SortInfo object with sort criteria and information about how to perform the sort. For example, [{index:0,ascending:true}]
                 * @returns {boolean} <c>true</c> if the data is sorted successfully; otherwise, <c>false</c>.
                 * @example
                 * //This example sorts a range.
                 * sheet.setValue(0,0,"112");
                 * sheet.setValue(1,0,"10");
                 * sheet.setValue(2,0,"223");
                 * sheet.setValue(3,0,"20");
                 * sheet.setValue(4,0,"334");
                 * sheet.setValue(5,0,"30");
                 * sheet.sortRange(0, 0, 6, 1, true, [
                 *                 {index:0, ascending:true}
                 *                 ]);
                 */
                sortRange(row:  number,  column:  number,  rowCount:  number,  columnCount:  number,  byRows:  boolean,  sortInfo:  Object): boolean;
                /**
                 * Starts to edit the cell.
                 * @param {boolean} selectAll Set to <c>true</c> to select all the text in the cell.
                 * @param {string} defaultText The default text to display while editing the cell.
                 * @example
                 * //This example uses the startEdit method.
                 * activeSheet.setActiveCell(5,5);
                 * activeSheet.startEdit(true, "Test");
                 */
                startEdit(selectAll?:  boolean,  defaultText?:  string): void;
                /**
                 * Suspends the calculation service.
                 * @param {boolean} ignoreDirty Specifies whether to invalidate the dependency cells.
                 * @example
                 * //This example uses the suspendCalcService method.
                 * activeSheet.suspendCalcService(false);
                 * activeSheet.setValue(0,0,1);
                 * activeSheet.setValue(0,1,2);
                 * activeSheet.setValue(0,2,10);
                 * activeSheet.getCell(1,1).formula("=SUM(A1:C1)");
                 * activeSheet.resumeCalcService(true);
                 */
                suspendCalcService(ignoreDirty?:  boolean): void;
                /**
                 * Suspends recording the dirty data.
                 * @example
                 * //This example uses the suspendDirty method.
                 *  var customers = [
                 *                { ID: 0, Name: 'A', Info1: 'Info0' },
                 *                { ID: 1, Name: 'B', Info1: 'Info1' },
                 *                { ID: 2, Name: 'C', Info1: 'Info2' },
                 *             ];
                 * activeSheet.setDataSource(customers);
                 * activeSheet.suspendDirty();
                 * alert(activeSheet.isDirtySuspended());
                 * activeSheet.resumeDirty();
                 * alert(activeSheet.isDirtySuspended());
                 */
                suspendDirty(): void;
                /**
                 * Suspends the event.
                 * @example
                 * //This example suspends and resumes the event.
                 * activeSheet.bind(GC.Spread.Sheets.Events.CellChanged, function (sender, args) {
                 *     if (args.propertyName === "value") {
                 *         alert(activeSheet.getValue(args.row, args.col));
                 *     }
                 * });
                 * activeSheet.suspendEvent();
                 * activeSheet.setValue(0, 0, "111");
                 * activeSheet.resumeEvent();
                 * activeSheet.setValue(1, 1, "222");
                 */
                suspendEvent(): void;
                /**
                 * Suspends the paint.
                 */
                suspendPaint(): void;
                /**
                 * Gets or sets the tag value for the current sheet.
                 * @param {Object} value The tag value to set for the current sheet.
                 * @returns {Object|GC.Spread.Sheets.Worksheet} If no value is set, returns the tag value of the current sheet; otherwise, returns the worksheet.
                 * @example
                 * //This example sets the sheet tag.
                 * activeSheet.tag("test");
                 * alert(activeSheet.tag());
                 */
                tag(value?:  any): any;
                /**
                 * Saves the object state to a JSON string.
                 * @param {Object} serializationOption Serialization option that contains the <i>includeBindingSource</i> argument. See the Remarks for more information.
                 * @returns {Object} The sheet data.
                 * @example
                 * //This example uses the toJSON method.
                 * activeSheet.getCell(0,0).value(123);
                 * var jsonStr = null;
                 * //export
                 * jsonStr = JSON.stringify(activeSheet.toJSON());
                 * //import
                 * activeSheet.fromJSON(JSON.parse(jsonStr));
                 * alert(jsonStr);
                 */
                toJSON(serializationOption?:  Object): Object;
                /**
                 * Removes the binding of an event to the sheet.
                 * @param {string} type The event type.
                 * @param {Function} fn Specifies the function for which to remove the binding.
                 * @example
                 * //This example unbinds the event after setting the first value.
                 * activeSheet.bind(GC.Spread.Sheets.Events.CellChanged, function (sender, args) {
                 *     if (args.propertyName === "value") {
                 *         alert(activeSheet.getValue(args.row, args.col));
                 *     }
                 * });
                 * activeSheet.setValue(0, 0, "111");
                 * activeSheet.unbind(GC.Spread.Sheets.Events.CellChanged);
                 * activeSheet.setValue(1, 0, "222");
                 * activeSheet.setValue(2, 0, "333");
                 * activeSheet.setValue(3, 0, "444");
                 */
                unbind(type:  any,  fn?:  any): void;
                /**
                 * Removes the binding of all events to the sheet.
                 * @example
                 * //This example cancels monitoring of all events.
                 * activeSheet.bind(GC.Spread.Sheets.Events.CellChanged, function (sender, args) {
                 *     if (args.propertyName === "value") {
                 *         alert(activeSheet.getValue(args.row, args.col));
                 *     }
                 * });
                 * activeSheet.setValue(0, 0, "111");
                 * activeSheet.unbindAll(); //cancel monitoring of all events.
                 * activeSheet.setValue(1, 0, "222");
                 * activeSheet.setValue(2, 0, "333");
                 * activeSheet.setValue(3, 0, "444");
                 */
                unbindAll(): void;
                /**
                 * Ungroups the sparklines in the specified group.
                 * @param {GC.Spread.Sheets.Sparklines.SparklineGroup} group The sparkline group.
                 * @example
                 * //This example uses the ungroupSparkline method.
                 * activeSheet.setValue(0, 0, "Data Range is A2-A9");
                 * activeSheet.setValue(1, 0, 1);
                 * activeSheet.setValue(2, 0, -2);
                 * activeSheet.setValue(3, 0, -1);
                 * activeSheet.setValue(4, 0, 6);
                 * activeSheet.setValue(5, 0, 4);
                 * activeSheet.setValue(6, 0, -4);
                 * activeSheet.setValue(7, 0, 3);
                 * activeSheet.setValue(8, 0, 8);
                 * var data = new GC.Spread.Sheets.Range(1, 0, 8, 1);
                 * var setting = new GC.Spread.Sheets.Sparklines.SparklineSetting();
                 * var s1=  activeSheet.setSparkline(11, 0, data, GC.Spread.Sheets.Sparklines.DataOrientation.Vertical, GC.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 * var s2 =activeSheet.setSparkline(11, 3, data, GC.Spread.Sheets.Sparklines.DataOrientation.Vertical, GC.Spread.Sheets.Sparklines.SparklineType.column, setting);
                 * var s3=  activeSheet.setSparkline(11, 6, data, GC.Spread.Sheets.Sparklines.DataOrientation.Vertical, GC.Spread.Sheets.Sparklines.SparklineType.winloss, setting);
                 * var group = activeSheet.groupSparkline([s1,s2,s3]);
                 * //activeSheet.ungroupSparkline(group);
                 */
                ungroupSparkline(group:  GC.Spread.Sheets.Sparklines.SparklineGroup): void;
                /**
                 * Sets whether the worksheet is displayed.
                 * @param {boolean} value Whether the worksheet is displayed.
                 * @returns {Object} If you call this function without a parameter, it returns a boolean indicating whether the sheet is visible;
                 * otherwise, it returns the current worksheet object.
                 * @example
                 * activeSheet.visible(false);
                 */
                visible(value?:  boolean): any;
                /**
                 * Gets or sets the zoom factor for the sheet.
                 * @param {number} factor The zoom factor.
                 * @returns {number|GC.Spread.Sheets.Worksheet} If no value is set, returns the zoom factor; otherwise, returns the worksheet.
                 * @example
                 * //This example zooms the sheet.
                 * spread.options.allowUserZoom = false;
                 * sheet.zoom(3);
                 */
                zoom(factor?:  number): any;
            }
            module Barcode{

                export class Codabar extends GC.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the Codabar.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class Code128 extends GC.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the Code128.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class Code39 extends GC.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the Code39.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class Code49 extends GC.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the Code49.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class Code93 extends GC.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the Code93.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class DataMatrix extends GC.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the DataMatrix.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class EAN13 extends GC.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the EAN13.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class EAN8 extends GC.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the EAN8.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class GS1_128 extends GC.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the GS1_128.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class PDF417 extends GC.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the PDF417.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class QRCode extends GC.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the QRCode.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }
            }

            module Bindings{

                export class CellBindingSource{
                    /**
                     * Represents a source for cell binding.
                     * @param {Object} source The data source.
                     * @class
                     * @example
                     * var person = {name: "Wang feng", age: 25, address: {postcode: "710075"}};
                     * var source = new GC.Spread.Sheets.Bindings.CellBindingSource(person);
                     * activeSheet.setBindingPath(0, 0, "name");
                     * activeSheet.setBindingPath(1, 1, "age");
                     * activeSheet.setBindingPath(3, 3, "address.postcode");
                     * activeSheet.setDataSource(source);
                     */
                    constructor(source:  Object);
                    /**
                     * Gets the wrapped data source for cell binding.
                     * @returns {Object} The original data source.
                     * @example
                     * //This example gets the name.
                     * var person = { name: "Wang feng", age: 25, address: { postcode: "710075" } };
                     * var source = new GC.Spread.Sheets.Bindings.CellBindingSource(person);
                     * activeSheet.setBindingPath(0, 0, "name");
                     * activeSheet.setBindingPath(1, 1, "age");
                     * activeSheet.setBindingPath(3, 3, "address.postcode");
                     * activeSheet.setDataSource(source);
                     * alert(source.getSource().name);
                     */
                    getSource(): Object;
                    /**
                     * Gets the value of the source by the binding path.
                     * @param {string} path The binding path.
                     * @returns {Object} Returns the value of the binding source at the specified path.
                     * @example
                     * //This example gets the value.
                     * var person = {name: "Wang feng", age: 25, address: {postcode: "710075"}};
                     * var source = new GC.Spread.Sheets.Bindings.CellBindingSource(person);
                     * activeSheet.setBindingPath(0, 0, "name");
                     * activeSheet.setBindingPath(1, 1, "age");
                     * activeSheet.setBindingPath(3, 3, "address.postcode");
                     * activeSheet.setDataSource(source);
                     * alert(source.getValue("name"));
                     */
                    getValue(path:  string): Object;
                    /**
                     * Sets the value of the source by the binding path.
                     * @param {string} path The row index.
                     * @param {Object} value The value to set.
                     * @example
                     * //This example sets the name value.
                     * var person = {name: "Wang feng", age: 25, address: {postcode: "710075"}};
                     * var source = new GC.Spread.Sheets.Bindings.CellBindingSource(person);
                     * activeSheet.setBindingPath(0, 0, "name");
                     * activeSheet.setBindingPath(1, 1, "age");
                     * activeSheet.setBindingPath(3, 3, "address.postcode");
                     * activeSheet.setDataSource(source);
                     * source.setValue("name", "test");
                     * activeSheet.resumePaint();
                     * activeSheet.repaint();
                     */
                    setValue(path:  string,  value:  Object): void;
                }
            }

            module CalcEngine{
                /**
                 * Evaluates the specified formula.
                 * @param {object} context The evaluation context; in general, you should use the active sheet object.
                 * @param {string} formula The formula string.
                 * @param {number} baseRow The base row index of the formula.
                 * @param {number} baseColumn The base column index of the formula.
                 * @param {boolean} useR1C1 Whether to use the r1c1 reference style.
                 * @returns {object} The evaluated formula result.
                 * @example
                 * var spread = new GC.Spread.Sheets.Workbook(document.getElementById('ss'), { sheetCount: 1 });
                 * sheet = spread.getSheet(0);
                 * sheet.setValue(0, 0, 1);
                 * sheet.setValue(1, 0, 2);
                 * // Using EvaluateFormula() method to evaluate formula without setting formula in sheet's cell
                 * var result = GC.Spread.Sheets.CalcEngine.evaluateFormula(sheet, "SUM(A1:A2)", 0, 0);
                 * console.log("SUM(A1:A2) = " + result);
                 */
                function evaluateFormula(context:  Object,  formula:  string,  baseRow?:  number,  baseColumn?:  number,  useR1C1?:  boolean): any;
                /**
                 * Unparse the specified expression tree to formula string.
                 * @param {object} context The context; in general, you should use the active sheet object.
                 * @param {GC.Spread.CalcEngine.Expression} expression The expression tree.
                 * @param {number} baseRow The base row index of the formula.
                 * @param {number} baseColumn The base column index of the formula.
                 * @param {boolean} useR1C1 Whether to use the r1c1 reference style.
                 * @returns {string} The formula string.
                 * @example
                 * var spread = new GC.Spread.Sheets.Workbook(document.getElementById('ss'), { sheetCount: 1 });
                 * sheet = spread.getSheet(0);
                 * sheet.setValue(0, 0, 1);
                 * sheet.setValue(0, 1, 2);
                 * sheet.setValue(0, 2, 3);
                 * sheet.addCustomName("customName1", "=12", 0, 0);
                 * sheet.addCustomName("customName2", "Average(20,45)", 0, 0);
                 * sheet.addCustomName("customName3", "=$A$1:$C$1");
                 * sheet.setFormula(1, 0, "customName1");
                 * sheet.setFormula(1, 1, "customName2");
                 * sheet.setFormula(1, 2, "sum(customName3)");
                 * var cname = sheet.getCustomName("customName2");
                 * if (cname instanceof GC.Spread.Sheets.NameInfo) {
                 *     // Get CustomName
                 *     var name = cname.getName();
                 *     // Get Expression
                 *     var expression = cname.getExpression();
                 *     // Get Expression String
                 *     var expStr = GC.Spread.Sheets.CalcEngine.expressionToFormula(sheet, expression, 0, 0);
                 *     console.log("Name: " + name + " ; Expression: " + expStr);
                 * }
                 */
                function expressionToFormula(context:  Object,  expression:  GC.Spread.CalcEngine.Expression,  baseRow?:  number,  baseColumn?:  number,  useR1C1?:  boolean): string;
                /**
                 * Parse the specified formula to expression tree.
                 * @param {object} context The context; in general, you should use the active sheet object.
                 * @param {string} formula The formula string.
                 * @param {number} baseRow The base row index of the formula.
                 * @param {number} baseColumn The base column index of the formula.
                 * @param {boolean} useR1C1 Whether to use the r1c1 reference style.
                 * @returns {GC.Spread.CalcEngine.Expression} The expression tree.
                 * @example
                 * var spread = new GC.Spread.Sheets.Workbook(document.getElementById('ss'), { sheetCount: 1 });
                 * sheet = spread.getSheet(0);
                 * sheet.setValue(0, 0, 1);
                 * sheet.setValue(0, 1, 2);
                 * sheet.setValue(0, 2, 3);
                 * sheet.getCell(4, 4).formula("=SUM(A1:C1)");
                 * var formula = sheet.getFormula(4, 4);
                 * var expression = GC.Spread.Sheets.CalcEngine.formulaToExpression(sheet, formula, 0, 0);
                 * console.log("Function Name is: " + expression.functionName);
                 */
                function formulaToExpression(context:  Object,  formula:  string,  baseRow?:  number,  baseColumn?:  number,  useR1C1?:  boolean): GC.Spread.CalcEngine.Expression;
                /**
                 * Converts a formula string to the specified cell ranges.
                 * @param {GC.Spread.Sheets.Worksheet} sheet The base sheet.
                 * @param {string} formula The formula.
                 * @param {number} baseRow The base row index of the formula.
                 * @param {number} baseCol The base column index of the formula.
                 * @returns {Array} The cell ranges that refers to the formula string.
                 * @example
                 * var spread = new GC.Spread.Sheets.Workbook(document.getElementById('ss'), { sheetCount: 1 });
                 * sheet = spread.getSheet(0);
                 * // Creating cell range using formulaToRanges() method
                 * cellRanges = GC.Spread.Sheets.CalcEngine.formulaToRanges(sheet, 'B3:D5', 0, 0);
                 * // Getting row/ col indexes and rowCount/ colCount of range in formula
                 * console.log("Starting Row Index of cell range 'B3:D5' is " + cellRanges[0].ranges[0].row);
                 * console.log("Starting Column Index of cell range 'B3:D5' is " + cellRanges[0].ranges[0].col);
                 * console.log("RowCount of cell range 'B3:D5' is " + cellRanges[0].ranges[0].rowCount);
                 * console.log("ColCount of cell range 'B3:D5' is " + cellRanges[0].ranges[0].colCount);
                 */
                function formulaToRanges(sheet: any,  formula: any,  baseRow?:  number,  baseCol?:  number): Object[];
                /**
                 * Attempts to find a value for one cell that produces the desired formula result in another cell.
                 * @param {GC.Spread.Sheets.Worksheet} changingSheet The sheet that contains the cell that you want to adjust.
                 * @param {number} changingRow The row index of the cell that contains the value that you want to adjust.
                 * @param {number} changingColumn The column index of the cell that contains the value that you want to adjust.
                 * @param {GC.Spread.Sheets.Worksheet} formulaSheet The sheet that contains the formula that you want to resolve.
                 * @param {number} formulaRow The row index of the cell that contains the formula that you want to resolve.
                 * @param {number} formulaColumn The column index of the cell that contains the formula that you want to resolve.
                 * @param {number} desiredResult The formula result that you want.
                 * @example
                 * // This sample shows how to use the goal seek.
                 * // Loan amount is 10000, term is 18 months and pay 600 each month, evaluate what interest rate you will need to secure in order to meet your loan goal.
                 * sheet.setValue(0, 1, 10000); // Loan Amount
                 * sheet.setValue(1, 1, 18); // Term in Months
                 * sheet.setFormatter(2, 1, "0%"); // Interest Rate
                 * sheet.setFormatter(3, 1, "0.00");
                 * sheet.setFormula(3, 1, "PMT(B3/12,B2,B1)"); // Payment
                 * GC.Spread.Sheets.CalcEngine.goalSeek(sheet, 2, 1, sheet, 3, 1, -600); // result in B3 is 10%
                 */
                function goalSeek(changingSheet:  Worksheet,  changingRow:  number,  changingColumn:  number,  formulaSheet:  Worksheet,  formulaRow:  number,  formulaColumn:  number,  desiredResult:  number): void;
                /**
                 * Converts the specified cell range to a formula string.
                 * @param {Array.<GC.Spread.Sheets.Range>} ranges The cell range in the sheet.
                 * @param {number} [baseRow] Optinal. The base row index of the formula.
                 * @param {number} [baseCol] The base column index of the formula.
                 * @param {GC.Spread.CalcEngine.RangeReferenceRelative} [rangeReferenceRelative] Optinal.Whether the range reference is relative or absolute.
                 * @param {boolean} [useR1C1] Optinal.Whether to use the r1c1 reference style.
                 * @returns {string} The formula string that refers to the specified cell range.
                 * @example
                 * spread = new GC.Spread.Sheets.Workbook(document.getElementById('ss'), { sheetCount: 1 });
                 * sheet = spread.getSheet(0);
                 * // Setting Value
                 * sheet.setValue(0, 0, 1, 3);
                 * sheet.setValue(1, 0, 50, 3);
                 * sheet.setValue(2, 0, 100, 3);
                 * sheet.setValue(3, 0, 2, 3);
                 * sheet.setValue(4, 0, 60, 3);
                 * sheet.setValue(5, 0, 90, 3);
                 * sheet.setValue(6, 0, 3, 3);
                 * sheet.setValue(7, 0, 40, 3);
                 * sheet.clearSelection();
                 * // Adding selections
                 * sheet.addSelection(0, 0, 3, 1);
                 * sheet.addSelection(5, 0, 2, 1);
                 * var ranges = sheet.getSelections();
                 * // getting range string
                 * var rangesStr = GC.Spread.Sheets.CalcEngine.rangesToFormula(ranges);
                 * // creating formula using selected ranges
                 * var formula = "Sum(" + rangesStr + ")";
                 * // setting formula in Sheet's cell
                 * sheet.setFormula(5, 5, formula, GC.Spread.Sheets.SheetArea.viewport);
                 */
                function rangesToFormula(ranges:  Range[],  baseRow?:  number,  baseCol?:  number,  rangeReferenceRelative?:  RangeReferenceRelative,  useR1C1?:  boolean): string;
                /**
                 * Converts the specified cell range to a formula string.
                 * @param {GC.Spread.Sheets.Range} range The cell range in the sheet.
                 * @param {number} [baseRow] Optinal.The base row index of the formula.
                 * @param {number} [baseCol] Optinal.The base column index of the formula.
                 * @param {GC.Spread.CalcEngine.RangeReferenceRelative} [rangeReferenceRelative] Optinal.Whether the range reference is relative or absolute.
                 * @param {boolean} [useR1C1] Optinal.Whether to use the r1c1 reference style.
                 * @returns {string} The formula string that refers to the specified cell range.
                 * @example
                 * var spread = new GC.Spread.Sheets.Workbook(document.getElementById('ss'), { sheetCount: 1 });
                 * sheet = spread.getSheet(0);
                 * // setting value
                 * sheet.setValue(0, 0, 1, 3);
                 * sheet.setValue(1, 0, 50, 3);
                 * sheet.setValue(2, 0, 100, 3);
                 * sheet.setValue(3, 0, 2, 3);
                 * sheet.setValue(4, 0, 60, 3);
                 * sheet.setValue(5, 0, 90, 3);
                 * sheet.clearSelection();
                 * // adding selection
                 * sheet.addSelection(2, 0, 3, 1);
                 * var range = sheet.getSelections();
                 * // Getting range string
                 * var rangeStr = GC.Spread.Sheets.CalcEngine.rangeToFormula(range[0]);
                 * // creating formula using selected range
                 * var formula = "Sum(" + rangeStr + ")";
                 * // setting formula in Sheet's cell
                 * sheet.setFormula(5, 5, formula, GC.Spread.Sheets.SheetArea.viewport);
                 */
                function rangeToFormula(range:  Range,  baseRow?:  number,  baseCol?:  number,  rangeReferenceRelative?:  RangeReferenceRelative,  useR1C1?:  boolean): string;
                /**
                 * Specifies whether the range reference is relative or absolute.
                 * @enum {number}
                 */
                export enum RangeReferenceRelative{
                    /**
                     * Specifies all reference is absolute
                     */
                    allAbsolute= 0,
                    /**
                     * Specifies start row is relative
                     */
                    startRowRelative= 1,
                    /**
                     * Specifies start column is relative
                     */
                    startColRelative= 2,
                    /**
                     * Specifies end row is relative
                     */
                    endRowRelative= 4,
                    /**
                     * Specifies end column is relative
                     */
                    endColRelative= 8,
                    /**
                     * Specifies row is relative
                     */
                    rowRelative= 5,
                    /**
                     * Specifies column is relative
                     */
                    colRelative= 10,
                    /**
                     * Specifies all reference is relative
                     */
                    allRelative= 15
                }

            }

            module CellTypes{
                /**
                 * Specifies the text alignment for check box cells.
                 * @enum {number}
                 * @example
                 * //This example creates a check box cell.
                 * var cellType1 = new GC.Spread.Sheets.CellTypes.CheckBox();
                 * cellType1.caption("caption");
                 * cellType1.textTrue("true");
                 * cellType1.textFalse("false");
                 * cellType1.textIndeterminate("indeterminate");
                 * cellType1.textAlign(GC.Spread.Sheets.CellTypes.CheckBoxTextAlign.bottom);
                 * cellType1.isThreeState(true);
                 * activeSheet.getCell(1, 1).cellType(cellType1);
                 */
                export enum CheckBoxTextAlign{
                    /**
                     * Specifies text is on top of the check box.
                     */
                    top= 0,
                    /**
                     * Specifies text is below the check box.
                     */
                    bottom= 1,
                    /**
                     * Specifies text is to the left of the check box.
                     */
                    left= 2,
                    /**
                     * Specifies text is to the right of the check box.
                     */
                    right= 3
                }

                /**
                 * Represents the editor type of text cell type.
                 * @enum {number}
                 * @example
                 * //This example shows how to change the editor of text cell type to textarea.
                 * var tempStyle = new GC.Spread.Sheets.Style();
                 * tempStyle.cellType = new GC.Spread.Sheets.CellTypes.Text(GC.Spread.Sheets.CellTypes.EditorType.textarea);
                 * activeSheet.setDefaultStyle(tempStyle);
                 */
                export enum EditorType{
                    /**
                     *  Use textarea element as the editor of text cell type.
                     */
                    textarea= 0,
                    /**
                     *  Use editorable div element as the editor of text cell type.
                     */
                    editableDiv= 1
                }

                /**
                 *  Specifies what is written out to the data model for a selected item from
                 *  certain cell types that offer a selection of multiple values.
                 * @readonly
                 * @enum {number}
                 * @example
                 * //This example uses the EditorValueType enumeration.
                 * var cellType2 = new GC.Spread.Sheets.CellTypes.ComboBox();
                 * cellType2.items(["a","b","c"]);
                 * cellType2.editorValueType(GC.Spread.Sheets.CellTypes.EditorValueType.text);
                 * activeSheet.getCell(2, 2).cellType(cellType2);
                 */
                export enum EditorValueType{
                    /**
                     *  Writes the text value of the selected item to the model.
                     */
                    text= 0,
                    /**
                     * Writes the index of the selected item to the model.
                     */
                    index= 1,
                    /**
                     *  Writes the corresponding data value of the selected item to the model.
                     */
                    value= 2
                }

                /**
                 * Specifies the hyperlink's target type.
                 * @enum {number}
                 * @example
                 * //This example creates a hyperlink cell.
                 * var cellType = new GC.Spread.Sheets.CellTypes.HyperLink();
                 * cellType.linkColor("blue");
                 * cellType.visitedLinkColor("#FFFF00");
                 * cellType.text("GrapeCity");
                 * cellType.linkToolTip("Company Web Site");
                 * cellType.target(GC.Spread.Sheets.CellTypes.HyperLinkTargetType.self);
                 * activeSheet.getCell(0, 2).cellType(cellType).value("http://www.grapecity.com/");
                 */
                export enum HyperLinkTargetType{
                    /**
                     * Opens the hyperlinked document in a new window or tab.
                     */
                    blank= 0,
                    /**
                     * Opens the hyperlinked document in the same frame where the user clicked.
                     */
                    self= 1,
                    /**
                     * Opens the hyperlinked document in the parent frame.
                     */
                    parent= 2,
                    /**
                     * Opens the hyperlinked document in the full body of the window.
                     */
                    top= 3
                }


                export class Base{
                    /**
                     * Represents the base class for the other cell type classes.
                     * @class
                     */
                    constructor();
                    /**
                     * Represents the type name string used for supporting serialization.
                     * @type {string}
                     */
                    typeName: string;
                    /**
                     * Activates the editor, including setting properties or attributes for the editor and binding events for the editor.
                     * @param {object} editorContext The DOM element that was created by the createEditorElement method.
                     * @param {GC.Spread.Sheets.Style} cellStyle The cell's actual style.
                     * @param {GC.Spread.Sheets.Rect} cellRect The cell's layout information.
                     * @param {object} context The context associated with the cell type. See the Remarks for more information.
                     */
                    activateEditor(editorContext:  any,  cellStyle:  GC.Spread.Sheets.Style,  cellRect:  GC.Spread.Sheets.Rect,  context?:  any): void;
                    /**
                     * Creates a DOM element then returns it.
                     * @param {object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {object} Returns a DOM element.
                     */
                    createEditorElement(context?:  any): any;
                    /**
                     * Deactivates the editor, such as unbinding events for editor.
                     * @param {object} editorContext The DOM element that was created by the createEditorElement method.
                     * @param {object} context The context associated with the cell type. See the Remarks for more information.
                     */
                    deactivateEditor(editorContext:  any,  context?:  any): void;
                    /**
                     * Focuses the editor DOM element.
                     * @param {object} editorContext The DOM element that was created by the createEditorElement method.
                     * @param {object} context The context associated with the cell type. See the Remarks for more information.
                     */
                    focus(editorContext:  any,  context?:  any): void;
                    /**
                     * Formats a value with the specified format to a string.
                     * @param {Object} value The object value to format.
                     * @param {GC.Spread.Formatter.GeneralFormatter} format The format.
                     * @param {Object} formattedData the formatted data.
                     * @param {Array} [formattedData.content] - The formatted data array, each item is an object that has two properties type and value, And it may contain these types: 'number', 'text', 'fillingChar', 'placeholder', 'exponent', 'decimalSeparator', 'groupSeparator', 'numberPlaceholder', 'percent', 'permille' and 'currency'. For example: {type: 'number', value: '123'}.
                     * @param {string} [formattedData.conditionalForeColor] - The conditional foreground color.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {string} Returns the formatted string.
                     */
                    format(value:  any,  format:  any,  formattedData?:  any,  context?:  any): string;
                    /**
                     * Loads the object state from the specified JSON string.
                     * @param {Object} settings The cell type data from deserialization.
                     */
                    fromJSON(settings:  Object): void;
                    /**
                     * Gets a cell's height that can be used to handle the row's automatic fit.
                     * @param {object} value The cell's value.
                     * @param {string} text The cell's text.
                     * @param {GC.Spread.Sheets.Style} cellStyle The cell's actual value.
                     * @param {number} zoomFactor The current sheet's zoom factor.
                     * @param {object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {number} Returns the cell's height that can be used to handle the row's automatic fit.
                     */
                    getAutoFitHeight(value:  any,  text:  string,  cellStyle:  GC.Spread.Sheets.Style,  zoomFactor:  number,  context?:  any): number;
                    /**
                     * Gets a cell's width that can be used to handle the column's automatic fit.
                     * @param {object} value The cell's value.
                     * @param {string} text The cell's text.
                     * @param {GC.Spread.Sheets.Style} cellStyle The cell's actual value.
                     * @param {number} zoomFactor The current sheet's zoom factor.
                     * @param {object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {number} Returns the cell's width that can be used to handle the column's automatic fit.
                     */
                    getAutoFitWidth(value:  any,  text:  string,  cellStyle:  GC.Spread.Sheets.Style,  zoomFactor:  number,  context?:  any): number;
                    /**
                     * Gets the editor's value.
                     * @param {object} editorContext The DOM element that was created by the createEditorElement method.
                     * @param {object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {object} Returns the editor's value.
                     */
                    getEditorValue(editorContext:  any,  context?:  any): any;
                    /**
                     * Gets the cell type's hit information.
                     * @param {number} x <i>x</i>-coordinate of pointer's current location relative to the canvas.
                     * @param {number} y <i>y</i>-coordinate of pointer's current location relative to the canvas.
                     * @param {GC.Spread.Sheets.Style} cellStyle The current cell's actual style.
                     * @param {GC.Spread.Sheets.Rect} cellRect The current cell's layout information.
                     * @param {object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {object} Returns an object that contains the <i>x</i>, <i>y</i>, <i>row</i>, <i>col</i>, <i>cellRect</i>, and <i>sheetArea</i> parameters, and a value to indicate <i>isReservedLocation</i>.
                     * <i>isReservedLocation</i> is <c>true</c> if the hit test is in a special area that the cell type needs to handle; otherwise, <c>false</c>.
                     */
                    getHitInfo(x:  number,  y:  number,  cellStyle:  GC.Spread.Sheets.Style,  cellRect:  GC.Spread.Sheets.Rect,  context?:  any): GC.Spread.Sheets.IHitTestCellTypeHitInfo;
                    /**
                     * Whether the editing value has changed.
                     * @param {object} oldValue Old editing value.
                     * @param {object} newValue New editing value.
                     * @param {object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {boolean} <c>true</c> if oldValue equals newValue; otherwise, <c>false</c>.
                     */
                    isEditingValueChanged(oldValue:  any,  newValue:  any,  context?:  any): boolean;
                    /**
                     * Whether this cell type is aware of IME.
                     * @param {object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {boolean} <c>true</c> if the cell type is aware of IME; otherwise, <c>false</c>.
                     */
                    isImeAware(context?:  any): boolean;
                    /**
                     * Whether the cell type handles the keyboard event itself.
                     * @param {KeyboardEvent} e The KeyboardEvent.
                     * @param {object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {boolean} Returns <c>true</c> if the cell type handles the keyboard event itself; otherwise, <c>false</c>.
                     */
                    isReservedKey(e:  any,  context?:  any): boolean;
                    /**
                     * Paints a cell on the canvas.
                     * @param {CanvasRenderingContext2D} ctx The canvas's two-dimensional context.
                     * @param {object} value The cell's value.
                     * @param {number} x <i>x</i>-coordinate relative to the canvas.
                     * @param {number} y <i>y</i>-coordinate relative to the canvas.
                     * @param {number} w The cell's width.
                     * @param {number} h The cell's height.
                     * @param {GC.Spread.Sheets.Style} style The cell's actual style.
                     * @param {object} context The context associated with the cell type. See the Remarks for more information.
                     */
                    paint(ctx:  CanvasRenderingContext2D,  value:  any,  x:  number,  y:  number,  w:  number,  h:  number,  style:  GC.Spread.Sheets.Style,  context?:  any): void;
                    /**
                     * Paints the cell content area on the canvas.
                     * @param {CanvasRenderingContext2D} ctx The canvas's two-dimensional context.
                     * @param {object} value The cell's value.
                     * @param {number} x <i>x</i>-coordinate relative to the canvas.
                     * @param {number} y <i>y</i>-coordinate relative to the canvas.
                     * @param {number} w The cell content area's width.
                     * @param {number} h The cell content area's height.
                     * @param {GC.Spread.Sheets.Style} style The cell's actual style.
                     * @param {object} context The context associated with the cell type. See the Remarks for more information.
                     */
                    paintContent(ctx:  CanvasRenderingContext2D,  value:  any,  x:  number,  y:  number,  w:  number,  h:  number,  style:  GC.Spread.Sheets.Style,  context?:  any): void;
                    /**
                     * Parses the text with the specified format string to an object.
                     * @param {string} text The parse text string.
                     * @param {object} formatStr The parse format string.
                     * @param {object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {object} The parsed object.
                     */
                    parse(text:  string,  formatStr:  string,  context?:  any): any;
                    /**
                     * Processes key down in display mode.
                     * @param {KeyboardEvent} event The KeyboardEvent.
                     * @param {object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {boolean} Returns <c>true</c> if the process is successful; otherwise, <c>false</c>.
                     */
                    processKeyDown(event:  KeyboardEvent,  context?:  any): boolean;
                    /**
                     * Processes key up in display mode.
                     * @param {KeyboardEvent} event The KeyboardEvent.
                     * @param {object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {boolean} Returns <c>true</c> if the process is successful; otherwise, <c>false</c>.
                     */
                    processKeyUp(event:  KeyboardEvent,  context?:  any): boolean;
                    /**
                     * Processes mouse down in display mode.
                     * @param {object} hitInfo The hit test information returned by the getHitInfo method. See the Remarks for more information.
                     * @returns {boolean} Returns <c>true</c> if the process is successful; otherwise, <c>false</c>.
                     */
                    processMouseDown(hitInfo:  GC.Spread.Sheets.IHitTestCellTypeHitInfo): boolean;
                    /**
                     * Processes mouse enter in display mode.
                     * @param {object} hitInfo The hit test information returned by the getHitInfo method. See the Remarks for more information.
                     * @returns {boolean} Returns <c>true</c> if the process is successful; otherwise, <c>false</c>.
                     */
                    processMouseEnter(hitInfo:  GC.Spread.Sheets.IHitTestCellTypeHitInfo): boolean;
                    /**
                     * Processes mouse leave in display mode.
                     * @param {object} hitInfo The hit test information returned by the getHitInfo method. See the Remarks for more information.
                     * @returns {boolean} Returns <c>true</c> if the process is successful; otherwise, <c>false</c>.
                     */
                    processMouseLeave(hitInfo:  GC.Spread.Sheets.IHitTestCellTypeHitInfo): boolean;
                    /**
                     * Processes mouse move in display mode.
                     * @param {object} hitInfo The hit test information returned by the getHitInfo method. See the Remarks for more information.
                     * @returns {boolean} Returns <c>true</c> if the process is successful; otherwise, <c>false</c>.
                     */
                    processMouseMove(hitInfo:  GC.Spread.Sheets.IHitTestCellTypeHitInfo): boolean;
                    /**
                     * Processes mouse up in display mode.
                     * @param {object} hitInfo The hit test information returned by the getHitInfo method. See the Remarks for more information.
                     * @returns {boolean} Returns <c>true</c> if the process is successful; otherwise, <c>false</c>.
                     */
                    processMouseUp(hitInfo:  GC.Spread.Sheets.IHitTestCellTypeHitInfo): boolean;
                    /**
                     * Selects all the text in the editor DOM element.
                     * @param {object} editorContext The DOM element that was created by the createEditorElement method.
                     * @param {object} context The context associated with the cell type. See the Remarks for more information.
                     */
                    selectAll(editorContext:  any,  context?:  any): void;
                    /**
                     * Sets the editor's value.
                     * @param {object} editorContext The DOM element that was created by the createEditorElement method.
                     * @param {object} value The value returned from the active cell.
                     * @param {object} context The context associated with the cell type. See the Remarks for more information.
                     */
                    setEditorValue(editorContext:  any,  value:  any,  context?:  any): void;
                    /**
                     * Saves the object state to a JSON string.
                     * @returns {Object} The cell type data.
                     */
                    toJSON(): Object;
                    /**
                     * Updates the editor's size.
                     * @param {object} editorContext The DOM element that was created by the createEditorElement method.
                     * @param {GC.Spread.Sheets.Style} cellStyle The cell's actual style.
                     * @param {GC.Spread.Sheets.Rect} cellRect The cell's layout information.
                     * @param {object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {object} Returns the new size for cell wrapper element, it should contain two properties 'width' and 'height'.
                     */
                    updateEditor(editorContext:  any,  cellStyle:  GC.Spread.Sheets.Style,  cellRect:  GC.Spread.Sheets.Rect,  context?:  any): any;
                    /**
                     * Updates the cell wrapper element size.
                     * @param {object} editorContext The DOM element that was created by the createEditorElement method.
                     * @param {object} editorBounds The cell wrapper element's new size.
                     * @param {number} editorBounds.x - The cell wrapper element's x position.
                     * @param {number} editorBounds.y - The cell wrapper element's y position.
                     * @param {number} editorBounds.width - The cell wrapper element's new width value.
                     * @param {number} editorBounds.height - The cell wrapper element's new height value.
                     * @param {GC.Spread.Sheets.Style} cellStyle The cell's actual style.
                     */
                    updateEditorContainer(editorContext:  any,  editorBounds:  Object,  cellStyle:  GC.Spread.Sheets.Style): void;
                    /**
                     * Updates the editor's ime-mode.
                     * @param {object} editorContext The DOM element that was created by the createEditorElement method.
                     * @param {GC.Spread.Sheets.ImeMode} imeMode The ime-mode from cell's actual style.
                     * @param {object} context The context associated with the cell type. See the Remarks for more information.
                     */
                    updateImeMode(editorContext:  any,  imeMode:  GC.Spread.Sheets.ImeMode,  context?:  any): void;
                }

                export class Button extends Base{
                    /**
                     * Represents a button cell.
                     * @extends GC.Spread.Sheets.CellTypes.Base
                     * @class
                     * @example
                     * //This example creates a button cell.
                     * var spread = new GC.Spread.Sheets.Workbook();
                     * var sheet = spread.getActiveSheet();
                     * var cellType = new GC.Spread.Sheets.CellTypes.Button();
                     * cellType.buttonBackColor("#FFFF00");
                     * cellType.text("this is a button");
                     * sheet.setCellType(1,1,cellType);
                     * //Bind event
                     * spread.bind(GC.Spread.Sheets.Events.ButtonClicked, function (e, args) {
                     *     var sheet = args.sheet, row = args.row, col = args.col;
                     *     var cellType = sheet.getCellType(row, col);
                     *     if (cellType instanceof GC.Spread.Sheets.CellTypes.Button) {
                     *         alert("Button Clicked");
                     *     }
                     * });
                     */
                    constructor();
                    /**
                     * Gets or sets the button's background color.
                     * @param {string} value The button's background color.
                     * @returns {string | GC.Spread.Sheets.CellTypes.Button} If no value is set, returns the background color; otherwise, returns the button cell type.
                     * @example
                     * //This example creates a button cell.
                     * var cellType = new GC.Spread.Sheets.CellTypes.Button();
                     * cellType.buttonBackColor("#FFFF00");
                     * cellType.text("this is a button");
                     * activeSheet.getCell(0, 2).cellType(cellType);
                     */
                    buttonBackColor(value?:  string): any;
                    /**
                     * Gets or sets the button's bottom margin in pixels relative to the cell.
                     * @param {number} value The button's bottom margin relative to the cell.
                     * @returns {number | GC.Spread.Sheets.CellTypes.Button} If no value is set, returns the bottom margin in pixels; otherwise, returns the button cell type.
                     * @example
                     * //This example creates a button cell and sets its margins.
                     * var cellType = new GC.Spread.Sheets.CellTypes.Button();
                     * cellType.buttonBackColor("#FFFF00");
                     * cellType.text("this is a button");
                     * cellType.marginTop(5).marginRight(8).marginBottom(10).marginLeft(12);
                     * activeSheet.getCell(0, 2).cellType(cellType);
                     * activeSheet.setColumnWidth(2, 120.0,GC.Spread.Sheets.SheetArea.viewport);
                     * activeSheet.setRowHeight(0, 90.0,GC.Spread.Sheets.SheetArea.viewport);
                     */
                    marginBottom(value?:  number): any;
                    /**
                     * Gets or sets the button's left margin in pixels relative to the cell.
                     * @param {number} value The button's left margin relative to the cell.
                     * @returns {number | GC.Spread.Sheets.CellTypes.Button} If no value is set, returns the left margin in pixels; otherwise, returns the button cell type.
                     * @example
                     * //This example creates a button cell and sets its margins.
                     * var cellType = new GC.Spread.Sheets.CellTypes.Button();
                     * cellType.buttonBackColor("#FFFF00");
                     * cellType.text("this is a button");
                     * cellType.marginTop(5).marginRight(8).marginBottom(10).marginLeft(12);
                     * activeSheet.getCell(0, 2).cellType(cellType);
                     * activeSheet.setColumnWidth(2, 120.0,GC.Spread.Sheets.SheetArea.viewport);
                     * activeSheet.setRowHeight(0, 90.0,GC.Spread.Sheets.SheetArea.viewport);
                     */
                    marginLeft(value?:  number): any;
                    /**
                     * Gets or sets the button's right margin in pixels relative to the cell.
                     * @param {number} value The button's right margin relative to the cell.
                     * @returns {number | GC.Spread.Sheets.CellTypes.Button} If no value is set, returns the right margin in pixels; otherwise, returns the button cell type.
                     * @example
                     * //This example creates a button cell and sets its margins.
                     * var cellType = new GC.Spread.Sheets.CellTypes.Button();
                     * cellType.buttonBackColor("#FFFF00");
                     * cellType.text("this is a button");
                     * cellType.marginTop(5).marginRight(8).marginBottom(10).marginLeft(12);
                     * activeSheet.getCell(0, 2).cellType(cellType);
                     * activeSheet.setColumnWidth(2, 120.0,GC.Spread.Sheets.SheetArea.viewport);
                     * activeSheet.setRowHeight(0, 90.0,GC.Spread.Sheets.SheetArea.viewport);
                     */
                    marginRight(value?:  number): any;
                    /**
                     * Gets or sets the button's top margin in pixels relative to the cell.
                     * @param {number} value The button's top margin relative to the cell.
                     * @returns {number | GC.Spread.Sheets.CellTypes.Button} If no value is set, returns the top margin in pixels; otherwise, returns the button cell type.
                     * @example
                     * //This example creates a button cell and sets its margins.
                     * var cellType = new GC.Spread.Sheets.CellTypes.Button();
                     * cellType.buttonBackColor("#FFFF00");
                     * cellType.text("this is a button");
                     * cellType.marginTop(5).marginRight(8).marginBottom(10).marginLeft(12);
                     * activeSheet.getCell(0, 2).cellType(cellType);
                     * activeSheet.setColumnWidth(2, 120.0,GC.Spread.Sheets.SheetArea.viewport);
                     * activeSheet.setRowHeight(0, 90.0,GC.Spread.Sheets.SheetArea.viewport);
                     */
                    marginTop(value?:  number): any;
                    /**
                     * Gets or sets the button's content.
                     * @param {string} value The button's content.
                     * @returns {string | GC.Spread.Sheets.CellTypes.Button} If no value is set, returns the content; otherwise, returns the button cell type.
                     * @example
                     * //This example creates a button cell.
                     * var cellType = new GC.Spread.Sheets.CellTypes.Button();
                     * cellType.buttonBackColor("#FFFF00");
                     * cellType.text("this is a button");
                     * activeSheet.getCell(0, 2).cellType(cellType);
                     */
                    text(value?:  string): any;
                }

                export class CheckBox extends Base{
                    /**
                     * Represents a check box cell.
                     * @extends GC.Spread.Sheets.CellTypes.Base
                     * @class
                     * @example
                     * //This example creates a check box cell.
                     * var cellType1 = new GC.Spread.Sheets.CellTypes.CheckBox();
                     * cellType1.caption("caption");
                     * cellType1.textTrue("true");
                     * cellType1.textFalse("false");
                     * cellType1.textIndeterminate("indeterminate");
                     * cellType1.textAlign(GC.Spread.Sheets.CellTypes.CheckBoxTextAlign.bottom);
                     * cellType1.isThreeState(true);
                     * activeSheet.getCell(1, 1).cellType(cellType1);
                     */
                    constructor();
                    /**
                     * Gets or sets the caption of the cell type.
                     * @param {string} value The caption of the cell type.
                     * @returns {string | GC.Spread.Sheets.CellTypes.CheckBox} If no value is set, returns the caption; otherwise, returns the check box cell type.
                     * @example
                     * //This example creates a check box cell.
                     * var cellType1 = new GC.Spread.Sheets.CellTypes.CheckBox();
                     * cellType1.caption("caption");
                     * cellType1.textTrue("true");
                     * cellType1.textFalse("false");
                     * cellType1.textIndeterminate("indeterminate");
                     * cellType1.textAlign(GC.Spread.Sheets.CellTypes.CheckBoxTextAlign.bottom);
                     * cellType1.isThreeState(true);
                     * activeSheet.getCell(1, 1).cellType(cellType1);
                     */
                    caption(value?:  string): any;
                    /**
                     * Gets or sets a value that indicates whether the check box supports three states.
                     * @param {boolean} value Whether the check box supports three states.
                     * @returns {boolean | GC.Spread.Sheets.CellTypes.CheckBox} If no value is set, returns whether the check box supports three states; otherwise, returns the check box cell type.
                     * @example
                     * //This example creates a check box cell.
                     * var cellType1 = new GC.Spread.Sheets.CellTypes.CheckBox();
                     * cellType1.caption("caption");
                     * cellType1.textTrue("true");
                     * cellType1.textFalse("false");
                     * cellType1.textIndeterminate("indeterminate");
                     * cellType1.textAlign(GC.Spread.Sheets.CellTypes.CheckBoxTextAlign.bottom);
                     * cellType1.isThreeState(true);
                     * activeSheet.getCell(1, 1).cellType(cellType1);
                     */
                    isThreeState(value?:  boolean): any;
                    /**
                     * Gets or sets the text alignment relative to the check box.
                     * @param {GC.Spread.Sheets.CellTypes.CheckBoxTextAlign} value The text alignment relative to the check box.
                     * @returns {GC.Spread.Sheets.CellTypes.CheckBoxTextAlign | GC.Spread.Sheets.CellTypes.CheckBox} If no value is set, returns the text alignment relative to the check box; otherwise, returns the check box cell type.
                     * @example
                     * //This example creates a check box cell.
                     * var cellType1 = new GC.Spread.Sheets.CellTypes.CheckBox();
                     * cellType1.caption("caption");
                     * cellType1.textTrue("true");
                     * cellType1.textFalse("false");
                     * cellType1.textIndeterminate("indeterminate");
                     * cellType1.textAlign(GC.Spread.Sheets.CellTypes.CheckBoxTextAlign.bottom);
                     * cellType1.isThreeState(true);
                     * activeSheet.getCell(1, 1).cellType(cellType1);
                     */
                    textAlign(value?:  GC.Spread.Sheets.CellTypes.CheckBoxTextAlign): any;
                    /**
                     * Gets or sets the text in the cell when the cell's value is <c>false</c>.
                     * @param {string} value The text in the cell when the cell's value is <c>false</c>.
                     * @returns {string | GC.Spread.Sheets.CellTypes.CheckBox} If no value is set, returns the text in the cell when the cell's value is <c>false</c>. If a value is set, returns the check box cell type.
                     * @example
                     * //This example creates a check box cell.
                     * var cellType1 = new GC.Spread.Sheets.CellTypes.CheckBox();
                     * cellType1.caption("caption");
                     * cellType1.textTrue("true");
                     * cellType1.textFalse("false");
                     * cellType1.textIndeterminate("indeterminate");
                     * cellType1.textAlign(GC.Spread.Sheets.CellTypes.CheckBoxTextAlign.bottom);
                     * cellType1.isThreeState(true);
                     * activeSheet.getCell(1, 1).cellType(cellType1);
                     */
                    textFalse(value?:  string): any;
                    /**
                     * Gets or sets the text in the cell when the cell's value is indeterminate (neither <c>true</c> nor <c>false</c>).
                     * @param {string} value The text in the cell when the cell's value is indeterminate.
                     * @returns {string | GC.Spread.Sheets.CellTypes.CheckBox} If no value is set, returns the text in the cell when the cell's value is indeterminate. If a value is set, returns the check box cell type.
                     * @example
                     * //This example creates a check box cell.
                     * var cellType1 = new GC.Spread.Sheets.CellTypes.CheckBox();
                     * cellType1.caption("caption");
                     * cellType1.textTrue("true");
                     * cellType1.textFalse("false");
                     * cellType1.textIndeterminate("indeterminate");
                     * cellType1.textAlign(GC.Spread.Sheets.CellTypes.CheckBoxTextAlign.bottom);
                     * cellType1.isThreeState(true);
                     * activeSheet.getCell(1, 1).cellType(cellType1);
                     */
                    textIndeterminate(value?:  string): any;
                    /**
                     * Gets or sets the text in the cell when the cell's value is <c>true</c>.
                     * @param {string} value The text when the cell's value is <c>true</c>.
                     * @returns {string | GC.Spread.Sheets.CellTypes.CheckBox} If no value is set, returns the text when the cell's value is <c>true</c>. If a value is set, returns the check box cell type.
                     * @example
                     * //This example creates a check box cell.
                     * var cellType1 = new GC.Spread.Sheets.CellTypes.CheckBox();
                     * cellType1.caption("caption");
                     * cellType1.textTrue("true");
                     * cellType1.textFalse("false");
                     * cellType1.textIndeterminate("indeterminate");
                     * cellType1.textAlign(GC.Spread.Sheets.CellTypes.CheckBoxTextAlign.bottom);
                     * cellType1.isThreeState(true);
                     * activeSheet.getCell(1, 1).cellType(cellType1);
                     */
                    textTrue(value?:  string): any;
                }

                export class ColumnHeader extends Base{
                    /**
                     * Represents the painter of the column header cells.
                     * @extends GC.Spread.Sheets.CellTypes.Base
                     * @class
                     */
                    constructor();
                }

                export class ComboBox extends Base{
                    /**
                     * Represents an editable combo box cell.
                     * @extends GC.Spread.Sheets.CellTypes.Base
                     * @class
                     * @example
                     * //This example creates a combo box cell.
                     * var cellType2 = new GC.Spread.Sheets.CellTypes.ComboBox();
                     * cellType2.items(["a","b","c"]);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    constructor();
                    /**
                     * Gets or sets whether the combo box is editable.
                     * @param {boolean} value Whether the combo box is editable.
                     * @returns {boolean | GC.Spread.Sheets.CellTypes.ComboBoxBox} If no value is set, returns whether the combo box is editable; otherwise, returns the combo box cellType.
                     * @example
                     * //This example sets the editable method.
                     * var items2 = ["a", "ab", "abc", "apple", "boy", "cat", "dog"];
                     * var eComboBoxCellType = new GC.Spread.Sheets.CellTypes.ComboBox().items(items2).editable(true);
                     * activeSheet.getCell(1, 3).cellType(eComboBoxCellType);
                     * activeSheet.setColumnWidth(0,120);
                     * activeSheet.setColumnWidth(2,120);
                     */
                    editable(value?:  boolean): any;
                    /**
                     * Gets or sets the value that is written to the underlying data model.
                     * @param {GC.Spread.Sheets.CellTypes.EditorValueType} value The type of editor value.
                     * @returns {GC.Spread.Sheets.CellTypes.EditorValueType | GC.Spread.Sheets.CellTypes.ComboBoxBox} If no value is set, returns the type of editor value; otherwise, returns the combo box cellType.
                     * @example
                     * //This example gets the type.
                     * var cellType2 = new GC.Spread.Sheets.CellTypes.ComboBox();
                     * cellType2.items(["a","b","c"]);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     * alert(cellType2.editorValueType());
                     */
                    editorValueType(value?:  GC.Spread.Sheets.CellTypes.EditorValueType): any;
                    /**
                     * Gets or sets the height of each item.
                     * @param {number} value The height of each item.
                     * @returns {number | GC.Spread.Sheets.CellTypes.ComboBoxBox} If no value is set, returns the height of each item; otherwise, returns the  combo box cellType.
                     * @example
                     * //This example sets the item height.
                     * var cellType2 = new GC.Spread.Sheets.CellTypes.ComboBox();
                     * cellType2.items(["a","b","c"]);
                     * cellType2.itemHeight(30);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    itemHeight(value?:  number): any;
                    /**
                     * Gets or sets the items for the drop-down list in the combo box.
                     * @param {Array} items The items for the combo box.
                     * @returns {Array | GC.Spread.Sheets.CellTypes.ComboBoxBox} If no value is set, returns the items array; otherwise, returns the  combo box cellType.
                     * @example
                     * //This example creates a combo box cell.
                     * var cellType2 = new GC.Spread.Sheets.CellTypes.ComboBox();
                     * cellType2.items(["a","b","c"]);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    items(items?:  any[]): any;
                    /**
                     * Gets or sets the maximum item count of the drop-down list per page.
                     * @param {number} value The maximum item count of the drop-down list per page.
                     * @returns {number | GC.Spread.Sheets.CellTypes.ComboBoxBox} If no value is set, returns the maximum item count of the drop-down list per page; otherwise, returns the  combo box cellType.
                     * @example
                     * //This example shows three items in the list at a time.
                     * var cellType2 = new GC.Spread.Sheets.CellTypes.ComboBox();
                     * cellType2.items(["a", "b", "c", "d", "e", "f", "g", "h"]);
                     * cellType2.maxDropDownItems(3);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     * });
                     */
                    maxDropDownItems(value?:  number): any;
                }

                export class Corner extends Base{
                    /**
                     * Represents the painter of the corner cell.
                     * @extends GC.Spread.Sheets.CellTypes.Base
                     * @class
                     */
                    constructor();
                }

                export class HyperLink extends Base{
                    /**
                     * Represents the hyperlink cell.
                     * @extends GC.Spread.Sheets.CellTypes.Base
                     * @class
                     * @example
                     * var cellType = new GC.Spread.Sheets.CellTypes.HyperLink();
                     * cellType.linkColor("blue");
                     * cellType.visitedLinkColor("#FF2235");
                     * cellType.text("GrapeCity");
                     * cellType.linkToolTip("Company Web Site");
                     * activeSheet.getCell(1, 1).cellType(cellType).value("http://www.grapecity.com/");
                     * activeSheet.getCell(1, -1).height(30);
                     * @example
                     * var cellType = new GC.Spread.Sheets.CellTypes.HyperLink();
                     * cellType.linkColor("blue");
                     * cellType.visitedLinkColor("#FF2235");
                     * cellType.text("GrapeCity");
                     * cellType.linkToolTip("Company Web Site");
                     * activeSheet.getCell(0, 2).cellType(cellType).value("formula.html");
                     */
                    constructor();
                    /**
                     *  Gets or sets whether to move to the active cell when clicked.
                     * @param {boolean} value Whether to move to the active cell when clicked.
                     * @returns {boolean | GC.Spread.Sheets.CellTypes.HyperLink} If no value is set, returns a value that indicates whether to move to the active cell; otherwise, returns the hyperlink cell type.
                     * @example
                     * //This example uses the activeOnClick method.
                     * var h1 = new GC.Spread.Sheets.CellTypes.HyperLink();
                     * h1.text("GrapeCity");
                     * h1.linkToolTip("link to GrapeCity Web page");
                     * h1.linkColor("rgb(0, 100, 200)");
                     * h1.visitedLinkColor("rgb(0, 200, 100)");
                     * h1.activeOnClick(true);
                     * activeSheet.setCellType(1, 1, h1);
                     * activeSheet.getCell(1, 1, GC.Spread.Sheets.SheetArea.viewport).value("http://www.grapecity.com/").hAlign(GC.Spread.Sheets.HorizontalAlign.center);
                     */
                    activeOnClick(value?:  boolean): any;
                    /**
                     * Gets or sets the color of the hyperlink.
                     * @param {string} value The hyperlink color.
                     * @returns {string | GC.Spread.Sheets.CellTypes.HyperLink} If no value is set, returns the hyperlink color; otherwise, returns the hyperLink cell type.
                     * @example
                     * //This example creates a hyperlink cell.
                     * cellType = new GC.Spread.Sheets.CellTypes.HyperLink();
                     * cellType.linkColor("blue");
                     * cellType.visitedLinkColor("#FF2235");
                     * cellType.text("GrapeCity");
                     * cellType.linkToolTip("Company Web Site");
                     * activeSheet.getCell(1, 1).cellType(cellType).value("http://www.grapecity.com/");
                     * activeSheet.getCell(1, -1).height(30);
                     */
                    linkColor(value?:  string): any;
                    /**
                     * Gets or sets the tooltip for the hyperlink.
                     * @param {string} value The tooltip text.
                     * @returns {string | GC.Spread.Sheets.CellTypes.HyperLink} If no value is set, returns the tooltip text; otherwise, returns the hyperLink cell type.
                     * @example
                     * //This example creates a hyperlink cell.
                     * cellType = new GC.Spread.Sheets.CellTypes.HyperLink();
                     * cellType.linkColor("blue");
                     * cellType.visitedLinkColor("#FF2235");
                     * cellType.text("GrapeCity");
                     * cellType.linkToolTip("Company Web Site");
                     * activeSheet.getCell(1, 1).cellType(cellType).value("http://www.grapecity.com/");
                     * activeSheet.getCell(1, -1).height(30);
                     */
                    linkToolTip(value?:  string): any;
                    /**
                     *  Gets or sets the callback of the hyperlink, If execute the function will represent the context for the callback.
                     * @param {Function} value The callback of the hyperlink.
                     * @returns {Function | GC.Spread.Sheets.CellTypes.HyperLink} If no value is set, return a value that indicates the callback of the hyperlink; otherwise, returns the hyperlink cell type.
                     * @example
                     * //This example sets the tab color when selecting the hyperlink.
                     * var h2 = new GC.Spread.Sheets.CellTypes.HyperLink();
                     * h2.text("set sheet tab style");
                     * h2.linkToolTip("set sheet tab style");
                     * h2.linkColor("blue");
                     * h2.visitedLinkColor("#FF2235");
                     * activeSheet.getCell(2, 1).cellType(h2).value("set sheet tab style").hAlign(GC.Spread.Sheets.HorizontalAlign.center);
                     * h2.activeOnClick(true);
                     *             h2.onClickAction(function () {
                     *                 var setSheetTabColor = {
                     *                     canUndo: true,
                     *                     execute: function (context, options, isUndo) {
                     *                         activeSheet.name("Hyperlink");
                     *                         activeSheet.options.sheetTabColor = "red";
                     *                     }
                     *                 };
                     *                 var commandManager = spread.commandManager();
                     *                 var commandName = "setSheetTabStyle";
                     *                 commandManager.register(commandName, setSheetTabColor, null, false, false, false, false);
                     *                 commandManager.execute({cmd: commandName})
                     *             });
                     */
                    onClickAction(value?:  Function): any;
                    /**
                     *  Gets or sets the type for the hyperlink's target.
                     * @param {GC.Spread.Sheets.CellTypes.HyperLinkTargetType} value The hyperlink's target type.
                     * @returns {GC.Spread.Sheets.CellTypes.HyperLinkTargetType | GC.Spread.Sheets.CellTypes.HyperLink} If no value is set, returns the hyperlink's target type; otherwise, returns the hyperLink cell type.
                     * @example
                     * //This example creates a hyperlink cell.
                     * var cellType = new GC.Spread.Sheets.CellTypes.HyperLink();
                     * cellType.linkColor("blue");
                     * cellType.visitedLinkColor("#FFFF00");
                     * cellType.text("GrapeCity");
                     * cellType.linkToolTip("Company Web Site");
                     * cellType.target(GC.Spread.Sheets.CellTypes.HyperLinkTargetType.self);
                     * activeSheet.getCell(0, 2).cellType(cellType).value("http://www.grapecity.com/");
                     */
                    target(value?:  GC.Spread.Sheets.CellTypes.HyperLinkTargetType): any;
                    /**
                     * Gets or sets the text string for the hyperlink.
                     * @param {string} value The text displayed in the hyperlink.
                     * @returns {string | GC.Spread.Sheets.CellTypes.HyperLink} If no value is set, returns the text in the hyperlink; otherwise, returns the hyperLink cell type.
                     * @example
                     * //This example creates a hyperlink cell.
                     * var cellType = new GC.Spread.Sheets.CellTypes.HyperLink();
                     * cellType.linkColor("blue");
                     * cellType.visitedLinkColor("#FFFF00");
                     * cellType.text("GrapeCity");
                     * cellType.linkToolTip("Company Web Site");
                     * cellType.target(GC.Spread.Sheets.CellTypes.HyperLinkTargetType.self);
                     * activeSheet.getCell(0, 2).cellType(cellType).value("http://www.grapecity.com/");
                     */
                    text(value?:  string): any;
                    /**
                     * Gets or sets the color of visited links.
                     * @param {string} value The visited link color.
                     * @returns {string | GC.Spread.Sheets.CellTypes.HyperLink} If no value is set, returns the visited link color; otherwise, returns the hyperLink cell type.
                     * @example
                     * //This example creates a hyperlink cell.
                     * var cellType = new GC.Spread.Sheets.CellTypes.HyperLink();
                     * cellType.linkColor("blue");
                     * cellType.visitedLinkColor("#FFFF00");
                     * cellType.text("GrapeCity");
                     * cellType.linkToolTip("Company Web Site");
                     * cellType.target(GC.Spread.Sheets.CellTypes.HyperLinkTargetType.self);
                     * activeSheet.getCell(0, 2).cellType(cellType).value("http://www.grapecity.com/");
                     */
                    visitedLinkColor(value?:  string): any;
                }

                export class RowHeader extends Base{
                    /**
                     * Represents the painter of the row header cells.
                     * @extends GC.Spread.Sheets.CellTypes.Base
                     * @class
                     */
                    constructor();
                }

                export class Text extends Base{
                    /**
                     * Represents a text cell type.
                     * @extends GC.Spread.Sheets.CellTypes.Base
                     * @class
                     * @param {GC.Spread.Sheets.CellTypes.EditorType} editorType The editor type of the text cell type.
                     */
                    constructor();
                }
            }

            module Charts{

                export interface IAxes{
                    primaryCategory?: IAxis;
                    primaryValue?: IAxis;
                    secondaryCategory?: IAxis;
                    secondaryValue?: IAxis;
                }


                export interface IAxis{
                    lineStyle?: GC.Spread.Sheets.Charts.IBorder;
                    style?: GC.Spread.Sheets.Charts.IAxisStyle;
                    majorTickPosition?: GC.Spread.Sheets.Charts.TickMark;
                    minorTickPosition?: GC.Spread.Sheets.Charts.TickMark;
                    majorUnit?: number;
                    minorUnit?: number;
                    format?: string;
                    title?: GC.Spread.Sheets.Charts.IAxisTitle;
                    majorGridLine?: GC.Spread.Sheets.Charts.IGridLine;
                    minorGridLine?: GC.Spread.Sheets.Charts.IGridLine;
                }


                export interface IAxisStyle{
                    color?: string;
                    transparency?: number;
                    fontFamily?: string;
                    fontSize?: number;
                }


                export interface IAxisTitle{
                    text?: string;
                    color?: string;
                    transparency?: number;
                    fontFamily?: string;
                    fontSize?: number;
                }


                export interface IBorder{
                    color?: string;
                    width?: number;
                    transparency?: number;
                }


                export interface IChartArea{
                    backColor?: string;
                    backColorTransparency?: number;
                    fontFamily?: string;
                    fontSize?: number;
                    color?: string;
                    transparency?: number;
                }


                export interface IChartTitle{
                    text?: string;
                    fontFamily?: string;
                    fontSize?: number;
                    color?: string;
                    transparency?:number;
                }


                export interface IDataLabels{
                    showValue?: boolean;
                    showSeriesName?: boolean;
                    showCategoryName?: boolean;
                    position?: GC.Spread.Sheets.Charts.DataLabelPosition;
                    format?: string;
                    color?: string;
                    transparency?: number;
                }


                export interface IGridLine{
                    color?: string;
                    transparency?: number;
                    visible?: boolean;
                    width?: number;
                }


                export interface ILegend{
                    position?: GC.Spread.Sheets.Charts.LegendPosition;
                    visible?: boolean;
                    backColor?: string;
                    backColorTransparency?: number;
                    borderStyle?: GC.Spread.Sheets.Charts.IBorder;
                }


                export interface ISeries{
                    chartType?: GC.Spread.Sheets.Charts.ChartType;
                    axisGroup?: GC.Spread.Sheets.Charts.AxisGroup;
                    backColor?: string;
                    backColorTransparency?: number;
                    border?: GC.Spread.Sheets.Charts.IBorder;
                    startAngle?: number;
                    name?: string;
                    xValues?: string;
                    yValues?: string;
                    bubbleSizes?: string;
                }

                /**
                 * Specifies the type of axis group.
                 * @enum {number}
                 */
                export enum AxisGroup{
                    /**
                     * Primary axis group.
                     */
                    primary= 0,
                    /**
                     * Secondary axis group.
                     */
                    secondary= 1
                }

                /**
                 * Specifies the chart type.
                 * @enum {number}
                 */
                export enum ChartType{
                    /**
                     * Combo
                     */
                    combo= 0,
                    /**
                     * Scatter
                     */
                    xyScatter= 1,
                    /**
                     * Radar
                     */
                    radar= 2,
                    /**
                     * Doughnut
                     */
                    doughnut= 3,
                    /**
                     * Area
                     */
                    area= 8,
                    /**
                     * Line
                     */
                    line= 9,
                    /**
                     * Pie
                     */
                    pie= 10,
                    /**
                     * Bubble
                     */
                    bubble= 11,
                    /**
                     * Clustered Column
                     */
                    columnClustered= 12,
                    /**
                     * Stacked Column
                     */
                    columnStacked= 13,
                    /**
                     * 100% Stacked Column
                     */
                    columnStacked100= 14,
                    /**
                     * Clustered Bar
                     */
                    barClustered= 18,
                    /**
                     * Stacked Bar
                     */
                    barStacked= 19,
                    /**
                     * 100% Stacked Bar
                     */
                    barStacked100= 20,
                    /**
                     * Stacked Line
                     */
                    lineStacked= 24,
                    /**
                     * 100% Stacked Line
                     */
                    lineStacked100= 25,
                    /**
                     * Line with Markers
                     */
                    lineMarkers= 26,
                    /**
                     * Stacked Line with Markers
                     */
                    lineMarkersStacked= 27,
                    /**
                     * 100% Stacked Line with Markers
                     */
                    lineMarkersStacked100= 28,
                    /**
                     * Scatter with Smoothed Lines
                     */
                    xyScatterSmooth= 33,
                    /**
                     * Scatter with Smoothed Lines and No Data Markers
                     */
                    xyScatterSmoothNoMarkers= 34,
                    /**
                     * Scatter with Lines.
                     */
                    xyScatterLines= 35,
                    /**
                     * Scatter with Lines and No Data Markers
                     */
                    xyScatterLinesNoMarkers= 36,
                    /**
                     * Stacked Area
                     */
                    areaStacked= 37,
                    /**
                     * 100% Stacked Area
                     */
                    areaStacked100= 38,
                    /**
                     * Radar with data makers
                     */
                    radarMarkers= 42,
                    /**
                     * Filled Radar
                     */
                    radarFilled= 43,
                    /**
                     * High-Low-Close
                     */
                    stockHLC= 49,
                    /**
                     * Open-High-Low-Close
                     */
                    stockOHLC= 50,
                    /**
                     * Volume-High-Low-Close
                     */
                    stockVHLC= 51,
                    /**
                     * Volume-Open-High-Low-Close
                     */
                    stockVOHLC= 52,
                    /**
                     * Box & Whisker
                     */
                    boxWhisker= 53,
                    /**
                     * Funnel
                     */
                    funnel= 54,
                    /**
                     * Pareto
                     */
                    paretoLine= 55,
                    /**
                     * map
                     */
                    regionMap= 56,
                    /**
                     * sunburst
                     */
                    sunburst= 57,
                    /**
                     * tree map
                     */
                    treemap= 58,
                    /**
                     * Waterfull
                     */
                    waterfall= 59,
                    /**
                     *  Histogram
                     */
                    clusteredColumn= 60
                }

                /**
                 * Specifies where the data label is positioned.
                 * @enum {number}
                 */
                export enum DataLabelPosition{
                    /**
                     * Adjust data label position automatically.
                     */
                    bestFit= 0,
                    /**
                     * Data label below point.
                     */
                    below= 1,
                    /**
                     * Data label centered on data point or inside bar or pie.
                     */
                    center= 2,
                    /**
                     * Data label positioned arbitrarily.
                     */
                    insideBase= 3,
                    /**
                     * Data label positioned arbitrarily.
                     */
                    insideEnd= 4,
                    /**
                     * Data label positioned at bottom of bar or pie.
                     */
                    left= 5,
                    /**
                     * Data label positioned at top of bar or pie.
                     */
                    outsideEnd= 6,
                    /**
                     * Data label positioned at top of bar or pie.
                     */
                    right= 7,
                    /**
                     * Data label above point.
                     */
                    above= 8
                }

                /**
                 * Specifies the position of the legend on a chart.
                 * @enum {number}
                 */
                export enum LegendPosition{
                    /**
                     * Above the chart.
                     */
                    top= 1,
                    /**
                     * To the right of the chart.
                     */
                    right= 2,
                    /**
                     * To the left of the chart.
                     */
                    left= 3,
                    /**
                     * Below the chart.
                     */
                    bottom= 4
                }

                /**
                 * Specifies whether the values corresponding to a particular data series are in rows or columns.
                 * @enum {number}
                 */
                export enum RowCol{
                    /**
                     * Data series is in a column.
                     */
                    rows= 0,
                    /**
                     * Data series is in a row.
                     */
                    columns= 1
                }

                /**
                 * Specifies the position of tick-mark labels on the specified axis.
                 * @enum {number}
                 */
                export enum TickLabelPosition{
                    /**
                     * Next to axis (where axis is not at either side of the chart).
                     */
                    nextToAxis= 2,
                    /**
                     * No tick marks.
                     */
                    none= 3
                }

                /**
                 * Specifies the position of major and minor tick marks for an axis.
                 * @enum {number}
                 */
                export enum TickMark{
                    /**
                     * Crosses the axis.
                     */
                    cross= 0,
                    /**
                     * Inside the axis.
                     */
                    inside= 1,
                    /**
                     * No mark.
                     */
                    none= 2,
                    /**
                     * Outside the axis.
                     */
                    outside= 3
                }


                export class Chart extends GC.Spread.Sheets.FloatingObjects.FloatingObject{
                    /**
                     * Represents a chart.
                     * @extends GC.Spread.Sheets.FloatingObjects.FloatingObject
                     * @class
                     * @param {GC.Spread.Sheets.Worksheet} sheet The host sheet of the chart.
                     * @param {string} name The name of the chart.
                     * @param {GC.Spread.Sheets.Charts.ChartType} chartType The type of the chart.
                     * @param {number} x The <i>x</i> location of the chart.
                     * @param {number} y The <i>y</i> location of the chart.
                     * @param {number} width The width of the chart.
                     * @param {number} height The height of the chart.
                     * @param {string?} dataRange The formula string of data range for the chart.
                     * @param {GC.Spread.Sheets.Charts.RowCol?} dataOrientation The orientation of data for series.
                     */
                    constructor(sheet:  GC.Spread.Sheets.Worksheet,  name:  string,  chartType:  GC.Spread.Sheets.Charts.ChartType,  x:  number,  y:  number,  width:  number,  height:  number,  dataRange?:  string,  dataOrientation?:  GC.Spread.Sheets.Charts.RowCol);
                    /**
                     * Gets or sets the chart axes of the chart.
                     * @param {Object} value The chart axes of the chart.
                     * @param {Object} value.primaryCategory The primary category axis of the chart.
                     * @param {Object} value.primaryValue The primary value axis of the chart.
                     * @param {Object} value.secondaryCategory The secondary category axis of the chart.
                     * @param {Object} value.secondaryValue The secondary value axis of the chart.
                     *
                     * The primaryCategory, primaryValue, secondaryCategory and secondaryValue have same type.
                     * @param {boolean} value.primaryCategory.visible Indicates if the specified axis should be shown.
                     * @param {GC.Spread.Sheets.Charts.TickLabelPosition} value.primaryCategory.tickLabelPosition The tick label position.
                     * @param {Object} value.primaryCategory.lineStyle The line style of the primary category axis.
                     * @param {string} value.primaryCategory.lineStyle.color The line color of the primary category axis.
                     * @param {number} value.primaryCategory.lineStyle.transparency The transparency of the chart primary category axis line color.
                     * @param {number} value.primaryCategory.lineStyle.width The line width of the primary category axis.
                     * @param {Object} value.primaryCategory.style The style of the primary category axis.
                     * @param {string} value.primaryCategory.style.color The color of the primary category axis.
                     * @param {number} value.primaryCategory.style.transparency The transparency of the chart primary category axis color.
                     * @param {string} value.primaryCategory.style.fontFamily The font family of the primary category axis.
                     * @param {number} value.primaryCategory.style.fontSize The font size of the primary category axis, its unit is pixel.
                     * @param {GC.Spread.Sheets.Charts.TickMark} value.primaryCategory.majorTickPosition The major tick position of the primary category axis.
                     * @param {GC.Spread.Sheets.Charts.TickMark} value.primaryCategory.minorTickPosition The minor tick position of the primary category axis.
                     * @param {number} value.primaryCategory.majorUnit The major unit of the primary category axis.
                     * @param {number} value.primaryCategory.minorUnit The minor unit of the primary category axis.
                     * @param {number | Date} value.primaryCategory.min The minimum value of the related axis. (for value / date axis only)
                     * @param {number | Date} value.primaryCategory.max The maximum value of the related axis. (for value / date axis only)
                     * @param {string} value.primaryCategory.format The format of the primary category axis.
                     * @param {Object} value.primaryCategory.title The title of the primary category axis.
                     * @param {string} value.primaryCategory.title.text The title text of the primary category axis.
                     * @param {string} value.primaryCategory.title.color The title color of the primary category axis.
                     * @param {number} value.primaryCategory.title.transparency The transparency of the primary category axis color.
                     * @param {string} value.primaryCategory.title.fontFamily The title font family of the primary category axis.
                     * @param {number} value.primaryCategory.title.fontSize The title font size of the primary category axis, its unit is pixel.
                     * @param {Object} value.primaryCategory.majorGridLine The major grid line of the primary category axis.
                     * @param {Object} value.primaryCategory.minorGridLine The minor grid line of the primary category axis.
                     * @param {number} value.primaryCategory.labelAngle The label angle of the primary category axis.
                     *
                     * The majorGridLine and minorGridLine have same type.
                     * @param {string} value.primaryCategory.majorGridLine.color The color of the major grid line.
                     * @param {boolean} value.primaryCategory.majorGridLine.visible The visibility of the major grid line.
                     * @param {number} value.primaryCategory.majorGridLine.width The width of the major grid line.
                     * @param {number} value.primaryCategory.majorGridLine.transparency The transparency of the major grid line color.
                     *
                     * @returns {Object | GC.Spread.Sheets.Charts.Chart} If no value is set, returns the chart axes of the chart; otherwise, returns the chart.
                     */
                    axes(value?:  GC.Spread.Sheets.Charts.IAxes): any;
                    /**
                     * Gets or sets the chart area style of the chart.
                     * @param {Object} value The chart area style of the chart.
                     * @param {string} value.backColor The background color of the chart area.
                     * @param {number} value.backColorTransparency The transparency of the chart area backColor.
                     * @param {string} value.fontFamily The font family of the chart area.
                     * @param {number} value.fontSize The font size of the chart area, its unit is pixel.
                     * @param {string} value.color The color of the chart area.
                     * @param {number} value.transparency The transparency of the chart area color.
                     * @returns {Object | GC.Spread.Sheets.Charts.Chart} If no value is set, returns the chart area style of the chart; otherwise, returns the chart.
                     */
                    chartArea(value?:  GC.Spread.Sheets.Charts.IChartArea): any;
                    /**
                     * Gets or sets the type of the chart.
                     * @param {GC.Spread.Sheets.Charts.ChartType} value The type of the chart.
                     * @returns {GC.Spread.Sheets.Charts.ChartType | GC.Spread.Sheets.Charts.Chart} If no value is set, returns the type of the chart; otherwise, returns the chart.
                     */
                    chartType(value?:  GC.Spread.Sheets.Charts.ChartType): any;
                    /**
                     * Gets or sets the chart data labels style of the chart.
                     * @param {Object} value The chart data labels style of the chart.
                     * @param {boolean} value.showValue Whether to show value in data labels.
                     * @param {boolean} value.showSeriesName Whether to show series name in data labels.
                     * @param {boolean} value.showCategoryName Whether to show category name in data labels.
                     * @param {boolean} value.showPercentage Whether to show the percent value in data labels.
                     * @param {GC.Spread.Sheets.Charts.DataLabelPosition} value.position The position of the chart data labels.
                     * @param {string} value.format The format of the chart data labels.
                     * @param {string} value.color The color of the chart data labels.
                     * @param {number} value.transparency The transparency of the chart data labels color.
                     * @returns {Object | GC.Spread.Sheets.Charts.Chart} If no value is set, returns the chart data labels style of the chart; otherwise, returns the chart.
                     */
                    dataLabels(value?:  GC.Spread.Sheets.Charts.IDataLabels): any;
                    /**
                     * Gets or sets the whole data range of the chart as formula string.
                     * @param {string} value The formula string of the data range for the chart.
                     * @returns {string | GC.Spread.Sheets.Charts.Chart} If no value is set, returns the formula string of the whole data range for the chart; otherwise, returns the chart.
                     */
                    dataRange(value?:  string): any;
                    /**
                     * Gets or sets the legend of the chart.
                     * @param {Object} value The legend of the chart.
                     * @param {GC.Spread.Sheets.Charts.LegendPosition} value.position The position of the chart legend.
                     * @param {boolean} value.visible The visibility of the chart legend.
                     * @param {string} value.backColor The backgroundColor of the chart legend.
                     * @param {number} value.backColorTransparency The transparency of the chart legend color
                     * @param {Object} value.borderStyle The borderStyle of the chart legend.
                     * @param {string} value.borderStyle.color The border color of the chart legend.
                     * @param {number} value.borderStyle.width The border width of the chart legend.
                     * @param {number} value.borderStyle.transparency The transparency of the chart legend border color
                     * @returns {Object | GC.Spread.Sheets.Charts.Chart} If no value is set, returns the legend of the chart; otherwise, returns the chart.
                     */
                    legend(value?:  GC.Spread.Sheets.Charts.ILegend): any;
                    /**
                     * Gets the series collection of the chart.
                     * @returns {GC.Spread.Sheets.Charts.SeriesCollection} Returns the series collection of the chart.
                     */
                    series(): GC.Spread.Sheets.Charts.SeriesCollection;
                    /**
                     * Switches the data orientation between rows and columns.
                     * @returns {boolean} Returns true when data orienetation is changable and successful switched; otherwise, false.
                     */
                    switchDataOrientation(): boolean;
                    /**
                     * Gets or sets the title of the chart.
                     * @param {Object} value The title of the chart.
                     * @param {string} value.text The text of the chart title.
                     * @param {string} value.fontFamily The font family of the chart title.
                     * @param {number} value.fontSize The font size of the chart title, its unit is pixel.
                     * @param {string} value.color The color of the chart title.
                     * @param {number} value.transparency The transparency of the chart title color
                     * @returns {Object | GC.Spread.Sheets.Charts.Chart} If no value is set, returns the title of the chart; otherwise, returns the chart.
                     */
                    title(value?:  GC.Spread.Sheets.Charts.IChartTitle): any;
                    /**
                     * Gets or sets whether apply animation to the chart.
                     * @param {boolean} value whether apply animation to the chart.
                     * @returns {boolean | GC.Spread.Sheets.Charts.Chart} If no value is set, returns whether apply animation to the chart; otherwise, returns the chart.
                     */
                    useAnimation(value?:  boolean): any;
                }

                export class ChartCollection{
                    /**
                     * Represents a chart manager that managers all charts in a sheet.
                     * @class
                     * @param {GC.Spread.Sheets.Worksheet} sheet The worksheet.
                     */
                    constructor();
                    /**
                     * Adds a chart to the sheet.
                     * @param {string} name The name of the chart that will be added to the sheet.
                     * @param {GC.Spread.Sheets.Charts.ChartType} chartType The type of the chart.
                     * @param {number} x The x location of the chart.
                     * @param {number} y The y location of the chart.
                     * @param {number} width The width of the chart.
                     * @param {number} height The height of the chart.
                     * @param {string?} dataRange The formula string of data range for the chart.
                     * @param {GC.Spread.Sheets.Charts.RowCol?} dataOrientation The orientation of data for series.
                     * @return {GC.Spread.Sheets.Charts.Chart} The chart that has been added to the sheet.
                     * @example
                     * //This example shows how to add a chart.
                     * var dataRange = "A1:D4";
                     * var chart = activeSheet.charts.add('Chart1', GC.Spread.Sheets.Charts.ChartType.columnClustered, 250, 20, 600, 400, dataRange);
                     */
                    add(name:  string,  chartType:  GC.Spread.Sheets.Charts.ChartType,  x:  number,  y:  number,  width:  number,  height:  number,  dataRange?:  string,  dataOrientation?:  GC.Spread.Sheets.Charts.RowCol): GC.Spread.Sheets.Charts.Chart;
                    /**
                     * Gets all of the charts in the sheet.
                     * @return {Array} The collection of all the charts in the sheet.
                     * @example
                     * var dataRange = "A1:D4";
                     * activeSheet.charts.add('Chart1', GC.Spread.Sheets.Charts.ChartType.columnClustered, 250, 20, 600, 180, dataRange);
                     * var dataRange2 = "A20:D24";
                     * activeSheet.charts.add('Chart2', GC.Spread.Sheets.Charts.ChartType.columnClustered, 250, 220, 600, 180, dataRange2);
                     * var charts = activeSheet.charts.all();
                     * for (var i = 0; i &lt; charts.length; i++) {
                     *     alert("Name of chart " + i + " is:  " + charts[i].name())
                     * }
                     */
                    all(): GC.Spread.Sheets.Charts.Chart[];
                    /**
                     * Removes all charts in the sheet.
                     */
                    clear(): void;
                    /**
                     * Gets a chart from the sheet by the indicate name.
                     * @param {string} name The name of the chart.
                     * @return {GC.Spread.Sheets.Charts.Chart} The chart in the sheet with the indicate name.
                     * @example
                     * var dataRange = "A1:D4";
                     * activeSheet.charts.add('Chart1', GC.Spread.Sheets.Charts.ChartType.columnClustered, 250, 20, 600, 400, dataRange);
                     * //button
                     * $("#button1").click(function () {
                     *  var chart = activeSheet.charts.get("f2");
                     * });
                     */
                    get(name:  string): GC.Spread.Sheets.Charts.Chart;
                    /**
                     * Removes a chart from the sheet by the indicate name.
                     * @param {string} name The name of the chart.
                     * @example
                     * var dataRange = "A1:D4";
                     * activeSheet.charts.add('Chart1', GC.Spread.Sheets.Charts.ChartType.columnClustered, 250, 20, 600, 400, dataRange);
                     * //button
                     * $("#button1").click(function () {
                     *      activeSheet.resumePaint();
                     *      activeSheet.charts.remove("f2");
                     *      activeSheet.repaint();
                     * });
                     */
                    remove(name:  string): void;
                    /**
                     * Gets or sets the z-index of chart.
                     * @param {string} name The name of the chart.
                     * @param {number} zIndex The z-index of the chart.
                     * @return {number | *} If the parameter 'zIndex' is null or undefined,it will return the z-index of the chart with the indicate name.
                     * @example
                     * var dataRange = "A1:D4";
                     * activeSheet.charts.add('Chart1', GC.Spread.Sheets.Charts.ChartType.columnClustered, 250, 20, 600, 180, dataRange);
                     * var dataRange2 = "A20:D24";
                     * activeSheet.charts.add('Chart2', GC.Spread.Sheets.Charts.ChartType.columnClustered, 250, 180, 600, 180, dataRange2);
                     * activeSheet.charts.zIndex('Chart1', 897);
                     * activeSheet.charts.zIndex('Chart2', 890);
                     */
                    zIndex(name:  string,  zIndex?:  number): any;
                }

                export class DataPoints{
                    /**
                     * Represents the dataPoint collection that managers all dataPoints in a chart series.
                     * @class
                     */
                    constructor();
                    /**
                     * Gets all dataPoints or a specified dataPoint from dataPoints collection.
                     * @param {number} index The index of the dataPoint.
                     * @return {Object | Object[]} The dataPoint of the chart series.
                     * @example
                     * // This example shows how to get a dataPoint.
                     * var dataRange = new GC.Spread.Sheets.Range(0, 0, 16, 4);
                     * var chart = activeSheet.charts.add('Chart1', GC.Spread.Sheets.Charts.ChartType.sunburst, 250, 20, 600, 400, dataRange);
                     * var dataPoints = chart.series().dataPoints();
                     * var dataPoint = dataPoints.get(0);
                     */
                    get(index?:  number): any;
                    /**
                     * Updates the specified dataPoint's property.
                     * @param {number} index The index of the dataPoint.
                     * @param {Object} dataPoint The data point of the chart.
                     * @param {string} dataPoint.fillColor The color of the data point.
                     * @param {number} dataPoint.transparency The transparency of the data point color.
                     * @example
                     * // This example shows how to update the property of a dataPoint
                     * var dataRange = new GC.Spread.Sheets.Range(0, 0, 16, 4);
                     * var chart = activeSheet.charts.add('Chart1', GC.Spread.Sheets.Charts.ChartType.sunburst, 250, 20, 600, 400, dataRange);
                     * var dataPoints = chart.series().dataPoints();
                     * var dataPoint = {fillColor: 'rgba(255,255,0,0,7)'};
                     * dataPoints.set(0, dataPoint);
                     */
                    set(index:  number,  dataPoint:  Object): void;
                }

                export class SeriesCollection{
                    /**
                     * Represents the series manager that managers all series in a chart.
                     * @class
                     */
                    constructor();
                    /**
                     * Adds a new series to series collection.
                     * @param {Object} seriesItem The series of the chart.
                     * @param {GC.Spread.Sheets.Charts.ChartType} seriesItem.chartType The chart type of the series.
                     * @param {GC.Spread.Sheets.Charts.AxisGroup} seriesItem.axisGroup The axis group of the series.
                     * @param {string} seriesItem.backColor The background color of the series.
                     * @param {number} seriesItem.backColorTransparency The transparency of the series background color.
                     * @param {string} seriesItem.border The border of the series.
                     * @param {string} seriesItem.border.color The border color of the series.
                     * @param {number} seriesItem.border.transparency The transparency of the series border color.
                     * @param {number} seriesItem.border.width The border width of the series.
                     * @param {number} seriesItem.startAngle The first slice angle of the chart whose chart type is pie. The default value is 0, which represents the 12 o'clock position.
                     * @param {string} seriesItem.name The name formula of the series.
                     * @param {string} seriesItem.xValues The x values formula of the series.
                     * @param {string} seriesItem.yValues The y values formula of the series.
                     * @param {string} seriesItem.bubbleSizes The bubble sizes formula of the series. This is used for bubble chart.
                     * @example
                     * // This example shows how to add a new series.
                     * var dataRange = "A1:D4";
                     * var chart = activeSheet.charts.add('Chart1', GC.Spread.Sheets.Charts.ChartType.columnClustered, 250, 20, 600, 400, dataRange);
                     * chart.series.add({
                     *     chartType: GC.Spread.Sheets.Charts.ChartType.columnClustered,
                     *     axisGroup: GC.Spread.Sheets.Charts.AxisGroup.primary,
                     *     backColor: {
                     *         color: "lightblue",
                     *         width: 2
                     *     },
                     *     xValues: "A2:A4",
                     *     yValues: "B2:B4"
                     * });
                     */
                    add(series:  GC.Spread.Sheets.Charts.ISeries): void;
                    /**
                     * Gets the dataPoints of the chart series.
                     * @returns {GC.Spread.Sheets.Charts.DataPoints} Returns the dataPoints of the chart series if exist.
                     */
                    dataPoints(): GC.Spread.Sheets.Charts.DataPoints;
                    /**
                     * Gets all series or a specified series from series collection.
                     * @param {number} index The index of the series.
                     * @return {Object | Object[]} The series of the chart.
                     * @example
                     * // This example shows how to get a series.
                     * var dataRange = "A1:D4";
                     * var chart = activeSheet.charts.add('Chart1', GC.Spread.Sheets.Charts.ChartType.columnClustered, 250, 20, 600, 400, dataRange);
                     * var series1 = chart.series().get(0);
                     */
                    get(index:  number): any;
                    /**
                     * Removes a specified series from series collection.
                     * @param {number} index The index of the series.
                     * @example
                     * // This example shows how to remove a specified series.
                     * var dataRange = "A1:D4";
                     * var chart = activeSheet.charts.add('Chart1', GC.Spread.Sheets.Charts.ChartType.columnClustered, 250, 20, 600, 400, dataRange);
                     * chart.series.remove(0);
                     */
                    remove(index:  number): void;
                    /**
                     * Updates the specified series's property.
                     * @param {number} index The index of the series.
                     * @param {Object} seriesItem The series of the chart.
                     * @param {GC.Spread.Sheets.Charts.ChartType} seriesItem.chartType The chart type of the series.
                     * @param {GC.Spread.Sheets.Charts.AxisGroup} seriesItem.axisGroup The axis group of the series.
                     * @param {string} seriesItem.backColor The background color of the series.
                     * @param {number} seriesItem.backColorTransparency The transparency of the series background color.
                     * @param {string} seriesItem.border The border of the series.
                     * @param {string} seriesItem.border.color The border color of the series.
                     * @param {number} seriesItem.border.transparency The transparency of the series border color.
                     * @param {number} seriesItem.border.width The border width of the series.
                     * @param {number} seriesItem.startAngle The first slice angle of the chart whose chart type is pie. The default value is 0, which represents the 12 o'clock position.
                     * @param {string} seriesItem.name The name formula of the series.
                     * @param {string} seriesItem.xValues The x values formula of the series.
                     * @param {string} seriesItem.yValues The y values formula of the series.
                     * @param {string} seriesItem.bubbleSizes The bubble sizes formula of the series. This is used for bubble chart.
                     * @example
                     * // This example shows how to update the property of a series.
                     * var dataRange = "A1:D4";
                     * var chart = activeSheet.charts.add('Chart1', GC.Spread.Sheets.Charts.ChartType.columnClustered, 250, 20, 600, 400, dataRange);
                     * var series1 = chart.series().get(0);
                     * series1.backColor = "red";
                     * chart.series().set(0, series1);
                     */
                    set(index:  number,  series:  GC.Spread.Sheets.Charts.ISeries): void;
                }
            }

            module Commands{
                /**
                 * Represents the command used to automatically resize the column in a sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.columns {Array} The resize columns; each item is an object which has a col.<br />
                 * options.rowHeader {boolean} Whether the resized columns are in the row header area.<br />
                 * options.autoFitType {GC.Spread.Sheets.AutoFitType} Whether the auto-fit action includes the header text.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * var columns = [ { col: 3 } ];
                 * spread.options.allowUndo = true;
                 * spread.commandManager().execute({cmd: "autoFitColumn", sheetName: "Sheet1", columns: columns, isRowHeader: false, autoFitType: GC.Spread.Sheets.AutoFitType.cell});
                 */
                var autoFitColumn: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, columns: Object[], rowHeader: boolean, autoFitType: GC.Spread.Sheets.AutoFitType}, isUndo: boolean): any};
                /**
                 * Represents the command used to automatically resize the row in a sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.rows {Array} The resize rows; each item is an object which has a row.<br />
                 * options.columnHeader {boolean} Whether the resized rows are in the column header area.<br />
                 * options.autoFitType {GC.Spread.Sheets.AutoFitType} Whether the auto-fit action includes the header text.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * spread.options.allowUndo = true;
                 * var rows = [ { row: 3 } ];
                 * spread.commandManager().execute({cmd: "autoFitRow", sheetName: "Sheet1", rows: rows, isColHeader: false, autoFitType: GC.Spread.Sheets.AutoFitType.cell});
                 */
                var autoFitRow: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, rows: Object[], columnHeader: boolean, autoFitType: GC.Spread.Sheets.AutoFitType}, isUndo: boolean): any};
                /**
                 * Represents the command used to stop cell editing and cancel input.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var cancelInput: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to switch the formula reference between relative, absolute, and mixed when editing formulas.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var changeFormulaReference: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to clear the cell value.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * // clear selected cells with the tab key
                 * spread.commandManager().setShortcutKey('clear', GC.Spread.Commands.Key.tab, false, false, false, false); // Tab key
                 */
                var clear: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to clear the active cell value and enters edit mode.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var clearAndEditing: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to clear cell values on a worksheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.ranges {Array} The clear cell value ranges whose item type is GC.Spread.Sheets.Range.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * spread.options.allowUndo = true;
                 * spread.commandManager().execute({cmd: "clearValues", sheetName: "Sheet1", ranges: [new GC.Spread.Sheets.Range(8, 5, 2, 1)]});
                 */
                var clearValues: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, ranges:GC.Spread.Sheets.Range[]}, isUndo: boolean): any};
                /**
                 * Represents the command used for a Clipboard paste on the worksheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.fromSheet {GC.Spread.Sheets.Worksheet} The source sheet.<br />
                 * options.fromRanges {Array} The source range array which item type is GC.Spread.Sheets.Range.<br />
                 * options.pastedRanges {Array} The target range array which item type is GC.Spread.Sheets.Range.<br />
                 * options.isCutting {boolean} Whether the operation is cutting or copying.<br />
                 * options.clipboardText {string} The text on the clipboard.<br />
                 * options.pasteOption {GC.Spread.Sheets.ClipboardPasteOptions} The Clipboard pasting option that indicates which content to paste.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the clipboardPaste method.
                 * activeSheet.setValue(0, 0, 1, GC.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.setValue(1, 0, 2, GC.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.setFormula(2, 0, "=A1+A2", GC.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.setValue(0, 1, 3, GC.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.setValue(1, 1, 4, GC.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.setFormula(2, 1, "=B1+B2", GC.Spread.Sheets.SheetArea.viewport);
                 * var fromRange = [new GC.Spread.Sheets.Range(0, 0, 3, 2)];
                 * var toRanges = [new GC.Spread.Sheets.Range(5, 0, 3, 2)];
                 * $("#button1").click(function () {
                 *     //Cut Paste Action
                 *     spread.commandManager().execute({cmd: "clipboardPaste", sheetName: "Sheet1", fromSheet: activeSheet, fromRanges: fromRange, pastedRanges: toRanges, isCutting: true, clipboardText: "", pasteOption: GC.Spread.Sheets.ClipboardPasteOptions.all});
                 * });
                 * $("#button2").click(function () {
                 *     spread.commandManager().execute({cmd: "clipboardPaste", sheetName: "Sheet1", fromSheet: activeSheet, fromRanges: fromRange, pastedRanges: toRanges, isCutting: false, clipboardText: "", pasteOption: GC.Spread.Sheets.ClipboardPasteOptions.all});
                 * });
                 * //Add button controls to page
                 * &lt;input type="button" id="button1" value="button1"/&gt;
                 * &lt;input type="button" id="button2" value="button2"/&gt;
                 */
                var clipboardPaste: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, fromSheet: GC.Spread.Sheets.Worksheet, fromRanges: GC.Spread.Sheets.Range[], pastedRanges: GC.Spread.Sheets.Range[], isCutting: boolean, clipboardText: string, pasteOption: GC.Spread.Sheets.ClipboardPasteOptions}, isUndo: boolean): any};
                /**
                 * Represents the command used to commit the cell editing and sets the array formula to the active range.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var commitArrayFormula: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to stop cell editing and moves the active cell to the next row.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var commitInputNavigationDown: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to stop cell editing and moves the active cell to the previous row.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var commitInputNavigationUp: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to copy the selected item text to the Clipboard.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var copy: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to cut the selected item text to the Clipboard.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 ** options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var cut: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command for deleting the floating objects.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var deleteFloatingObjects: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to drag and copy the floating objects on the sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.floatingObjects {Array} The names array of floating objects.<br />
                 * options.offsetX The horizontal offset.<br />
                 * options.offsetY The vertical offset.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise <c>false</c>.
                 */
                var dragCopyFloatingObjects: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, floatingObjects: string[], offsetX: number, offsetY: number}, isUndo: boolean): any};
                /**
                 * Represents the command used to drag a range and drop it onto another range on the worksheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * commandOptions {Object} The options of the operation.<br />
                 * commandOptions.sheetName {string} The sheet name.<br />
                 * commandOptions.fromRow {number} The source row index for the drag drop.<br />
                 * commandOptions.fromColumn {number} The source column index for the drag drop.<br />
                 * commandOptions.toRow {number} The destination row index for the drag drop.<br />
                 * commandOptions.toColumn {number} The destination column index for the drag drop.<br />
                 * commandOptions.rowCount {number} The row count for the drag drop.<br />
                 * commandOptions.columnCount {number} The column count for the drag drop.<br />
                 * commandOptions.copy {boolean} If set to <c>true</c> copy; otherwise, cut if <c>false</c>.<br />
                 * commandOptions.insert {boolean} If set to <c>true</c> inserts the drag data in the drop row or column.<br />
                 * commandOptions.option {GC.Spread.Sheets.CopyToOptions} Indicates the content type to drag and drop.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * spread.options.allowUndo = true;
                 * spread.commandManager().execute({cmd: "dragDrop",  sheetName: "Sheet1", fromRow:2, fromColumn:1, toRow:12, toColumn:2, rowCount:2, columnCount:2, copy: true, insert: false, option: GC.Spread.Sheets.CopyToOptions.value});
                 */
                var dragDrop: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, fromRow: number, fromColumn: number, toRow: number, toColumn: number, rowCount: number, columnCount: number, copy: boolean, insert: boolean, option: GC.Spread.Sheets.CopyToOptions}, isUndo: boolean): any};
                /**
                 * Represents the command used to apply a new value to a cell on the worksheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.row {number} The row index of the cell.<br />
                 * options.col {number} The column index of the cell.<br />
                 * options.newValue {Object} The new value of the cell.<br />
                 * options.autoFormat {boolean} Whether to format the new value automatically.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var editCell: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, row: number, col: number, newValue: any, autoFormat: boolean}, isUndo: boolean): any};
                /**
                 * Represents the command to expand or collapse a column range group.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.index {number} The outline summary index.<br />
                 * options.level {number} The outline level.<br />
                 * options.collapsed {boolean} Whether to make the outline collapsed or expanded.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var expandColumnOutline: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, index: number, level: number, collapsed: boolean}, isUndo: boolean): any};
                /**
                 * Represents the command used to expand or collapse column range groups on the same level.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.level {number} The outline level.<br />
                 * isUndo {boolean} <c>true</c> if this an undo operation; otherwise, <c>false</c>.
                 */
                var expandColumnOutlineForLevel: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, level: number}, isUndo: boolean): any};
                /**
                 * Represents the command to expand or collapse a row range group.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.index {number} The outline summary index.<br />
                 * options.level {number} The outline level.<br />
                 * options.collapsed {boolean} Whether to make the outline collapsed or expanded.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var expandRowOutline: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, index: number, level: number, collapsed: boolean}, isUndo: boolean): any};
                /**
                 * Represents the command used to expand or collapse row range groups on the same level.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.level {number} The outline level.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var expandRowOutlineForLevel: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, level: number}, isUndo: boolean): any};
                /**
                 * Represents the command used to drag and fill a range on the sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.startRange {GC.Spread.Sheets.Range} The start range.<br />
                 * options.fillRange {GC.Spread.Sheets.Range} The fill range.<br />
                 * options.autoFillType {GC.Spread.Sheets.Fill.AutoFillType} The auto fill type.<br />
                 * options.fillDirection {GC.Spread.Sheets.Fill.FillDirection} The fill direction.<br />
                 * isUndo {boolean} <c>true</c> if an undo operation; otherwise, <c>false</c>.
                 * @example
                 * spread.options.allowUndo = true;
                 * var srange = new GC.Spread.Sheets.Range(10, 5, 1, 1);
                 * var frange = new GC.Spread.Sheets.Range(11, 5, 5, 1);
                 * spread.commandManager().execute({cmd: "fill", sheetName: "Sheet1", startRange: srange, fillRange: frange, autoFillType: GC.Spread.Sheets.Fill.AutoFillType.fillSeries, fillDirection: GC.Spread.Sheets.Fill.FillDirection.down });
                 */
                var fill: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, startRange: GC.Spread.Sheets.Range, fillRange: GC.Spread.Sheets.Range, autoFillType: GC.Spread.Sheets.Fill.AutoFillType, fillDirection: GC.Spread.Sheets.Fill.FillDirection}, isUndo: boolean): any};
                /**
                 * Represents the command for moving floating objects.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.floatingObjects {Array} The names array of floating objects.<br />
                 * options.offsetX The horizontal offset.<br />
                 * options.offsetY The vertical offset.
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var moveFloatingObjects: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, floatingObjects: string[], offsetX: number, offsetY: number}, isUndo: boolean): any};
                /**
                 * Represents the command used to move the active cell to the next cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example maps the moveToNextCell action.
                 * spread.focus();
                 * spread.commandManager().setShortcutKey('moveToNextCell', GC.Spread.Commands.Key.a, false, false, false, false); // a
                 */
                var moveToNextCell: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to select the next control if the active cell is the last visible cell; otherwise, move the active cell to the next cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example maps the moveToNextCellThenControl action.
                 * spread.commandManager().setShortcutKey('moveToNextCellThenControl', GC.Spread.Commands.Key.tab, false, false, false, false); // Tab key
                 * spread.commandManager().setShortcutKey('moveToPreviousCellThenControl', GC.Spread.Commands.Key.tab, false, true, false, false); // Shift key and Tab key
                 */
                var moveToNextCellThenControl: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to move the active cell to the previous cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the moveToPreviousCell action.
                 * spread.commandManager().setShortcutKey('moveToPreviousCell', GC.Spread.Commands.Key.a, false, false, false, false); // a
                 */
                var moveToPreviousCell: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to select the previous control if the active cell is the first visible cell; otherwise, move the active cell to the previous cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example maps the moveToPreviousCellThenControl action.
                 * spread.commandManager().setShortcutKey('moveToNextCellThenControl', GC.Spread.Commands.Key.tab, false, false, false, false); // Tab key
                 * spread.commandManager().setShortcutKey('moveToPreviousCellThenControl', GC.Spread.Commands.Key.tab, false, true, false, false); // Shift key and Tab key
                 */
                var moveToPreviousCellThenControl: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to move the active cell to the last row.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example maps the navigationBottom action to the Tab key.
                 * spread.commandManager().setShortcutKey('navigationDown', GC.Spread.Commands.Key.tab, false, false, false, false); // Tab key
                 * spread.commandManager().setShortcutKey('navigationBottom', GC.Spread.Commands.Key.tab, false, true, false, false); // Shift key and Tab key
                 */
                var navigationBottom: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to move the active cell to the next row.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example maps the navigationDown key.
                 * spread.commandManager().setShortcutKey('navigationDown', GC.Spread.Commands.Key.tab, false, false, false, false); // Tab key
                 * spread.commandManager().setShortcutKey('navigationBottom', GC.Spread.Commands.Key.tab, false, true, false, false); // Shift key and Tab key
                 */
                var navigationDown: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to move the active cell to the last column.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationEnd method.
                 * spread.commandManager().setShortcutKey('navigationEnd', GC.Spread.Commands.Key.tab,  false, false, false, false); // Tab key
                 */
                var navigationEnd: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to move the active cell to the last column without regard to frozen trailing columns.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationEnd2 action.
                 * spread.commandManager().setShortcutKey("navigationEnd2", GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationEnd2: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to move the active cell to the first cell in the sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationFirst action.
                 * spread.commandManager().setShortcutKey("navigationFirst", GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationFirst: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to move the active cell to the first column.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationHome action.
                 * spread.commandManager().setShortcutKey("navigationHome", GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationHome: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to move the active cell to the first column without regard to frozen columns.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 ** options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationHome2 action.
                 * spread.commandManager().setShortcutKey("navigationHome2", GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationHome2: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to move the active cell to the last cell in the sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationLast action.
                 * spread.commandManager().setShortcutKey("navigationLast", GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationLast: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to move the active cell to the previous column.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationLeft action.
                 * spread.commandManager().setShortcutKey("navigationLeft", GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationLeft: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to move the active sheet to the next sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationNextSheet action.
                 * spread.commandManager().setShortcutKey("navigationNextSheet", GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationNextSheet: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to move the active cell down one page of rows.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationPageDown action.
                 * spread.commandManager().setShortcutKey("navigationPageDown", GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationPageDown: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to move the active cell up one page of rows.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationPageUp action.
                 * spread.commandManager().setShortcutKey("navigationPageUp", GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationPageUp: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to move the active sheet to the previous sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationPreviousSheet action.
                 * spread.commandManager().setShortcutKey("navigationNextSheet", GC.Spread.Commands.Key.a, false, false, false, false);
                 * spread.commandManager().setShortcutKey("navigationPreviousSheet", GC.Spread.Commands.Key.c, false, false, false, false);
                 */
                var navigationPreviousSheet: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to move the active cell to the next column.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationRight action.
                 * spread.commandManager().setShortcutKey("navigationRight", GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationRight: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to move the active cell to the first row.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationTop action.
                 * spread.commandManager().setShortcutKey("navigationTop", GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationTop: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to move the active cell to the previous row.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example maps the navigationUp action to a.
                 * spread.commandManager().setShortcutKey('navigationUp', GC.Spread.Commands.Key.a, false, false, false, false); // a
                 */
                var navigationUp: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command for grouping a column outline (range group) on a sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.index {number} The outline starting index.<br />
                 * options.count {number} The number of rows or columns to group or ungroup in the outline.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example creates a group.
                 * spread.options.allowUndo = true;
                 * spread.commandManager().execute({cmd: "outlineColumn", sheetName: "Sheet1", index: 3, count: 5});
                 */
                var outlineColumn: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, index: number, count: number}, isUndo: boolean): any};
                /**
                 * Represents the command for grouping a row outline (range group) on a sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.index {number} The outline starting index.<br />
                 * options.count {number} The number of rows or columns to group or ungroup in the outline.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example undoes an action.
                 * spread.options.allowUndo = true;
                 * spread.commandManager().execute({cmd: "outlineRow", sheetName: "Sheet1", index: 3, count: 5});
                 */
                var outlineRow: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, index: number, count: number}, isUndo: boolean): any};
                /**
                 * Represents the command used to paste the selected items from the Clipboard to the current sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var paste: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command for pasting the floating objects on the sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var pasteFloatingObjects: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to perform a redo of the most recently undone edit or action.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the undo or redo action.
                 * $("#button1").click(function () {
                 *    if(spread.undoManager().canUndo()){
                 *        spread.undoManager().undo();
                 *    }
                 * });
                 * $("#button2").click(function () {
                 *     if(spread.undoManager().canRedo()){
                 *         spread.undoManager().redo();
                 *     }
                 * });
                 */
                var redo: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command for ungrouping a column outline (range group) on a sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.index {number} The outline starting index.<br />
                 * options.count {number} The number of rows or columns to group or ungroup in the outline.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var removeColumnOutline: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, index: number, count: number}, isUndo: boolean): any};
                /**
                 * Represents the command for ungrouping a row outline (range group) on a sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.index {number} The outline starting index.<br />
                 * options.count {number} The number of rows or columns to group or ungroup in the outline.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var removeRowOutline: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, index: number, count: number}, isUndo: boolean): any};
                /**
                 * Represents the command used to rename a worksheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.name {string} The sheet's new name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example renames a sheet.
                 * spread.commandManager().execute({cmd: "renameSheet", sheetName: "Sheet1", name: "SheetName"});
                 */
                var renameSheet: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, name: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to resize the column on a worksheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.columns {Array} The resize columns; each item is an object which has firstCol and lastCol.<br />
                 * options.size {number} The size of the column that is being resized.<br />
                 * options.rowHeader {boolean} Whether the column being resized is in the row header area.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var resizeColumn: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, columns: Object[], size: number, rowHeader: boolean}, isUndo: boolean): any};
                /**
                 * Represents the command for resizing floating objects.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.floatingObjects {Array} The names array of floating objects.<br />
                 * options.offsetX The offset left.<br />
                 * options.offsetY The offset top.<br />
                 * options.offsetWidth The offset width.<br />
                 * options.offsetHeight The offset height.
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var resizeFloatingObjects: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, floatingObjects: string[], offsetX: number, offsetY: number, offsetWidth: number, offsetHeight: number}, isUndo: boolean): any};
                /**
                 * Represents the command used to resize the row on a worksheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.rows {Array} The resize rows; each item is an object which has firstRow and lastRow.<br />
                 * options.size {number} The size of the row that is being resized.<br />
                 * options.columnHeader {boolean} Whether the row being resized is in the column header area.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var resizeRow: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, rows: Object[], size: number, columnHeader: boolean}, isUndo: boolean): any};
                /**
                 * Represents the command used to extend the selection to the last row.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionBottom action.
                 * spread.commandManager().setShortcutKey('selectionBottom', GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionBottom: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to extend the selection down one row.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionDown action.
                 * spread.commandManager().setShortcutKey('selectionDown', GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionDown: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to extend the selection to the last column.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionEnd action.
                 * spread.focus();
                 * spread.commandManager().setShortcutKey('selectionEnd', GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionEnd: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to extend the selection to the first cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionFirst action.
                 * spread.focus();
                 * spread.commandManager().setShortcutKey('selectionFirst', GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionFirst: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to extend the selection to the first column.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionHome action.
                 * spread.focus();
                 * spread.commandManager().setShortcutKey('selectionHome', GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionHome: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to extend the selection to the last cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionLast action.
                 * spread.focus();
                 * spread.commandManager().setShortcutKey('selectionLast', GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionLast: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to extend the selection one column to the left.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionLeft action.
                 * spread.commandManager().setShortcutKey('selectionLeft', GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionLeft: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to extend the selection down to include one page of rows.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionPageDown action.
                 * spread.commandManager().setShortcutKey('selectionPageDown', GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionPageDown: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to extend the selection up to include one page of rows.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionPageUp action.
                 * spread.commandManager().setShortcutKey('selectionPageUp', GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionPageUp: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to extend the selection one column to the right.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionRight action.
                 * spread.commandManager().setShortcutKey("selectionRight", GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionRight: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to extend the selection to the first row.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionTop action.
                 * spread.commandManager().setShortcutKey("selectionTop", GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionTop: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to extend the selection up one row.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionUp action.
                 * spread.commandManager().setShortcutKey("selectionUp", GC.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionUp: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to select the next control.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example maps the selectNextControl action to the Tab key.
                 * spread.commandManager().setShortcutKey('selectNextControl', GC.Spread.Commands.Key.tab, false, false, false, false); // Tab key
                 * spread.commandManager().setShortcutKey('selectPreviousControl', GC.Spread.Commands.Key.tab, false, true, false, false); // Shift key and Tab key
                 */
                var selectNextControl: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to select the previous control.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 ** options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example maps the selectPreviousControl action to the Shift + Tab key combination.
                 * spread.commandManager().setShortcutKey('selectNextControl', GC.Spread.Commands.Key.tab, false, false, false, false); // Tab key
                 * spread.commandManager().setShortcutKey('selectPreviousControl', GC.Spread.Commands.Key.tab, false, true, false, false); // Shift key and Tab key
                 */
                var selectPreviousControl: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to perform an undo of the most recent edit or action.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the undo or redo action.
                 * $("#button1").click(function () {
                 *      if(spread.undoManager().canUndo()){
                 *          spread.undoManager().undo();
                 *      }
                 *  });
                 * $("#button2").click(function() {
                 *      if(spread.undoManager().canRedo()){
                 *          spread.undoManager().redo();
                 *      }
                 * });
                 */
                var undo: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to zoom the sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GC.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.zoomFactor {number} The zoom factor.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var zoom: { canUndo: boolean, execute(context: GC.Spread.Sheets.Workbook, options: {sheetName: string, zoomFactor: number}, isUndo: boolean): any};
                /**
                 * Ends a transaction. During the transaction, the changes of the data model will be saved.
                 * @param {GC.Spread.Sheets.Workbook} context The context of the operation.
                 * @param {Object} options The options of the operation.<br />
                 *  @param  {string|Array<string>} [options.sheetName] The sheet name. If the current transaction need change multiple worksheets, the sheetName could be a string Array.
                 */
                function endTransaction(context:  GC.Spread.Sheets.Workbook,  options:  any): void;
                /**
                 * Starts a transaction. During the transaction, the changes of the data model will be saved.
                 * @param {GC.Spread.Sheets.Workbook} context The context of the operation.
                 * @param {Object} options The options of the operation.
                 * @param {string|Array<string>} [options.sheetName] The sheet name. If the current transaction need change multiple worksheets, the sheetName could be a string Array.
                 */
                function startTransaction(context:  GC.Spread.Sheets.Workbook,  options:  any): void;
                /**
                 * Undo the changes made in a transaction.
                 * @param {GC.Spread.Sheets.Workbook} context The context of the operation.
                 * @param {Object} options The options of the operation.<br />
                 * @param {string|Array<string>} [options.sheetName] The sheet name. If the current transaction need change multiple worksheets, the sheetName could be a string Array.
                 */
                function undoTransaction(context:  GC.Spread.Sheets.Workbook,  options:  any): void;
            }

            module Comments{
                /**
                 * Defines the comment state.
                 * @enum {number}
                 * @example
                 * //This example gets the comment state.
                 * var comment = new GC.Spread.Sheets.Comments.Comment();
                 * comment.text("new comment!");
                 * comment.backColor("yellow");
                 * comment.foreColor("green");
                 * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                 * activeSheet.getCell(5,5).comment(comment);
                 * alert(comment.commentState());
                 */
                export enum CommentState{
                    /**
                     * Specifies that the comment is in an active state.
                     */
                    active= 1,
                    /**
                     *Specifies that the comment is in an editing state.
                     */
                    edit= 2,
                    /**
                     * Specifies that the comment is in a normal state.
                     */
                    normal= 3
                }

                /**
                 * Defines when the comment is displayed.
                 * @enum {number}
                 * @example
                 * //This example uses the DisplayMode enumeration.
                 * var comment = new GC.Spread.Sheets.Comments.Comment();
                 * comment.text("new comment!");
                 * comment.backColor("yellow");
                 * comment.foreColor("green");
                 * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                 * activeSheet.getCell(5,5).comment(comment);
                 */
                export enum DisplayMode{
                    /**
                     *  Specifies that the comment is always displayed.
                     */
                    alwaysShown= 1,
                    /**
                     *  Specifies that the comment is displayed only when the pointer hovers over the comment's owner cell.
                     */
                    hoverShown= 2
                }


                export class Comment{
                    /**
                     * Represents a comment.
                     * @class
                     * @param text The text of the comment.
                     * @example
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.autoSize(true);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    constructor();
                    /**
                     * Gets or sets whether the comment automatically sizes based on its content.
                     * @param {boolean} value Whether the comment automatically sizes.
                     * @returns {boolean | GC.Spread.Sheets.Comments.Comment} If no value is set, returns whether the comment automatically sizes; otherwise, returns the comment.
                     * @example
                     * //This example uses the autoSize method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.autoSize(true);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    autoSize(value?:  boolean): any;
                    /**
                     * Gets or sets the background color of the comment.
                     * @param {string} value The background color of the comment.
                     * @returns {string | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the background color of the comment; otherwise, returns the comment.
                     * @example
                     * //This example sets the backColor method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    backColor(value?:  string): any;
                    /**
                     * Gets or sets the border color for the comment.
                     * @param {string} value The border color for the comment.
                     * @returns {string | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the border color for the comment; otherwise, returns the comment.
                     * @example
                     * //This example sets the borderColor method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.borderWidth(2);
                     * comment.borderStyle("dotted");
                     * comment.borderColor("red");
                     * activeSheet.getCell(5,5).comment(comment);
                     * activeSheet.suspendPaint();
                     * activeSheet.resumePaint();
                     */
                    borderColor(value?:  string): any;
                    /**
                     * Gets or sets the border style for the comment.
                     * @param {string} value The border style for the comment.
                     * @returns {string | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the border style for the comment; otherwise, returns the comment.
                     * @example
                     * //This example sets the borderStyle method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.borderWidth(2);
                     * comment.borderStyle("dotted");
                     * comment.borderColor("red");
                     * activeSheet.getCell(5,5).comment(comment);
                     * activeSheet.suspendPaint();
                     * activeSheet.resumePaint();
                     */
                    borderStyle(value?:  string): any;
                    /**
                     * Gets or sets the border width for the comment.
                     * @param {number} value The border width for the comment.
                     * @returns {number | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the border width for the comment; otherwise, returns the comment.
                     * @example
                     * //This example sets the borderWidth method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.borderWidth(2);
                     * comment.borderStyle("dotted");
                     * comment.borderColor("red");
                     * activeSheet.getCell(5,5).comment(comment);
                     * activeSheet.suspendPaint();
                     * activeSheet.resumePaint();
                     */
                    borderWidth(value?:  number): any;
                    /**
                     * Gets or sets the state of the comment.
                     * @param {GC.Spread.Sheets.Comments.CommentState} value The state of the comment.
                     * @returns {GC.Spread.Sheets.Comments.CommentState | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the state of the comment; otherwise, returns the comment.
                     * @example
                     * //This example gets the comment state.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * activeSheet.getCell(5,5).comment(comment);
                     * alert(comment.commentState());
                     */
                    commentState(value?:  GC.Spread.Sheets.Comments.CommentState): any;
                    /**
                     * Gets or sets the display mode for the comment.
                     * @param {GC.Spread.Sheets.Comments.DisplayMode} value The display mode for the comment.
                     * @returns {GC.Spread.Sheets.Comments.DisplayMode | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the display mode for the comment; otherwise, returns the comment.
                     * @example
                     * //This example sets the displayMode method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    displayMode(value?:  GC.Spread.Sheets.Comments.DisplayMode): any;
                    /**
                     * Gets or sets whether the comment dynamically moves.
                     * @param {boolean} value Whether the comment dynamically moves.
                     * @returns {boolean | GC.Spread.Sheets.Comments.Comment} If no value is set, returns whether the comment dynamically moves; otherwise, returns the comment.
                     * @example
                     * //This example uses the dynamicMove method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.dynamicMove(true);
                     * comment.dynamicSize(true);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    dynamicMove(value?:  boolean): any;
                    /**
                     * Gets or sets whether the comment is dynamically sized.
                     * @param {boolean} value Whether the comment is dynamically sized.
                     * @returns {boolean | GC.Spread.Sheets.Comments.Comment} If no value is set, returns whether the comment is dynamically sized; otherwise, returns the comment.
                     * @example
                     * //This example uses the dynamicSize method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.dynamicMove(true);
                     * comment.dynamicSize(true);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    dynamicSize(value?:  boolean): any;
                    /**
                     * Gets or sets the font family for the comment.
                     * @param {string} value The font family for the comment.
                     * @returns {string | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the font family for the comment; otherwise, returns the comment.
                     * @example
                     * //This example uses the fontFamily method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.fontFamily("Comic Sans MS");
                     * comment.fontSize("10pt");
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    fontFamily(value?:  string): any;
                    /**
                     * Gets or sets the font size for the comment. Valid value is numbers followed by "pt" (required), such as "12pt".
                     * @param {string} value The font size for the comment.
                     * @returns {string | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the font size for the comment; otherwise, returns the comment.
                     * @example
                     * //This example uses the fontSize method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.fontFamily("Comic Sans MS");
                     * comment.fontSize("10pt");
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    fontSize(value?:  string): any;
                    /**
                     * Gets or sets the font style of the comment.
                     * @param {string} value The font style of the comment.
                     * @returns {string | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the font style of the comment; otherwise, returns the comment.
                     * @example
                     * //This example uses the fontStyle method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.fontFamily("Comic Sans MS");
                     * comment.fontStyle("normal");
                     * comment.fontWeight("normal");
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    fontStyle(value?:  string): any;
                    /**
                     * Gets or sets the font weight for the comment.
                     * @param {string} value The font weight for the comment.
                     * @returns {string | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the font weight for the comment; otherwise, returns the comment.
                     * @example
                     * //This example uses the fontWeight method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.fontFamily("Comic Sans MS");
                     * comment.fontStyle("normal");
                     * comment.fontWeight("normal");
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    fontWeight(value?:  string): any;
                    /**
                     * Gets or sets the text color for the comment.
                     * @param {string} value The text color for the comment.
                     * @returns {string | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the text color for the comment; otherwise, returns the comment.
                     * @example
                     * //This example sets the foreColor method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    foreColor(value?:  string): any;
                    /**
                     * Gets or sets the height of the comment.
                     * @param {number} value The height of the comment.
                     * @returns {number | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the height of the comment; otherwise, returns the comment.
                     * @example
                     * //This example sets the height method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.height(50);
                     * comment.width(90);
                     * activeSheet.getCell(5,5).comment(comment);
                     * activeSheet.suspendPaint();
                     * activeSheet.resumePaint();
                     */
                    height(value?:  number): any;
                    /**
                     * Gets or sets the horizontal alignment of the comment.
                     * @param {GC.Spread.Sheets.HorizontalAlign} value The horizontal alignment of the comment.
                     * @returns {GC.Spread.Sheets.HorizontalAlign | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the horizontal alignment of the comment; otherwise, returns the comment.
                     * @example
                     * //This example uses the horizontalAlign method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.horizontalAlign(GC.Spread.Sheets.HorizontalAlign.center);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    horizontalAlign(value?:  GC.Spread.Sheets.HorizontalAlign): any;
                    /**
                     * Gets or sets the location of the comment.
                     * @param {GC.Spread.Sheets.Point} value The location of the comment.
                     * @returns {GC.Spread.Sheets.Point | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the location of the comment; otherwise, returns the comment.
                     * @example
                     * //This example uses the location method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.location(new GC.Spread.Sheets.Point(10, 10));
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    location(value?:  GC.Spread.Sheets.Point): any;
                    /**
                     * Gets or sets the locked setting for the comment.
                     * @param {boolean} value The locked setting for the comment.
                     * @returns {boolean | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the locked setting for the comment; otherwise, returns the comment.
                     * @example
                     * //This example uses the locked method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.lockText(false);
                     * comment.locked(false);
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * activeSheet.options.isProtected = true;
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    locked(value?:  boolean): any;
                    /**
                     * Gets or sets the locked text for the comment.
                     * @param {boolean} value The locked text for the comment.
                     * @returns {boolean | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the locked text for the comment; otherwise, returns the comment.
                     * @example
                     * //This example uses the lockText method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.lockText(false);
                     * comment.locked(false);
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * activeSheet.options.isProtected = true;
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    lockText(value?:  boolean): any;
                    /**
                     * Gets or sets the opacity of the comment.
                     * @param {number} value The opacity of the comment.
                     * @returns {number | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the opacity of the comment; otherwise, returns the comment.
                     * @example
                     * //This example sets the opacity.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.opacity(10);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    opacity(value?:  number): any;
                    /**
                     * Gets or sets the padding for the comment.
                     * @param {GC.Spread.Sheets.Comments.Padding} value The padding for the comment.
                     * @returns {GC.Spread.Sheets.Comments.Padding | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the padding for the comment; otherwise, returns the comment.
                     * @example
                     * //This example uses the padding method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.padding(new GC.Spread.Sheets.Comments.Padding(2, 2, 2, 2));
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    padding(value?:  GC.Spread.Sheets.Comments.Padding): any;
                    /**
                     * Gets or sets whether the comment displays a shadow.
                     * @param {boolean} value Whether the comment displays a shadow.
                     * @returns {boolean | GC.Spread.Sheets.Comments.Comment} If no value is set, returns whether the comment displays a shadow; otherwise, returns the comment.
                     * @example
                     * //This example uses the showShadow method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.borderWidth(2);
                     * comment.borderStyle("dotted");
                     * comment.borderColor("red");
                     * comment.showShadow(true);
                     * activeSheet.getCell(5,5).comment(comment);
                     * activeSheet.suspendPaint();
                     * activeSheet.resumePaint();
                     */
                    showShadow(value?:  boolean): any;
                    /**
                     * Gets or sets the text of the comment.
                     * @param {string} value The text of the comment.
                     * @returns {string | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the text of the comment; otherwise, returns the comment.
                     * @example
                     * //This example sets the text method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    text(value?:  string): any;
                    /**
                     * Gets or sets the text decoration for the comment.
                     * @param {GC.Spread.Sheets.TextDecorationType} value The text decoration for the comment.
                     * @returns {GC.Spread.Sheets.TextDecorationType | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the text decoration for the comment; otherwise, returns the comment.
                     * @example
                     * //This example uses the textDecoration method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.textDecoration(GC.Spread.Sheets.TextDecorationType.underline);
                     * activeSheet.getCell(5,5).comment(comment);
                     * activeSheet.suspendPaint();
                     * activeSheet.resumePaint();
                     */
                    textDecoration(value?:  GC.Spread.Sheets.TextDecorationType): any;
                    /**
                     * Gets or sets the width of the comment.
                     * @param {number} value The width of the comment.
                     * @returns {number | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the width of the comment; otherwise, returns the comment.
                     * @example
                     * //This example sets the width method.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.height(50);
                     * comment.width(90);
                     * activeSheet.getCell(5,5).comment(comment);
                     * activeSheet.suspendPaint();
                     * activeSheet.resumePaint();
                     */
                    width(value?:  number): any;
                    /**
                     * Gets or sets the z-index of the comment.
                     * @param {number} value The z-index of the comment.
                     * @returns {number | GC.Spread.Sheets.Comments.Comment} If no value is set, returns the z-index of the comment; otherwise, returns the comment.
                     * @example
                     * //This example gets the index.
                     * var comment = new GC.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GC.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * activeSheet.getCell(5,5).comment(comment);
                     * alert(comment.zIndex());
                     */
                    zIndex(value?:  number): any;
                }

                export class CommentManager{
                    /**
                     * Represents a comment manager that can manage all comments in a sheet.
                     * @class
                     * @param {GC.Spread.Sheets.Worksheet} sheet The worksheet.
                     */
                    constructor(sheet:  GC.Spread.Sheets.Worksheet);
                    /**
                     * Adds a comment to the cell for the indicated row and column.
                     * @param {number} row The row index of the cell.
                     * @param {number} col The column index of the cell.
                     * @param {string} text The text of the comment.
                     * @returns {GC.Spread.Sheets.Comments.Comment} The comment that has been added to the cell.
                     */
                    add(row:  number,  col:  number,  text:  string): GC.Spread.Sheets.Comments.Comment;
                    /**
                     * Gets all comments in the sheet.
                     * @returns {Array.<GC.Spread.Sheets.Comments.Comment>}
                     */
                    all(): GC.Spread.Sheets.Comments.Comment[];
                    /**
                     * Clears all of the comments in the indicated range on the sheet. When the range is not specified, it clears all the comments in the sheet.
                     * @param {GC.Spread.Sheets.Range} range The range that you want clear all comments from.
                     */
                    clear(range:  GC.Spread.Sheets.Range): void;
                    /**
                     * Gets the comment in the cell with the indicated row and column.
                     * @param {number} row The row index of the cell.
                     * @param {number} col The column index of the cell.
                     * @returns {GC.Spread.Sheets.Comments.Comment} The comment in the indicated cell.
                     */
                    get(row:  number,  col:  number): GC.Spread.Sheets.Comments.Comment;
                    /**
                     *Removes the comment from the cell for the indicated row and column.
                     * @param {number} row The row index of the cell.
                     * @param {number} col The column index of the cell.
                     */
                    remove(row:  number,  col:  number): void;
                }

                export class Padding{
                    /**
                     * Represents the padding information.
                     * @class
                     * @param {number} top The top padding.
                     * @param {number} right The right padding.
                     * @param {number} bottom The bottom padding.
                     * @param {number} left The left padding.
                     */
                    constructor(top?:  number,  right?:  number,  bottom?:  number,  left?:  number);
                }
            }

            module ConditionalFormatting{

                export interface IIconInfo{
                    iconSetType:GC.Spread.Sheets.ConditionalFormatting.IconSetType;
                    iconIndex:number;
                }

                /**
                 * Specifies the average condition type.
                 * @enum {number}
                 * @example
                 * //This example creates an average rule.
                 * activeSheet.setValue(0,0, 1,3);
                 * activeSheet.setValue(1,0, 50,3);
                 * activeSheet.setValue(2,0, 100,3);
                 * activeSheet.setValue(3,0, 2,3);
                 * activeSheet.setValue(4,0, 60,3);
                 * activeSheet.setValue(5,0, 90,3);
                 * activeSheet.setValue(6,0, 3,3);
                 * activeSheet.setValue(7,0, 40,3);
                 * activeSheet.setValue(8,0, 70,3);
                 * activeSheet.setValue(9,0, 5,3);
                 * activeSheet.setValue(10,0, 35,3);
                 * var style = new GC.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.borderLeft =new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderTop = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderRight = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * style.borderBottom = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                 * var rule = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                 * rule.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.averageRule);
                 * rule.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 3)]);
                 * rule.style(style);
                 * rule.type(GC.Spread.Sheets.ConditionalFormatting.AverageConditionType.above);
                 * activeSheet.conditionalFormats.addRule(rule);
                 */
                export enum AverageConditionType{
                    /** Specifies the above average condition.
                     * @type {number}
                     */
                    above= 0,
                    /** Specifies the below average condition.
                     * @type {number}
                     */
                    below= 1,
                    /** Specifies the above average or equal average condition.
                     * @type {number}
                     */
                    equalOrAbove= 2,
                    /** Specifies the below average or equal average condition.
                     * @type {number}
                     */
                    equalOrBelow= 3,
                    /** Specifies the above standard deviation condition.
                     * @type {number}
                     */
                    above1StdDev= 4,
                    /** Specifies the below standard deviation condition.
                     * @type {number}
                     */
                    below1StdDev= 5,
                    /** Specifies above the two standard deviation condition.
                     * @type {number}
                     */
                    above2StdDev= 6,
                    /** Specifies below the two standard deviation condition.
                     * @type {number}
                     */
                    below2StdDev= 7,
                    /** Specifies above the three standard deviation condition.
                     * @type {number}
                     */
                    above3StdDev= 8,
                    /** Specifies below the three standard deviation condition.
                     * @type {number}
                     */
                    below3StdDev= 9
                }

                /**
                 * Specifies the data bar direction.
                 * @enum {number}
                 * @example
                 * //This example creates a data bar rule.
                 * activeSheet.setValue(0,0,1,3);
                 * activeSheet.setValue(1,0,15,3);
                 * activeSheet.setValue(2,0,25,3);
                 * activeSheet.setValue(3,0,-1,3);
                 * var dataBarRule = new GC.Spread.Sheets.ConditionalFormatting.DataBarRule();
                 * dataBarRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                 * dataBarRule.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                 * dataBarRule.minValue(-1);
                 * dataBarRule.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                 * dataBarRule.maxValue(40);
                 * dataBarRule.color("green");
                 * dataBarRule.showBorder(true);
                 * dataBarRule.borderColor("orange");
                 * dataBarRule.dataBarDirection(GC.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                 * dataBarRule.negativeFillColor("yellow");
                 * dataBarRule.useNegativeFillColor(true);
                 * dataBarRule.negativeBorderColor("red");
                 * dataBarRule.useNegativeBorderColor(true);
                 * dataBarRule.axisPosition(GC.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                 * dataBarRule.axisColor("blue");
                 * dataBarRule.showBarOnly(false);
                 * activeSheet.conditionalFormats.addRule(dataBarRule);
                 */
                export enum BarDirection{
                    /** Specifies whether to display the data bar from left to right.
                     * @type {number}
                     */
                    leftToRight= 0,
                    /** Specifies whether to display the data bar from right to left.
                     * @type {number}
                     */
                    rightToLeft= 1
                }

                /**
                 * Specifies the color compare type.
                 * @enum {number}
                 * @example
                 * //This example filters using colors.
                 * activeSheet.suspendPaint();
                 * var rowFilter = new GC.Spread.Sheets.Filter.HideRowFilter(new GC.Spread.Sheets.Range(-1, 0, -1, 1));
                 * activeSheet.rowFilter(rowFilter);
                 * activeSheet.getCell(0, 0).value("A1").backColor("blue");
                 * activeSheet.getCell(1, 0).value("A2").backColor("yellow");
                 * activeSheet.getCell(2, 0).value("A3").backColor("red");
                 * activeSheet.getCell(3, 0).value("A4").backColor("green");
                 * activeSheet.getCell(4, 0).value("A5").backColor("yellow");
                 * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.colorCondition, {compareType: GC.Spread.Sheets.ConditionalFormatting.ColorCompareType.backgroundColor, expected: "yellow"});
                 * var filter = activeSheet.rowFilter();
                 * filter.addFilterItem(0, nCondition);
                 * filter.filter(0);
                 * activeSheet.resumePaint();
                 */
                export enum ColorCompareType{
                    /** Indicates whether the cell background color is equal to a specified color.
                     * @type {number}
                     */
                    backgroundColor= 0,
                    /** Indicates whether the cell foreground color is equal to a specified color.
                     * @type {number}
                     */
                    foregroundColor= 1
                }

                /**
                 * Specifies the comparison operator.
                 * @enum {number}
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GC.Spread.Sheets.DataValidation.createDateValidator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between, new Date(2012, 11, 31), new Date(2013, 11, 31));
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Enter a date between 12/31/2012 and 12/31/2013.");
                 * dv.inputTitle("Tip");
                 * activeSheet.getCell(1, -1).validator(dv);
                 */
                export enum ComparisonOperators{
                    /** Determines whether a cell value is equal to the parameter value.
                     * @type {number}
                     */
                    equalsTo= 0,
                    /** Determines whether a cell value is not equal to the parameter value.
                     * @type {number}
                     */
                    notEqualsTo= 1,
                    /** Determines whether a cell value is greater than the parameter value.
                     * @type {number}
                     */
                    greaterThan= 2,
                    /** Determines whether a cell value is greater than or equal to the parameter value.
                     * @type {number}
                     */
                    greaterThanOrEqualsTo= 3,
                    /** Determines whether a cell value is less than the parameter value.
                     * @type {number}
                     */
                    lessThan= 4,
                    /** Determines whether a cell value is less than or equal to the parameter value.
                     * @type {number}
                     */
                    lessThanOrEqualsTo= 5,
                    /** Determines whether a cell value is between the two parameter values.
                     * @type {number}
                     */
                    between= 6,
                    /** Determines whether a cell value is not between the two parameter values.
                     * @type {number}
                     */
                    notBetween= 7
                }

                /**
                 * Specifies the condition type.
                 * @enum {number}
                 */
                export enum ConditionType{
                    /** Specifies the relation condition.
                     * @type {number}
                     */
                    relationCondition= 0,
                    /** Specifies the number condition.
                     * @type {number}
                     */
                    numberCondition= 1,
                    /** Specifies the text condition.
                     * @type {number}
                     */
                    textCondition= 2,
                    /** Specifies the color condition.
                     * @type {number}
                     */
                    colorCondition= 3,
                    /** Specifies the formula condition.
                     * @type {number}
                     */
                    formulaCondition= 4,
                    /** Specifies the date condition.
                     * @type {number}
                     */
                    dateCondition= 5,
                    /** Specifies the dateex condition.
                     * @type {number}
                     */
                    dateExCondition= 6,
                    /** Specifies the text length condition.
                     * @type {number}
                     */
                    textLengthCondition= 7,
                    /** Specifies the top 10 condition.
                     * @type {number}
                     */
                    top10Condition= 8,
                    /** Specifies the unique condition.
                     * @type {number}
                     */
                    uniqueCondition= 9,
                    /** Specifies the average condition.
                     * @type {number}
                     */
                    averageCondition= 10,
                    /** Specifies the cell value condition.
                     * @type {number}
                     */
                    cellValueCondition= 11,
                    /** Specifies the area condition.
                     * @type {number}
                     */
                    areaCondition= 12
                }

                /**
                 * Specifies the custom value type.
                 * @enum {number}
                 * @example
                 * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.formulaCondition, {compareType: GC.Spread.Sheets.ConditionalFormatting.CustomValueType.nonEmpty});
                 * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                 * validator.ignoreBlank(false);
                 * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                 * spread.options.highlightInvalidData = true;
                 */
                export enum CustomValueType{
                    /** Indicates whether the cell value is empty or null.
                     * @type {number}
                     */
                    empty= 0,
                    /** Indicates whether the cell value is not empty or null.
                     * @type {number}
                     */
                    nonEmpty= 1,
                    /** Indicates whether the cell value contains a calculation error.
                     * @type {number}
                     */
                    error= 2,
                    /** Indicates whether the cell value does not contain a calculation error.
                     * @type {number}
                     */
                    nonError= 3,
                    /** Indicates whether the cell value is a formula.
                     * @type {number}
                     */
                    formula= 4
                }

                /**
                 * Specifies the position of the data bar's axis.
                 * @enum {number}
                 * @example
                 * //This example creates a data bar rule.
                 * activeSheet.setValue(0,0,1,3);
                 * activeSheet.setValue(1,0,15,3);
                 * activeSheet.setValue(2,0,25,3);
                 * activeSheet.setValue(3,0,-1,3);
                 * var dataBarRule = new GC.Spread.Sheets.ConditionalFormatting.DataBarRule();
                 * dataBarRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                 * dataBarRule.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                 * dataBarRule.minValue(-1);
                 * dataBarRule.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                 * dataBarRule.maxValue(40);
                 * dataBarRule.color("green");
                 * dataBarRule.showBorder(true);
                 * dataBarRule.borderColor("orange");
                 * dataBarRule.dataBarDirection(GC.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                 * dataBarRule.negativeFillColor("yellow");
                 * dataBarRule.useNegativeFillColor(true);
                 * dataBarRule.negativeBorderColor("red");
                 * dataBarRule.useNegativeBorderColor(true);
                 * dataBarRule.axisPosition(GC.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                 * dataBarRule.axisColor("blue");
                 * dataBarRule.showBarOnly(false);
                 * activeSheet.conditionalFormats.addRule(dataBarRule);
                 */
                export enum DataBarAxisPosition{
                    /** Specifies whether to display at a variable position based on negative values.
                     * @type {number}
                     */
                    automatic= 0,
                    /** Specifies whether to display at the cell midpoint.
                     * @type {number}
                     */
                    cellMidPoint= 1,
                    /** Specifies whether to display value bars in the same direction as positive values.
                     * @type {number}
                     */
                    none= 2
                }

                /**
                 * Specifies the date compare type.
                 * @enum {number}
                 * @example
                 * //This example validates cell data.
                 * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.dateCondition, {compareType: GC.Spread.Sheets.ConditionalFormatting.DateCompareType.before, expected: new Date(2012, 11, 31)});
                 * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                 * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.custom);
                 * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                 * spread.options.highlightInvalidData = true;
                 * activeSheet.setValue(0, 0, new Date(2012, 12, 12));
                 */
                export enum DateCompareType{
                    /** Indicates whether the date time is equal to a certain time.
                     * @type {number}
                     */
                    equalsTo= 0,
                    /** Indicates whether the date time is not equal to a certain time.
                     * @type {number}
                     */
                    notEqualsTo= 1,
                    /** Indicates whether the date time is before a certain time.
                     * @type {number}
                     */
                    before= 2,
                    /** Indicates whether the date time is before or equal to a certain time.
                     * @type {number}
                     */
                    beforeEqualsTo= 3,
                    /** Indicates whether the date time is after a certain time.
                     * @type {number}
                     */
                    after= 4,
                    /** Indicates whether the date time is after or equal to a certain time.
                     * @type {number}
                     */
                    afterEqualsTo= 5
                }

                /**
                 * Specifies the date occurring type.
                 * @enum {number}
                 * @example
                 * //This example creates a rule.
                 * var style = new GC.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * var rule = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule(GC.Spread.Sheets.ConditionalFormatting.RuleType.dateOccurringRule, [new GC.Spread.Sheets.Range(0,0,10,1)], style, null, null, null, null, null, GC.Spread.Sheets.ConditionalFormatting.DateOccurringType.nextWeek);
                 * activeSheet.conditionalFormats.addRule(rule);
                 * var d = new Date();
                 * activeSheet.setValue(0, 0, d);
                 * activeSheet.setValue(1, 0, new Date(d.setDate(d.getDate()+1)));
                 * activeSheet.setValue(2, 0, new Date(d.setDate(d.getDate()+5)));
                 * activeSheet.setValue(3, 0,new Date(d.setDate(d.getDate()+6)));
                 * activeSheet.setValue(4, 0,new Date(d.setDate(d.getDate()+7)));
                 * activeSheet.setValue(5, 0, new Date(d.setDate(d.getDate()+8)));
                 */
                export enum DateOccurringType{
                    /** Specifies today.
                     * @type {number}
                     */
                    today= 0,
                    /** Specifies yesterday.
                     * @type {number}
                     */
                    yesterday= 1,
                    /** Specifies tomorrow.
                     * @type {number}
                     */
                    tomorrow= 2,
                    /** Specifies the last seven days.
                     * @type {number}
                     */
                    last7Days= 3,
                    /** Specifies this month.
                     * @type {number}
                     */
                    thisMonth= 4,
                    /** Specifies last month.
                     * @type {number}
                     */
                    lastMonth= 5,
                    /** Specifies next month.
                     * @type {number}
                     */
                    nextMonth= 6,
                    /** Specifies this week.
                     * @type {number}
                     */
                    thisWeek= 7,
                    /** Specifies last week.
                     * @type {number}
                     */
                    lastWeek= 8,
                    /** Specifies next week.
                     * @type {number}
                     */
                    nextWeek= 9,
                    /** Specifies next Quarter.
                     * @type {number}
                     */
                    nextQuarter= 10,
                    /** Specifies this Quarter.
                     * @type {number}
                     */
                    thisQuarter= 11,
                    /** Specifies last Quarter.
                     * @type {number}
                     */
                    lastQuarter= 12,
                    /** Specifies next Year.
                     * @type {number}
                     */
                    nextYear= 13,
                    /** Specifies this Year.
                     * @type {number}
                     */
                    thisYear= 14,
                    /** Specifies last Year.
                     * @type {number}
                     */
                    lastYear= 15
                }

                /**
                 * Specifies the general operator.
                 * @enum {number}
                 * @example
                 * //This example validates a cell value.
                 * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.cellValueCondition);
                 * nCondition.compareType(GC.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators.equalsTo);
                 * nCondition.expected(0);
                 * //When the option is false, the validation fails and the red alert is displayed.
                 * //When the option is true, the blank cell is treated as zero and the validation is successful.
                 * nCondition.treatNullValueAsZero(false);
                 * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                 * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.custom);
                 * validator.ignoreBlank(false);
                 * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                 * spread.options.highlightInvalidData = true;
                 * activeSheet.setValue(0, 0, null);
                 * alert(validator.value2());
                 */
                export enum GeneralComparisonOperators{
                    /** Indicates whether the number is equal to a specified number.
                     * @type {number}
                     */
                    equalsTo= 0,
                    /** Indicates whether the number is not equal to a specified number.
                     * @type {number}
                     */
                    notEqualsTo= 1,
                    /** Indicates whether the number is greater than a specified number.
                     * @type {number}
                     */
                    greaterThan= 2,
                    /** Indicates whether the number is greater than or equal to a specified number.
                     * @type {number}
                     */
                    greaterThanOrEqualsTo= 3,
                    /** Indicates whether the number is less than a specified number.
                     * @type {number}
                     */
                    lessThan= 4,
                    /** Indicates whether the number is less than or equal to a specified number.
                     * @type {number}
                     */
                    lessThanOrEqualsTo= 5
                }

                /**
                 * Specifies the icon set.
                 * @enum {number}
                 * @example
                 * //This example creates a rule.
                 * activeSheet.setValue(0,0,1,3);
                 * activeSheet.setValue(1,0,15,3);
                 * activeSheet.setValue(2,0,25,3);
                 * activeSheet.setValue(3,0,-1,3);
                 * var iconSetRule = new GC.Spread.Sheets.ConditionalFormatting.IconSetRule();
                 * iconSetRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                 * iconSetRule.iconSetType(GC.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights);
                 * var iconCriteria = iconSetRule.iconCriteria();
                 * iconCriteria[0] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 1);
                 * iconCriteria[1] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 10);
                 * iconCriteria[2] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 20);
                 * iconSetRule.reverseIconOrder(false);
                 * iconSetRule.showIconOnly(false);
                 * activeSheet.conditionalFormats.addRule(iconSetRule);
                 */
                export enum IconSetType{
                    /** Specifies three colored arrows.
                     * @type {number}
                     */
                    threeArrowsColored= 0,
                    /** Specifies three gray arrows.
                     * @type {number}
                     */
                    threeArrowsGray= 1,
                    /** Specifies three trangles.
                     * @type {number}
                     */
                    threeTriangles= 2,
                    /** Specifies three stars.
                     * @type {number}
                     */
                    threeStars= 3,
                    /** Specifies three flags.
                     * @type {number}
                     */
                    threeFlags= 4,
                    /** Specifies three traffic lights (unrimmed).
                     * @type {number}
                     */
                    threeTrafficLightsUnrimmed= 5,
                    /** Specifies three traffic lights (rimmed).
                     * @type {number}
                     */
                    threeTrafficLightsRimmed= 6,
                    /** Specifies three signs.
                     * @type {number}
                     */
                    threeSigns= 7,
                    /** Specifies three symbols (circled).
                     * @type {number}
                     */
                    threeSymbolsCircled= 8,
                    /** Specifies three symbols (uncircled).
                     * @type {number}
                     */
                    threeSymbolsUncircled= 9,
                    /** Specifies four colored arrows.
                     * @type {number}
                     */
                    fourArrowsColored= 10,
                    /** Specifies four gray arrows.
                     * @type {number}
                     */
                    fourArrowsGray= 11,
                    /** Specifies four red to black icons.
                     * @type {number}
                     */
                    fourRedToBlack= 12,
                    /** Specifies four ratings.
                     * @type {number}
                     */
                    fourRatings= 13,
                    /** Specifies four traffic lights.
                     * @type {number}
                     */
                    fourTrafficLights= 14,
                    /** Specifies five colored arrows.
                     * @type {number}
                     */
                    fiveArrowsColored= 15,
                    /** Specifies five gray arrows.
                     * @type {number}
                     */
                    fiveArrowsGray= 16,
                    /** Specifies five ratings.
                     * @type {number}
                     */
                    fiveRatings= 17,
                    /** Specifies five quarters.
                     * @type {number}
                     */
                    fiveQuarters= 18,
                    /** Specifies five boxes.
                     * @type {number}
                     */
                    fiveBoxes= 19,
                    /** Specifies no cell icon.
                     * @type {number}
                     */
                    noIcons= 20
                }

                /**
                 * Specifies the icon value type.
                 * @enum {number}
                 * @example
                 * //This example creates a rule.
                 * activeSheet.setValue(0,0,1,3);
                 * activeSheet.setValue(1,0,15,3);
                 * activeSheet.setValue(2,0,25,3);
                 * activeSheet.setValue(3,0,-1,3);
                 * var iconSetRule = new GC.Spread.Sheets.ConditionalFormatting.IconSetRule();
                 * iconSetRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                 * iconSetRule.iconSetType(GC.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights);
                 * var iconCriteria = iconSetRule.iconCriteria();
                 * iconCriteria[0] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 1);
                 * iconCriteria[1] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 10);
                 * iconCriteria[2] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 20);
                 * iconSetRule.reverseIconOrder(false);
                 * iconSetRule.showIconOnly(false);
                 * activeSheet.conditionalFormats.addRule(iconSetRule);
                 */
                export enum IconValueType{
                    /** Indicates whether to return a specified number directly.
                     * @type {number}
                     */
                    number= 1,
                    /** Indicates whether to return the percentage of a cell value in a specified cell range.
                     * @type {number}
                     */
                    percent= 4,
                    /** Indicates whether to return the result of a formula calculation.
                     * @type {number}
                     */
                    formula= 7,
                    /** Indicates whether to return the percentile of a cell value in a specified cell range.
                     * @type {number}
                     */
                    percentile= 5
                }

                /**
                 * Specifies the relation operator.
                 * @enum {number}
                 * @example
                 * //This example validates data.
                 * var condition1 = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.dateCondition, {compareType: GC.Spread.Sheets.ConditionalFormatting.DateCompareType.afterEqualsTo, expected: new Date(2012, 11, 31)});
                 * var condition2 = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.dateCondition, {compareType: GC.Spread.Sheets.ConditionalFormatting.DateCompareType.beforeEqualsTo, expected: new Date(2013, 11, 31)});
                 * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.relationCondition, {compareType: GC.Spread.Sheets.ConditionalFormatting.LogicalOperators.and, item1: condition1, item2: condition2});
                 * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                 * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.custom);
                 * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                 * spread.options.highlightInvalidData = true;
                 * activeSheet.setValue(0, 0, new Date(2012, 11, 25));
                 */
                export enum LogicalOperators{
                    /** Specifies the Or relation.
                     * @type {number}
                     */
                    or= 0,
                    /** Specifies the And relation.
                     * @type {number}
                     */
                    and= 1
                }

                /**
                 * Specifies the quarter type.
                 * @enum {number}
                 */
                export enum QuarterType{
                    /** Indicates the first quarter of a year.
                     * @type {number}
                     */
                    quarter1= 0,
                    /** Indicates the second quarter of a year.
                     * @type {number}
                     */
                    quarter2= 1,
                    /** Indicates the third quarter of a year.
                     * @type {number}
                     */
                    quarter3= 2,
                    /** Indicates the fourth quarter of a year.
                     * @type {number}
                     */
                    quarter4= 3
                }

                /**
                 * Specifies the rule type.
                 * @enum {number}
                 */
                export enum RuleType{
                    /** Specifies the base rule of the condition.
                     * @type {number}
                     */
                    conditionRuleBase= 0,
                    /** Specifies the cell value rule.
                     * @type {number}
                     */
                    cellValueRule= 1,
                    /** Specifies the specific text rule.
                     * @type {number}
                     */
                    specificTextRule= 2,
                    /** Specifies the formula rule.
                     * @type {number}
                     */
                    formulaRule= 3,
                    /** Specifies the date occurring rule.
                     * @type {number}
                     */
                    dateOccurringRule= 4,
                    /** Specifies the top 10 rule.
                     * @type {number}
                     */
                    top10Rule= 5,
                    /** Specifies the unique rule.
                     * @type {number}
                     */
                    uniqueRule= 6,
                    /** Specifies the duplicate rule.
                     * @type {number}
                     */
                    duplicateRule= 7,
                    /** Specifies the average rule.
                     * @type {number}
                     */
                    averageRule= 8,
                    /** Specifies the two scale rule.
                     * @type {number}
                     */
                    twoScaleRule= 10,
                    /** Specifies the three scale rule.
                     * @type {number}
                     */
                    threeScaleRule= 11,
                    /** Specifies the data bar rule.
                     * @type {number}
                     */
                    dataBarRule= 12,
                    /** Specifies the icon set rule.
                     * @type {number}
                     */
                    iconSetRule= 13
                }

                /**
                 * Specifies the scale value type.
                 * @enum {number}
                 * @example
                 * //This example creates a data bar rule.
                 * activeSheet.setValue(0,0,1,3);
                 * activeSheet.setValue(1,0,15,3);
                 * activeSheet.setValue(2,0,25,3);
                 * activeSheet.setValue(3,0,-1,3);
                 * var dataBarRule = new GC.Spread.Sheets.ConditionalFormatting.DataBarRule();
                 * dataBarRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                 * dataBarRule.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                 * dataBarRule.minValue(-1);
                 * dataBarRule.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                 * dataBarRule.maxValue(40);
                 * dataBarRule.color("green");
                 * dataBarRule.showBorder(true);
                 * dataBarRule.borderColor("orange");
                 * dataBarRule.dataBarDirection(GC.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                 * dataBarRule.negativeFillColor("yellow");
                 * dataBarRule.useNegativeFillColor(true);
                 * dataBarRule.negativeBorderColor("red");
                 * dataBarRule.useNegativeBorderColor(true);
                 * dataBarRule.axisPosition(GC.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                 * dataBarRule.axisColor("blue");
                 * dataBarRule.showBarOnly(false);
                 * activeSheet.conditionalFormats.addRule(dataBarRule);
                 */
                export enum ScaleValueType{
                    /** Indicates whether to return a specified number directly.
                     * @type {number}
                     */
                    number= 0,
                    /** Indicates whether to return the lowest value in a specified cell range.
                     * @type {number}
                     */
                    lowestValue= 1,
                    /** Indicates whether to return the highest value in a specified cell range.
                     * @type {number}
                     */
                    highestValue= 2,
                    /** Indicates whether to return the percentage of a cell value in a specified cell range.
                     * @type {number}
                     */
                    percent= 3,
                    /** Indicates whether to return the percentile of a cell value in a specified cell range.
                     * @type {number}
                     */
                    percentile= 4,
                    /** Indicates whether to return the automatic minimum value in a specified range.
                     * @type {number}
                     */
                    automin= 5,
                    /** Indicates whether to return the result of a formula calculation.
                     * @type {number}
                     */
                    formula= 6,
                    /** Indicates whether to return the automatic maximum value in a specified range.
                     * @type {number}
                     */
                    automax= 7
                }

                /**
                 * Specifies the text compare type.
                 * @enum {number}
                 * @example
                 * //This example uses the TextCompareType enumeration.
                 * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.textCondition, {compareType: GC.Spread.Sheets.ConditionalFormatting.TextCompareType.contains, expected: "test"});
                 * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                 * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.custom);
                 * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                 * spread.options.highlightInvalidData = true;
                 * activeSheet.setValue(0, 0, "testing");
                 * //Type text in 0,0 that does not contain "test" to see invalid symbol
                 */
                export enum TextCompareType{
                    /** Indicates whether the string is equal to a specified string.
                     * @type {number}
                     */
                    equalsTo= 0,
                    /** Indicates whether the string is not equal to a specified string.
                     * @type {number}
                     */
                    notEqualsTo= 1,
                    /** Indicates whether the string starts with a specified string.
                     * @type {number}
                     */
                    beginsWith= 2,
                    /** Indicates whether the string does not start with a specified string.
                     * @type {number}
                     */
                    doesNotBeginWith= 3,
                    /** Indicates whether the string ends with a specified string.
                     * @type {number}
                     */
                    endsWith= 4,
                    /** Indicates whether the string does not end with a specified string.
                     * @type {number}
                     */
                    doesNotEndWith= 5,
                    /** Indicates whether the string contains a specified string.
                     * @type {number}
                     */
                    contains= 6,
                    /** Indicates whether the string does not contain a specified string.
                     * @type {number}
                     */
                    doesNotContain= 7
                }

                /**
                 * Specifies the text comparison operator.
                 * @enum {number}
                 * @example
                 * //This example creates a rule.
                 * var style = new GC.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * var ranges=[new GC.Spread.Sheets.Range(0,0,10,1)];
                 * activeSheet.conditionalFormats.addSpecificTextRule(GC.Spread.Sheets.ConditionalFormatting.TextComparisonOperators.contains, "test", style, ranges);
                 * activeSheet.setValue(0, 0, "testing");
                 * activeSheet.setValue(1, 0, "test");
                 * activeSheet.setValue(2, 0, "a");
                 * activeSheet.setValue(3, 0, "t");
                 */
                export enum TextComparisonOperators{
                    /** Determines whether a cell value contains the parameter value.
                     * @type {number}
                     */
                    contains= 0,
                    /** Determines whether a cell value does not contain the parameter value.
                     * @type {number}
                     */
                    doesNotContain= 1,
                    /** Determines whether a cell value begins with the parameter value.
                     * @type {number}
                     */
                    beginsWith= 2,
                    /** Determines whether a cell value ends with the parameter value.
                     * @type {number}
                     */
                    endsWith= 3
                }

                /**
                 * Specifies the top 10 condition type.
                 * @enum {number}
                 * @example
                 * //This example uses the Top10ConditionType enumeration.
                 * var style = new GC.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * var ranges=[new GC.Spread.Sheets.Range(0,0,10,1)];
                 * activeSheet.conditionalFormats.addTop10Rule(GC.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top, 2, style, ranges);
                 * activeSheet.setValue(0, 0, 1);
                 * activeSheet.setValue(1, 0, 50);
                 * activeSheet.setValue(2, 0, 11);
                 * activeSheet.setValue(3, 0, 5);
                 */
                export enum Top10ConditionType{
                    /** Specifies the top condition.
                     * @type {number}
                     */
                    top= 0,
                    /** Specifies the bottom condition.
                     * @type {number}
                     */
                    bottom= 1
                }


                export class Condition{
                    /**
                     * Represents a conditional item using the parameter object.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.ConditionType} conditionType
                     * @param {Object} args
                     * @constructor
                     * @example
                     * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.averageCondition, {compareType: GC.Spread.Sheets.ConditionalFormatting.AverageConditionType.above});
                     * nCondition.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 3)]);
                     * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, 5);
                     * activeSheet.setValue(1, 0, 15);
                     */
                    constructor(conditionType:  ConditionType,  args:  Object);
                    /**
                     * Gets or sets the rule compare type.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.LogicalOperators | GC.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators | GC.Spread.Sheets.ConditionalFormatting.TextCompareType | GC.Spread.Sheets.ConditionalFormatting.ColorCompareType | GC.Spread.Sheets.ConditionalFormatting.DateCompareType} value The rule compare type.
                     * @returns {GC.Spread.Sheets.ConditionalFormatting.LogicalOperators | GC.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators | GC.Spread.Sheets.ConditionalFormatting.TextCompareType | GC.Spread.Sheets.ConditionalFormatting.ColorCompareType | GC.Spread.Sheets.ConditionalFormatting.DateCompareType | GC.Spread.Sheets.ConditionalFormatting.Condition} If no value is set, returns the rule compare type; otherwise, returns the condition.
                     * @example
                     * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.textCondition);
                     * nCondition.compareType(GC.Spread.Sheets.ConditionalFormatting.TextCompareType.contains);
                     * nCondition.expected("test");
                     * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, "testing");
                     */
                    compareType(value?:  any): any;
                    /**
                     * Evaluates the condition using the specified evaluator.
                     * @param {object} evaluator The evaluator that can evaluate an expression or a function.
                     * @param {number} baseRow The base row index for evaluation.
                     * @param {number} baseColumn The base column index for evaluation.
                     * @param {object} actualObj The actual value of object1 for evaluation.
                     * @returns {boolean} <c>true</c> if the result is successful; otherwise, <c>false</c>.
                     */
                    evaluate(evaluator:  Object,  baseRow:  number,  baseColumn:  number,  actualObj:  Object): boolean;
                    /**
                     * Gets or sets the expected value.
                     * @param {object} value The expected value.
                     * @returns {object | GC.Spread.Sheets.ConditionalFormatting.Condition} If no value is set, returns the expected value; otherwise, returns the condition.
                     * @example
                     * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.dateCondition);
                     * nCondition.compareType(GC.Spread.Sheets.ConditionalFormatting.DateCompareType.before);
                     * nCondition.expected(new Date(2012, 11, 31));
                     * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, new Date(2012, 12, 12));
                     */
                    expected(value?:  any): any;
                    /**
                     * Gets or sets the expected formula.
                     * @param {string | number} formulaOrBaseRow The expected formula or base row.
                     * @param {number} baseColumn The base column.
                     * @returns {string | GC.Spread.Sheets.ConditionalFormatting.Condition} If no value is set or baseRow and baseColumn is set, returns the expected formula; otherwise, returns the condition.
                     * @example
                     * var textLengthCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.textLengthCondition);
                     * textLengthCondition.compareType(GC.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators.greaterThan);
                     * textLengthCondition.formula("$C$1"); // formula used to calculate a number.
                     * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(textLengthCondition);
                     * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, "abcf");
                     * //Set value 3 to $C$1, after this code, the value in Cell(0,0) is valid.
                     * activeSheet.setValue(0, 2, 3);
                     * //Set value 5 to $C$1, after this code, the value in Cel(0,0) is invalid.
                     * // activeSheet.setValue(0, 2, 5);
                     */
                    formula(formulaOrBaseRow?:  string | number,  baseColumn ?:  number): any;
                    /**
                     * Creates a date extend condition object from the specified day.
                     * @static
                     * @param {number} day The day.
                     * @returns {GC.Spread.Sheets.ConditionalFormatting.Condition} A date extend condition object.
                     */
                    static fromDay(day:  number): GC.Spread.Sheets.ConditionalFormatting.Condition;
                    /**
                     * Creates the area condition from formula data.
                     * @static
                     * @param {string} formula The formula that specifies a range that contains data items.
                     * @returns {GC.Spread.Sheets.ConditionalFormatting.Condition} The area condition.
                     */
                    static fromFormula(formula:  string): GC.Spread.Sheets.ConditionalFormatting.Condition;
                    /**
                     * Creates a date extend condition object from the specified month.
                     * @static
                     * @param {number} month The month. The first month is 0.
                     * @returns {GC.Spread.Sheets.ConditionalFormatting.Condition} A date extend condition object.
                     */
                    static fromMonth(month:  number): GC.Spread.Sheets.ConditionalFormatting.Condition;
                    /**
                     * Creates a date extend condition object from the specified quarter.
                     * @static
                     * @param {GC.Spread.Sheets.ConditionalFormatting.QuarterType} quarter The quarter.
                     * @returns {GC.Spread.Sheets.ConditionalFormatting.Condition} A date extend condition object.
                     */
                    static fromQuarter(quarter:  QuarterType): GC.Spread.Sheets.ConditionalFormatting.Condition;
                    /**
                     * Creates the area condition from source data.
                     * @static
                     * @param {string} expected The expected source that separates each data item with a comma (",").
                     * @returns {GC.Spread.Sheets.ConditionalFormatting.Condition} The area condition.
                     */
                    static fromSource(expected:  string): GC.Spread.Sheets.ConditionalFormatting.Condition;
                    /**
                     * Creates a date extend condition object from the specified week.
                     * @static
                     * @param {number} week The week.
                     * @returns {GC.Spread.Sheets.ConditionalFormatting.Condition} A date extend condition object.
                     */
                    static fromWeek(week:  number): GC.Spread.Sheets.ConditionalFormatting.Condition;
                    /**
                     * Creates a date extend condition object from the specified year.
                     * @static
                     * @param {number} year The year.
                     * @returns {GC.Spread.Sheets.ConditionalFormatting.Condition} A date extend condition object.
                     */
                    static fromYear(year:  number): GC.Spread.Sheets.ConditionalFormatting.Condition;
                    /**
                     * Gets the expected value.
                     * @constructor
                     * @param {object} evaluator The evaluator that can evaluate an expression or a function.
                     * @param {number} baseRow The base row index for evaluation.
                     * @param {number} baseColumn The base column index for evaluation.
                     * @returns {object} The expected value.
                     */
                    getExpected(evaluator:  Object,  baseRow:  number,  baseColumn:  number): Object;
                    /**
                     * Returns the list of valid data items.
                     * @param {object} evaluator The evaluator that can evaluate an expression or a function.
                     * @param {number} baseRow The base row index for evaluation.
                     * @param {number} baseColumn The base column index for evaluation.
                     * @returns {Array} The list of valid data items.
                     */
                    getValidList(evaluator:  Object,  baseRow:  number,  baseColumn:  number): any[];
                    /**
                     * Gets or sets whether to ignore the blank cell.
                     * @param {boolean} value Whether to ignore the blank cell.
                     * @returns {boolean | GC.Spread.Sheets.ConditionalFormatting.Condition} If no value is set, returns whether to ignore the blank cell; otherwise, returns the condition.
                     * @example
                     * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.textCondition);
                     * nCondition.compareType(GC.Spread.Sheets.ConditionalFormatting.TextCompareType.contains);
                     * nCondition.expected("te?t");
                     * nCondition.ignoreBlank(true);
                     * nCondition.ignoreCase(true);
                     * nCondition.useWildCards(true);
                     * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, "testing");
                     */
                    ignoreBlank(value?:  boolean): any;
                    /**
                     * Gets or sets whether to ignore case when performing the comparison.
                     * @param {boolean} value Whether to ignore case when performing the comparison.
                     * @returns {boolean | GC.Spread.Sheets.ConditionalFormatting.Condition} If no value is set, returns whether to ignore case when performing the comparison; otherwise, returns the condition.
                     * @example
                     * //This example creates a text condition.
                     * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.textCondition);
                     * nCondition.compareType(GC.Spread.Sheets.ConditionalFormatting.TextCompareType.contains);
                     * nCondition.expected("te?t");
                     * nCondition.ignoreBlank(true);
                     * nCondition.ignoreCase(true);
                     * nCondition.useWildCards(true);
                     * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, "testing");
                     */
                    ignoreCase(value?:  boolean): any;
                    /**
                     * Gets or sets the first condition.
                     * @param {object} value The first condition.
                     * @returns {object | GC.Spread.Sheets.ConditionalFormatting.Condition} If no value is set, returns the first condition; otherwise, returns the relation condition.
                     * @example
                     * //This example validates a date.
                     * var condition1 = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.dateCondition, {compareType: GC.Spread.Sheets.ConditionalFormatting.DateCompareType.afterEqualsTo, expected: new Date(2012, 11, 31)});
                     * var condition2 = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.dateCondition, {compareType: GC.Spread.Sheets.ConditionalFormatting.DateCompareType.beforeEqualsTo, expected: new Date(2013, 11, 31)});
                     * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.relationCondition);
                     * nCondition.compareType(GC.Spread.Sheets.ConditionalFormatting.LogicalOperators.and);
                     * nCondition.item1(condition1);
                     * nCondition.item2(condition2);
                     * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, new Date(2012, 11, 25));
                     */
                    item1(value?:  Object): any;
                    /**
                     * Gets or sets the second condition.
                     * @param {object} value The second condition.
                     * @returns {object | GC.Spread.Sheets.ConditionalFormatting.Condition} If no value is set, returns the second condition; otherwise, returns the relation condition.
                     * @example
                     * //This example validates a date.
                     * var condition1 = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.dateCondition, {compareType: GC.Spread.Sheets.ConditionalFormatting.DateCompareType.afterEqualsTo, expected: new Date(2012, 11, 31)});
                     * var condition2 = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.dateCondition, {compareType: GC.Spread.Sheets.ConditionalFormatting.DateCompareType.beforeEqualsTo, expected: new Date(2013, 11, 31)});
                     * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.relationCondition);
                     * nCondition.compareType(GC.Spread.Sheets.ConditionalFormatting.LogicalOperators.and);
                     * nCondition.item1(condition1);
                     * nCondition.item2(condition2);
                     * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, new Date(2012, 11, 25));
                     */
                    item2(value?:  Object): any;
                    /**
                     * Gets or sets the condition ranges.
                     * @param {Array.<GC.Spread.Sheets.Range>} value The condition ranges.
                     * @returns {Array.<GC.Spread.Sheets.Range> | GC.Spread.Sheets.ConditionalFormatting.Condition} If no value is set, returns the condition ranges; otherwise, returns the condition.
                     * @example
                     * //This example creates a unique condition.
                     * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.uniqueCondition);
                     * nCondition.expected(true);
                     * nCondition.ranges([new GC.Spread.Sheets.Range(0, 0, 5, 1)]);
                     * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, 5);
                     */
                    ranges(value?:  GC.Spread.Sheets.Range[]): any;
                    /**
                     * Resets this instance.
                     * @example
                     * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.numberCondition);
                     * nCondition.compareType(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                     * nCondition.expected(5);
                     * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, 5);
                     * //Create a button
                     * $("#button1").click(function () {
                     * activeSheet.suspendPaint();
                     * nCondition.reset();
                     * activeSheet.resumePaint();
                     *     });
                     */
                    reset(): void;
                    /**
                     * Gets or sets whether to treat the null value in a cell as zero.
                     * @param {boolean} value Whether to treat the null value in a cell as zero.
                     * @returns {boolean | GC.Spread.Sheets.ConditionalFormatting.Condition} If no value is set, returns whether to treat the null value in a cell as zero; otherwise, returns the condition.
                     * @example
                     * //This example sets the treatNullValueAsZero method.
                     * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.cellValueCondition);
                     * nCondition.compareType(GC.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators.equalsTo);
                     * nCondition.expected(0);
                     * //When the option is false, the validation fails and the red alert is displayed.
                     * //When the option is true, the blank cell is treated as zero and the validation is successful.
                     * nCondition.treatNullValueAsZero(false);
                     * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * validator.ignoreBlank(false);
                     * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, null);
                     */
                    treatNullValueAsZero(value?:  boolean): any;
                    /**
                     * Gets or sets whether to compare strings using wildcards.
                     * @param {boolean} value Whether to compare strings using wildcards.
                     * @returns {boolean | GC.Spread.Sheets.ConditionalFormatting.Condition} If no value is set, returns whether to compare strings using wildcards; otherwise, returns the condition.
                     * @example
                     * //This example allows wildcards.
                     * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.textCondition);
                     * nCondition.compareType(GC.Spread.Sheets.ConditionalFormatting.TextCompareType.contains);
                     * nCondition.expected("te?t");
                     * nCondition.ignoreBlank(true);
                     * nCondition.ignoreCase(true);
                     * nCondition.useWildCards(true);
                     * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, "testing");
                     */
                    useWildCards(value?:  boolean): any;
                }

                export class ConditionalFormats{
                    /**
                     * Represents a format condition class.
                     * @class
                     * @param {object} worksheet The sheet.
                     */
                    constructor(worksheet:  GC.Spread.Sheets.Worksheet);
                    /**
                     * Adds the two scale rule to the rule collection.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.ScaleValueType} minType The minimum scale type.
                     * @param {object} minValue The minimum scale value.
                     * @param {string} minColor The minimum scale color.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.ScaleValueType} maxType The maximum scale type.
                     * @param {object} maxValue The maximum scale value.
                     * @param {string} maxColor The maximum scale color.
                     * @param {Array.<GC.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GC.Spread.Sheets.Range.
                     * @returns {object} The two scale rule added to the rule collection.
                     * @example
                     * //This example uses the add2ScaleRule method.
                     * activeSheet.conditionalFormats.add2ScaleRule(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number,10,"Red",GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number,100,"Yellow", [new GC.Spread.Sheets.Range(0,0,10,3)]);
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     */
                    add2ScaleRule(minType:  ScaleValueType,  minValue:  Object,  minColor:  string,  maxType:  ScaleValueType,  maxValue:  Object,  maxColor:  string,  ranges:  GC.Spread.Sheets.Range[]): Object;
                    /**
                     * Adds the three scale rule to the rule collection.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.ScaleValueType} minType The minimum scale type.
                     * @param {object} minValue The minimum scale value.
                     * @param {string} minColor The minimum scale color.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.ScaleValueType} midType The midpoint scale type.
                     * @param {object} midValue The midpoint scale value.
                     * @param {string} midColor The midpoint scale color.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.ScaleValueType} maxType The maximum scale type.
                     * @param {object} maxValue The maximum scale value.
                     * @param {string} maxColor The maximum scale color.
                     * @param {Array.<GC.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GC.Spread.Sheets.Range.
                     * @returns {object} The three scale rule added to the rule collection.
                     * @example
                     * //This example uses the add3ScaleRule method.
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     * activeSheet.conditionalFormats.add3ScaleRule(1, 10, "red", 0, 50, "blue",2, 100, "yellow", [new GC.Spread.Sheets.Range(0, 0, 10, 3)]);
                     */
                    add3ScaleRule(minType:  ScaleValueType,  minValue:  Object,  minColor:  string,  midType:  ScaleValueType,  midValue:  Object,  midColor:  string,  maxType:  ScaleValueType,  maxValue:  Object,  maxColor:  string,  ranges:  GC.Spread.Sheets.Range[]): Object;
                    /**
                     * Adds an average rule to the rule collection.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.AverageConditionType} type The average condition type.
                     * @param {GC.Spread.Sheets.Style} style The style that is applied to the cell when the condition is met.
                     * @param {Array.<GC.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GC.Spread.Sheets.Range.
                     * @returns {object} The average rule added to the rule collection.
                     * @example
                     * //This example uses the addAverageRule method.
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     * activeSheet.setValue(3,0, 2,3);
                     * activeSheet.setValue(4,0, 60,3);
                     * activeSheet.setValue(5,0, 90,3);
                     * activeSheet.setValue(6,0, 3,3);
                     * activeSheet.setValue(7,0, 40,3);
                     * activeSheet.setValue(8,0, 70,3);
                     * activeSheet.setValue(9,0, 5,3);
                     * activeSheet.setValue(10,0, 35,3);
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * style.borderLeft =new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                     * style.borderTop = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                     * style.borderRight = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                     * style.borderBottom = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                     * activeSheet.conditionalFormats.addAverageRule(GC.Spread.Sheets.ConditionalFormatting.AverageConditionType.above,style,[new GC.Spread.Sheets.Range(0, 0, 10, 3)]);
                     */
                    addAverageRule(type:  AverageConditionType,  style:  GC.Spread.Sheets.Style,  ranges:  GC.Spread.Sheets.Range[]): Object;
                    /**
                     * Adds the cell value rule to the rule collection.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators} comparisionOperator The comparison operator.
                     * @param {object} value1 The first value.
                     * @param {object} value2 The second value.
                     * @param {GC.Spread.Sheets.Style} style The style that is applied to the cell when the condition is met.
                     * @param {Array.<GC.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GC.Spread.Sheets.Range.
                     * @returns {object} The cell value rule added to the rule collection.
                     * @example
                     * //This example uses the addCellValueRule method.
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var ranges=[new GC.Spread.Sheets.Range(0,0,5,1)];
                     * activeSheet.conditionalFormats.addCellValueRule(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between, 2, 100, style, ranges);
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,45,3);
                     */
                    addCellValueRule(comparisionOperator:  ComparisonOperators,  value1:  Object,  value2:  Object,  style:  GC.Spread.Sheets.Style,  ranges:  GC.Spread.Sheets.Range[]): Object;
                    /**
                     * Adds a data bar rule to the rule collection.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.ScaleValueType} minType The minimum scale type.
                     * @param {object} minValue The minimum scale value.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.ScaleValueType} maxType The maximum scale type.
                     * @param {object} maxValue The maximum scale value.
                     * @param {string} color The color data bar to show on the view.
                     * @param {Array.<GC.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GC.Spread.Sheets.Range.
                     * @returns {object} The data bar rule added to the rule collection.
                     * @example
                     * //This example uses the addDataBarRule method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * activeSheet.conditionalFormats.addDataBarRule(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number, -1, GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number, 40, "orange", [new GC.Spread.Sheets.Range(0,0,4,1)]);
                     */
                    addDataBarRule(minType:  ScaleValueType,  minValue:  Object,  maxType:  ScaleValueType,  maxValue:  Object,  color:  string,  ranges:  GC.Spread.Sheets.Range[]): Object;
                    /**
                     * Adds the date occurring rule to the rule collection.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.DateOccurringType} type The data occurring type.
                     * @param {GC.Spread.Sheets.Style} style The style that is applied to the cell when the condition is met.
                     * @param {Array.<GC.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GC.Spread.Sheets.Range.
                     * @returns {object} The date occurring rule added to the rule collection.
                     * @example
                     * //This example uses the addDateOccurringRule method.
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var d = new Date();
                     * activeSheet.setValue(0, 0, d);
                     * activeSheet.setValue(1, 0, new Date(d.setDate(d.getDate()+1)));
                     * activeSheet.setValue(2, 0, new Date(d.setDate(d.getDate()+5)));
                     * activeSheet.setValue(3, 0,new Date(d.setDate(d.getDate()+6)));
                     * activeSheet.setValue(4, 0,new Date(d.setDate(d.getDate()+7)));
                     * activeSheet.setValue(5, 0, new Date(d.setDate(d.getDate()+8)));
                     * activeSheet.conditionalFormats.addDateOccurringRule(GC.Spread.Sheets.ConditionalFormatting.DateOccurringType.nextWeek, style, [new GC.Spread.Sheets.Range(0,0,10,1)]);
                     */
                    addDateOccurringRule(type:  DateOccurringType,  style:  GC.Spread.Sheets.Style,  ranges:  GC.Spread.Sheets.Range[]): Object;
                    /**
                     * Adds a duplicate rule to the rule collection.
                     * @param {GC.Spread.Sheets.Style} style The style that is applied to the cell when the condition is met.
                     * @param {Array.<GC.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GC.Spread.Sheets.Range.
                     * @returns {object} The duplicate rule added to the rule collection.
                     * @example
                     * //This example uses the addDuplicateRule method.
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "yellow";
                     * var ranges=[new GC.Spread.Sheets.Range(0,0,10,1)];
                     * activeSheet.conditionalFormats.addDuplicateRule(style, ranges);
                     * activeSheet.setValue(0, 0, 50);
                     * activeSheet.setValue(1, 0, 50);
                     * activeSheet.setValue(2, 0, 11);
                     * activeSheet.setValue(3, 0, 5);
                     */
                    addDuplicateRule(style:  GC.Spread.Sheets.Style,  ranges:  GC.Spread.Sheets.Range[]): Object;
                    /**
                     * Adds the formula rule to the rule collection.
                     * @param {string} formula The condition formula.
                     * @param {GC.Spread.Sheets.Style} style The style that is applied to the cell when the condition is met.
                     * @param {Array.<GC.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GC.Spread.Sheets.Range.
                     * @returns {object} The formula rule added to the rule collection.
                     * @example
                     * //This example uses the addFormulaRule method.
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var ranges = [new GC.Spread.Sheets.Range(0, 0, 2, 1)];
                     * activeSheet.conditionalFormats.addFormulaRule("=A1=B1+C1", style, ranges);
                     * activeSheet.setValue(0, 0, 2,3);
                     * activeSheet.setValue(0, 1, 1,3);
                     * activeSheet.setValue(0, 2,1,3);
                     * activeSheet.setValue(1, 0, 1,3);
                     */
                    addFormulaRule(formula:  string,  style:  GC.Spread.Sheets.Style,  ranges:  GC.Spread.Sheets.Range[]): Object;
                    /**
                     * Adds an icon set rule to the rule collection.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.IconSetType} iconSetTye The type of icon set.
                     * @param {Array.<GC.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GC.Spread.Sheets.Range.
                     * @returns {object} The icon set rule added to the rule collection.
                     * @example
                     * //This example uses the addIconSetRule method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * activeSheet.conditionalFormats.addIconSetRule(GC.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights, [new GC.Spread.Sheets.Range(0,0,4,1)]);
                     */
                    addIconSetRule(iconSetTye:  IconSetType,  ranges:  GC.Spread.Sheets.Range[]): Object;
                    /**
                     * Adds the rule.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} rule The rule to add.
                     * @example
                     * //This example uses the addRule method.
                     * var scale = new GC.Spread.Sheets.ConditionalFormatting.ScaleRule();
                     * scale.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.threeScaleRule);
                     * scale.midColor("red");
                     * scale.midType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.midValue(50);
                     * scale.maxColor("blue");
                     * scale.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.maxValue(100);
                     * scale.minColor("yellow");
                     * scale.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.minValue(10);
                     * scale.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 3)]);
                     * activeSheet.conditionalFormats.addRule(scale);
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     */
                    addRule(rule:  ConditionRuleBase): void;
                    /**
                     * Adds the text rule to the rule collection.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.TextComparisonOperators} comparisonOperator The comparison operator.
                     * @param {string} text The text for comparison.
                     * @param {GC.Spread.Sheets.Style} style The style that is applied to the cell when the condition is met.
                     * @param {Array.<GC.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied to items whose item type is GC.Spread.Sheets.Range.
                     * @returns {object} The text rule added to the rule collection.
                     * @example
                     * //This example uses the addSpecificTextRule method.
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var ranges=[new GC.Spread.Sheets.Range(0,0,10,1)];
                     * activeSheet.conditionalFormats.addSpecificTextRule(GC.Spread.Sheets.ConditionalFormatting.TextComparisonOperators.contains, "test", style, ranges);
                     * activeSheet.setValue(0, 0, "testing");
                     * activeSheet.setValue(1, 0, "test");
                     * activeSheet.setValue(2, 0, "a");
                     * activeSheet.setValue(3, 0, "t");
                     */
                    addSpecificTextRule(comparisionOperator:  TextComparisonOperators,  text:  string,  style:  GC.Spread.Sheets.Style,  ranges:  GC.Spread.Sheets.Range[]): Object;
                    /**
                     * Adds the top 10 rule or bottom 10 rule to the collection based on the Top10CondtionType object.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.Top10ConditionType} type The top 10 condition.
                     * @param {number} rank The number of top or bottom items to apply the style to.
                     * @param {GC.Spread.Sheets.Style} style The style that is applied to the cell when the condition is met.
                     * @param {Array.<GC.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GC.Spread.Sheets.Range.
                     * @returns {object} The top 10 rule added to the rule collection.
                     * @example
                     * //This example uses the addTop10Rule method.
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var ranges=[new GC.Spread.Sheets.Range(0,0,10,1)];
                     * activeSheet.conditionalFormats.addTop10Rule(GC.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top, 2, style, ranges);
                     * activeSheet.setValue(0, 0, 1);
                     * activeSheet.setValue(1, 0, 50);
                     * activeSheet.setValue(2, 0, 11);
                     * activeSheet.setValue(3, 0, 5);
                     */
                    addTop10Rule(type:  Top10ConditionType,  rank:  number,  style:  GC.Spread.Sheets.Style,  ranges:  GC.Spread.Sheets.Range[]): Object;
                    /**
                     * Adds a unique rule to the rule collection.
                     * @param {GC.Spread.Sheets.Style} style The style that is applied to the cell when the condition is met.
                     * @param {Array.<GC.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GC.Spread.Sheets.Range.
                     * @returns {object} The unique rule added to the rule collection.
                     * @example
                     * //This example uses the addUniqueRule method.
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "green";
                     * activeSheet.setValue(0, 0, 50);
                     * activeSheet.setValue(1, 0, 50);
                     * activeSheet.setValue(2, 0, 11);
                     * activeSheet.setValue(3, 0, 5);
                     * activeSheet.conditionalFormats.addUniqueRule(style, [new GC.Spread.Sheets.Range(0,0,10,1)]);
                     */
                    addUniqueRule(style:  GC.Spread.Sheets.Style,  ranges:  GC.Spread.Sheets.Range[]): Object;
                    /**
                     * Removes all rules.
                     * @example
                     * //This example uses the clearRule method.
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     * activeSheet.conditionalFormats.add2ScaleRule(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number, 10, "red", GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number, 100, "yellow", [new GC.Spread.Sheets.Range(0, 0, 10, 3)]);
                     * // Remove comment in front of method to test
                     * //activeSheet.conditionalFormats.clearRule();
                     */
                    clearRule(): void;
                    /**
                     * Determines whether the specified cell contains a specified rule.
                     * @param {object} rule The rule for which to check.
                     * @param {number} row The row index.
                     * @param {number} column The column index.
                     * @returns {boolean} <c>true</c> if the specified cell contains a specified rule; otherwise, <c>false</c>.
                     * @example
                     * //This example checks to see if a cell has a specified rule.
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var rule = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * rule.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * rule.ranges([new GC.Spread.Sheets.Range(0,0,5,1)]);
                     * rule.operator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between);
                     * rule.style(style);
                     * rule.value1(2);
                     * rule.value2(100);
                     * activeSheet.conditionalFormats.addRule(rule);
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,45,3);
                     * var ruletest = activeSheet.conditionalFormats.containsRule(rule, 0, 0);
                     * alert(ruletest);
                     */
                    containsRule(rule:  Object,  row:  number,  column:  number): boolean;
                    /**
                     * Gets the number of rule objects in the collection.
                     * @returns {number} The number of rule objects in the collection.
                     * @example
                     * //This example counts the rules.
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var rule = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * rule.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * rule.ranges([new GC.Spread.Sheets.Range(0,0,5,1)]);
                     * rule.operator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between);
                     * rule.style(style);
                     * rule.value1(2);
                     * rule.value2(100);
                     * activeSheet.conditionalFormats.addRule(rule);
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,45,3);
                     * var ruletest = activeSheet.conditionalFormats.count();
                     * alert(ruletest);
                     */
                    count(): number;
                    /**
                     * Gets the rule using the index.
                     * @param {number} index The index from which to get the rule.
                     * @returns {GC.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} The rule from the index.
                     * @example
                     * //This example uses the getRule method.
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var rule = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * rule.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * rule.ranges([new GC.Spread.Sheets.Range(0,0,5,1)]);
                     * rule.operator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between);
                     * rule.style(style);
                     * rule.value1(2);
                     * rule.value2(100);
                     * activeSheet.conditionalFormats.addRule(rule);
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,45,3);
                     * var ruletest = activeSheet.conditionalFormats.getRule(0);
                     * alert(ruletest.value1());
                     */
                    getRule(index:  number): ConditionRuleBase;
                    /**
                     * Gets the conditional rules from the cell at the specified row and column.
                     * @param {number} row The row index.
                     * @param {number} column The column index.
                     * @returns {Array.<GC.Spread.Sheets.ConditionalFormatting.ConditionRuleBase>} The conditional rules.
                     * @example
                     * //This example uses the getRules method.
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var rule = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * rule.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * rule.ranges([new GC.Spread.Sheets.Range(0,0,5,1)]);
                     * rule.operator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between);
                     * rule.style(style);
                     * rule.value1(2);
                     * rule.value2(100);
                     * activeSheet.conditionalFormats.addRule(rule);
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,45,3);
                     * var ruletest = activeSheet.conditionalFormats.getRules();
                     * alert(ruletest[0].style().backColor);
                     */
                    getRules(row:  number,  column:  number): ConditionRuleBase[];
                    /**
                     * Removes a rule object from the ConditionalFormats object.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} rule The rule object to remove from the ConditionalFormats object.
                     * @example
                     * //This example uses the removeRule method.
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var rule = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * rule.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * rule.ranges([new GC.Spread.Sheets.Range(0,0,5,1)]);
                     * rule.operator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between);
                     * rule.style(style);
                     * rule.value1(2);
                     * rule.value2(100);
                     * activeSheet.conditionalFormats.addRule(rule);
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,45,3);
                     * activeSheet.conditionalFormats.removeRule(rule);
                     */
                    removeRule(rule:  ConditionRuleBase): void;
                    /**
                     * Removes the rules from a specified cell range.
                     * @param {number} row The row index of the first cell in the range.
                     * @param {number} column The column index of the first cell in the range.
                     * @param {number} rowCount The number of rows in the range.
                     * @param {number} columnCount The number of columns in the range.
                     * @example
                     * //This example uses the removeRuleByRange method.
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var rule = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * rule.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * rule.ranges([new GC.Spread.Sheets.Range(0,0,5,1)]);
                     * rule.operator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between);
                     * rule.style(style);
                     * rule.value1(2);
                     * rule.value2(100);
                     * activeSheet.conditionalFormats.addRule(rule);
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,45,3);
                     * activeSheet.conditionalFormats.removeRuleByRange(0, 0, 5, 1);
                     */
                    removeRuleByRange(row:  number,  column:  number,  rowCount:  number,  columnCount:  number): void;
                }

                export class ConditionRuleBase{
                    /**
                     * Represents a formatting base rule class as the specified style.
                     * @param ruleType
                     * @param {GC.Spread.Sheets.Style} style The style for the rule.
                     * @param {Array.<GC.Spread.Sheets.Range>} ranges The range array.
                     * @class
                     */
                    constructor(ruleType:  RuleType,  style:  GC.Spread.Sheets.Style,  ranges:  GC.Spread.Sheets.Range[]);
                    /**
                     * Gets or sets the base condition of the rule.
                     * @param {object} value The base condition of the rule.
                     * @returns {object | GC.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} If no value is set, returns the base condition of the rule; otherwise, returns the condition rule.
                     */
                    condition(value?:  Condition): any;
                    /**
                     * Determines whether the range of cells contains the cell at the specified row and column.
                     * @param {number} row The row index.
                     * @param {number} column The column index.
                     * @returns {boolean} <c>true</c> if the range of cells contains the cell at the specified row and column; otherwise, <c>false</c>.
                     */
                    contains(row:  number,  column:  number): boolean;
                    /**
                     * Creates condition for the rule.
                     * @returns {GC.Spread.Sheets.ConditionalFormatting.Condition} The condition.
                     */
                    createCondition(): Condition;
                    /**
                     * Returns the cell style of the rule if the cell satisfies the condition.
                     * @param {object} evaluator The object that can evaluate a condition.
                     * @param {number} baseRow The row index.
                     * @param {number} baseColumn The column index.
                     * @param {object} actual The actual value.
                     * @returns {object} The cell style of the rule.
                     */
                    evaluate(evaluator:  Object,  baseRow:  number,  baseColumn:  number,  actual:  Object): Object;
                    /**
                     * Gets the style of the base rule.
                     * @returns {GC.Spread.Sheets.Style}
                     */
                    getExpected(): GC.Spread.Sheets.Style;
                    /**
                     * Specifies whether the range for this rule intersects another range.
                     * @param {number} row The row index.
                     * @param {number} column The column index.
                     * @param {number} rowCount The number of rows.
                     * @param {number} columnCount The number of columns.
                     * @returns {boolean} <c>true</c> if the range for this rule intersects another range; otherwise, <c>false</c>.
                     */
                    intersects(row:  number,  column:  number,  rowCount:  number,  columnCount:  number): boolean;
                    /**
                     * Specifies whether this rule is a scale rule.
                     * @returns {boolean} <c>true</c> if this rule is a scale rule; otherwise, <c>false</c>.
                     */
                    isScaleRule(): boolean;
                    /**
                     * Gets or sets the priority of the rule.
                     * @param {number} value The priority of the rule.
                     * @returns {number | GC.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} If no value is set, returns the priority of the rule; otherwise, returns the condition rule.
                     */
                    priority(value?:  number): any;
                    /**
                     * Gets or sets the condition rule ranges.
                     * @param {Array.<GC.Spread.Sheets.Range>} value The condition rule ranges.
                     * @returns {Array.<GC.Spread.Sheets.Range> | GC.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} If no value is set, returns the condition rule ranges; otherwise, returns the condition rule.
                     * @example
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "green";
                     * var ranges = [new GC.Spread.Sheets.Range(0, 0, 10, 1)];
                     * activeSheet.conditionalFormats.addUniqueRule(style, ranges);
                     * activeSheet.setValue(0, 0, 50);
                     * activeSheet.setValue(1, 0, 50);
                     * activeSheet.setValue(2, 0, 11);
                     * activeSheet.setValue(3, 0, 5);
                     */
                    ranges(value?:  GC.Spread.Sheets.Range[]): any;
                    /**
                     * Resets the rule.
                     */
                    reset(): void;
                    /**
                     * Gets or sets the condition rule type.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.RuleType} value The condition rule type.
                     * @returns {GC.Spread.Sheets.ConditionalFormatting.RuleType | GC.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} If no value is set, returns the condition rule type; otherwise, returns the condition rule.
                     * @example
                     * //This example uses the ruleType method.
                     * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * style.foreColor = "black";
                     * var cell = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * cell.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * cell.operator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                     * cell.value1(5);
                     * cell.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * cell.style(style);
                     * activeSheet.conditionalFormats.addRule(cell);
                     * var style1 = new GC.Spread.Sheets.Style();
                     * style1.foreColor = "red";
                     * var top = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * top.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.top10Rule);
                     * top.type(GC.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top);
                     * top.rank(3);
                     * top.style(style1);
                     * top.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * top.stopIfTrue(true);
                     * activeSheet.conditionalFormats.addRule(top);
                     */
                    ruleType(value?:  RuleType): any;
                    /**
                     * Gets or sets whether rules with lower priority are applied before this rule.
                     * @param {boolean} value Whether rules with lower priority are applied before this rule.
                     * @returns {boolean | GC.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} If no value is set, returns whether the rules with lower priority are not applied before this rule; otherwise, returns the condition rule.
                     * @example
                     * //This example applies multiple rules.
                     * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * style.foreColor = "black";
                     * var cell = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * cell.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * cell.operator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                     * cell.value1(5);
                     * cell.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * cell.style(style);
                     * activeSheet.conditionalFormats.addRule(cell);
                     * var style1 = new GC.Spread.Sheets.Style();
                     * style1.foreColor = "red";
                     * var top = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * top.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.top10Rule);
                     * top.type(GC.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top);
                     * top.rank(3);
                     * top.style(style1);
                     * top.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * top.stopIfTrue(true);
                     * activeSheet.conditionalFormats.addRule(top);
                     */
                    stopIfTrue(value?:  boolean): any;
                    /**
                     * Gets or sets the style for the rule.
                     * @param {GC.Spread.Sheets.Style} value The style for the rule.
                     * @returns {GC.Spread.Sheets.Style | GC.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} If no value is set, returns the style for the rule; otherwise, returns the condition rule.
                     * @example
                     * //This example applies multiple rules.
                     * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * style.foreColor = "black";
                     * var cell = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * cell.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * cell.operator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                     * cell.value1(5);
                     * cell.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * cell.style(style);
                     * activeSheet.conditionalFormats.addRule(cell);
                     * var style1 = new GC.Spread.Sheets.Style();
                     * style1.foreColor = "red";
                     * var top = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * top.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.top10Rule);
                     * top.type(GC.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top);
                     * top.rank(3);
                     * top.style(style1);
                     * top.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * top.stopIfTrue(true);
                     * activeSheet.conditionalFormats.addRule(top);
                     */
                    style(value?:  GC.Spread.Sheets.Style): any;
                }

                export class DataBarRule extends ConditionRuleBase{
                    /**
                     * Represents a data bar conditional rule with the specified parameters.
                     * @extends GC.Spread.Sheets.ConditionalFormatting.ScaleRule
                     * @param {GC.Spread.Sheets.ConditionalFormatting.ScaleValueType} minType The minimum scale type.
                     * @param {object} minValue The minimum scale value.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.ScaleValueType} maxType The maximum scale type.
                     * @param {object} maxValue The maximum scale value.
                     * @param {string} color The fill color of the data bar.
                     * @param {Array.<GC.Spread.Sheets.Range>} ranges The data bar rule effected range.
                     * @class
                     * @example
                     * //This example creates a data bar rule.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var dataBarRule = new GC.Spread.Sheets.ConditionalFormatting.DataBarRule(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number, -1, GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number, 40, "green", [new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GC.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GC.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    constructor(minType:  ScaleValueType,  minValue:  Object,  maxType:  ScaleValueType,  maxValue:  Object,  color:  string,  ranges:  GC.Spread.Sheets.Range[]);
                    /**
                     * Gets or sets the axis color of the data bar.
                     * @param {string} value The axis color of the data bar.
                     * @returns {string | GC.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the axis color of the data bar; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the axisColor method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     *  //rule
                     * var dataBarRule = new GC.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GC.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GC.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    axisColor(value?:  string): any;
                    /**
                     * Gets or sets the axis position of the data bar.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition} value The axis position of the data bar.
                     * @returns {GC.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition | GC.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the axis position of the data bar; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the axisPosition method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     *  //rule
                     * var dataBarRule = new GC.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GC.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GC.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    axisPosition(value?:  DataBarAxisPosition): any;
                    /**
                     * Gets or sets the color of the border.
                     * @param {string} value The color of the border.
                     * @returns {string | GC.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the color of the border; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the borderColor method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     *  //rule
                     * var dataBarRule = new GC.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GC.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GC.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    borderColor(value?:  string): any;
                    /**
                     * Gets or sets the postive fill color of the data bar.
                     * @param {string} value The fill color.
                     * @returns {string | GC.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the postive fill color of the data bar; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the color method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     *  //rule
                     * var dataBarRule = new GC.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GC.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GC.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    color(value?:  string): any;
                    /**
                     * Gets or sets the data bar direction.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.BarDirection} value The data bar direction.
                     * @returns {GC.Spread.Sheets.ConditionalFormatting.BarDirection | GC.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the data bar direction; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the dataBarDirection method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     *  //rule
                     * var dataBarRule = new GC.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GC.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GC.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    dataBarDirection(value?:  BarDirection): any;
                    /**
                     * Returns the specified value of the rule if the cell meets the condition.
                     * @param {object} evaluator The evaluator.
                     * @param {number} baseRow The row index.
                     * @param {number} baseColumn The column index.
                     * @param {object} actual The current value.
                     * @returns {object} The specified value of the rule if the cell meets the condition.
                     */
                    evaluate(evaluator:  Object,  baseRow:  number,  baseColumn:  number,  actual:  Object): Object;
                    /**
                     * Gets or sets a value that indicates whether the data bar is a gradient.
                     * @param {boolean} value Whether the data bar is a gradient.
                     * @returns {boolean | GC.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the value that indicates whether the data bar is a gradient; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the gradient method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var dataBarRule = new GC.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GC.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GC.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * dataBarRule.gradient(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    gradient(value?:  boolean): any;
                    /**
                     * Gets or sets the color of the negative border.
                     * @param {string} value The color of the negative boreder.
                     * @returns {string | GC.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the color of the negative border; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the negativeBorderColor method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var dataBarRule = new GC.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GC.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GC.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    negativeBorderColor(value?:  string): any;
                    /**
                     * Gets or sets the color of the negative fill.
                     * @param {string} value The color of the negative fill.
                     * @returns {string | GC.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the color of the negative fill; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the negativeFillColor method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var dataBarRule = new GC.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GC.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GC.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    negativeFillColor(value?:  string): any;
                    /**
                     * Gets or sets whether to display the data bar without text.
                     * @param {boolean} value Whether to display the data bar without text.
                     * @returns {boolean | GC.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns whether the widget displays the data bar without text; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the showBarOnly method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var dataBarRule = new GC.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GC.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GC.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    showBarOnly(value?:  boolean): any;
                    /**
                     * Gets or sets a value that indicates whether to paint the border.
                     * @param {boolean} value Whether to paint the border.
                     * @returns {boolean | GC.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the value that indicates whether to paint the border; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the showBorder method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var dataBarRule = new GC.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GC.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GC.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    showBorder(value?:  boolean): any;
                    /**
                     * Gets or sets a value that indicates whether the negative border color is used to paint the border for the negative value.
                     * @param {boolean} value Whether the negative border color is used to paint the border for the negative value.
                     * @returns {boolean | GC.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the value that indicates whether the negative border color is used to paint the border for the negative value; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the useNegativeBorderColor method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var dataBarRule = new GC.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GC.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GC.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    useNegativeBorderColor(value?:  boolean): any;
                    /**
                     * Gets or sets a value that indicates whether the negative fill color is used to paint the negative value.
                     * @param {boolean} value Whether the negative fill color is used to paint the negative value.
                     * @returns {boolean | GC.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the value that indicates whether the negative fill color is used to paint the negative value; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the useNegativeFillColor method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var dataBarRule = new GC.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GC.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GC.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    useNegativeFillColor(value?:  boolean): any;
                }

                export class IconCriterion{
                    /**
                     * Represents an icon criteria with the specified parameters.
                     * @class
                     * @param {boolean} isGreaterThanOrEqualTo If set to true, use the greater than or equal to operator to calculate the value.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.IconValueType} iconValueType The type of scale value.
                     * @param {object} iconValue The scale value.
                     * @example
                     * //This example creates an icon rule.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * //rule
                     * var iconSetRule = new GC.Spread.Sheets.ConditionalFormatting.IconSetRule();
                     * iconSetRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * iconSetRule.iconSetType(GC.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights);
                     * var iconCriteria = iconSetRule.iconCriteria();
                     * iconCriteria[0] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 1);
                     * iconCriteria[1] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 10);
                     * iconCriteria[2] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 20);
                     * iconSetRule.reverseIconOrder(false);
                     * iconSetRule.showIconOnly(false);
                     * activeSheet.conditionalFormats.addRule(iconSetRule);
                     */
                    constructor(isGreaterThanOrEqualTo:  boolean,  iconValueType:  IconValueType,  iconValue:  Object);
                }

                export class IconSetRule extends ConditionRuleBase{
                    /**
                     * Represents an icon set rule with the specified parameters.
                     * @class
                     * @extends GC.Spread.Sheets.ConditionalFormatting.ScaleRule
                     * @param {GC.Spread.Sheets.ConditionalFormatting.IconSetType} iconSetType The type of icon set.
                     * @param {Array.<GC.Spread.Sheets.Range>} ranges
                     * @example
                     * //This example creates a new icon set rule and sets the range and icon for it.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var iconSetRule = new GC.Spread.Sheets.ConditionalFormatting.IconSetRule();
                     * iconSetRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * iconSetRule.iconSetType(GC.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights);
                     * var icons = iconSetRule.icons();
                     * icons[0] = {iconSetType: GC.Spread.Sheets.ConditionalFormatting.IconSetType.fiveArrowsColored, iconIndex: 1};
                     * icons[1] = {iconSetType: GC.Spread.Sheets.ConditionalFormatting.IconSetType.fiveArrowsColored, iconIndex: 2};
                     * icons[2] = {iconSetType: GC.Spread.Sheets.ConditionalFormatting.IconSetType.noIcons, iconIndex: 0};
                     *
                     * var iconCriteria = iconSetRule.iconCriteria();
                     * iconCriteria[0] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 1);
                     * iconCriteria[1] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 10);
                     * iconCriteria[2] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 20);
                     * iconSetRule.reverseIconOrder(false);
                     * iconSetRule.showIconOnly(false);
                     * activeSheet.conditionalFormats.addRule(iconSetRule);
                     */
                    constructor(iconSetType:  IconSetType,  ranges:  GC.Spread.Sheets.Range[]);
                    /**
                     * Returns the specified value of the rule if the cell meets the condition.
                     * @param {object} evaluator The evaluator.
                     * @param {number} baseRow The row index.
                     * @param {number} baseColumn The column index.
                     * @param {object} actual The current value.
                     * @returns {object} The specified value of the rule if the cell meets the condition.
                     */
                    evaluate(evaluator:  Object,  baseRow:  number,  baseColumn:  number,  actual:  Object): Object;
                    /**
                     * Gets the icon based on the specific iconSetType and iconIndex objects.
                     * @static
                     * @param {GC.Spread.Sheets.ConditionalFormatting.IconSetType} iconSetType The icon set type.
                     * @param {number} iconIndex The icon index.
                     * returns {object} An object that contains the image's URL string, the offset, and width and height.
                     * If the user wants to customize the icon for IconSet, it returns the image URL string.
                     * @example
                     * //This example returns the icons for an icon set rule.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * //get the icon
                     * var base = GC.Spread.Sheets.ConditionalFormatting.IconSetRule.getIcon;
                     * GC.Spread.Sheets.ConditionalFormatting.IconSetRule.getIcon = function (iconSetType, iconIndex) {
                     *      var icon = base.apply(this, arguments);
                     *      if (iconSetType === GC.Spread.Sheets.ConditionalFormatting.IconSetType.threeArrowsColored) {
                     *          if (iconIndex === 0) {
                     *              return "images/Star2.png";
                     *          } else if (iconIndex === 1){
                     *              return "images/Rating4.png";
                     *          } else if (iconIndex === 2) {
                     *              return "images/Box4.png";
                     *          }
                     *      }
                     *      return icon;
                     * };
                     * var iconSetRule = new GC.Spread.Sheets.ConditionalFormatting.IconSetRule();
                     * iconSetRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * iconSetRule.iconSetType(GC.Spread.Sheets.ConditionalFormatting.IconSetType.threeArrowsColored);
                     * var iconCriteria = iconSetRule.iconCriteria();
                     * iconCriteria[0] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 1);
                     * iconCriteria[1] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 10);
                     * iconCriteria[2] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 20);
                     * iconSetRule.reverseIconOrder(false);
                     * iconSetRule.showIconOnly(false);
                     * activeSheet.conditionalFormats.addRule(iconSetRule);
                     */
                    static getIcon(iconSetType:  IconSetType,  iconIndex:  number): Object;
                    /**
                     * Gets the icon criteria.
                     * @returns {Array.<GC.Spread.Sheets.ConditionalFormatting.IconCriterion>} Returns the icon criterias whose item type is GC.Spread.Sheets.ConditionalFormatting.IconCriterion.
                     * @example
                     * //This example creates a rule.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * //rule
                     * var iconSetRule = new GC.Spread.Sheets.ConditionalFormatting.IconSetRule();
                     * iconSetRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * iconSetRule.iconSetType(GC.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights);
                     * var iconCriteria = iconSetRule.iconCriteria();
                     * iconCriteria[0] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 1);
                     * iconCriteria[1] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 10);
                     * iconCriteria[2] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 20);
                     * iconSetRule.reverseIconOrder(false);
                     * iconSetRule.showIconOnly(false);
                     * activeSheet.conditionalFormats.addRule(iconSetRule);
                     */
                    iconCriteria(): IconCriterion[];
                    /**
                     * Gets or sets the icons.
                     * @param {object[]} [iconInfos] - Sets the iconInfos array.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.IconSetType} iconInfos.iconSetType - The custom iconSetType
                     * @param {number} iconInfos.iconIndex - The custom iconIndex
                     * @returns {object[]} Returns the iconInfos array.
                     * @example
                     * //This example creates a rule.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     *
                     * //rule
                     * var iconSetRule = new GC.Spread.Sheets.ConditionalFormatting.IconSetRule();
                     * iconSetRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * iconSetRule.iconSetType(GC.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights);
                     * var icons = iconSetRule.icons();
                     * icons[0] = {iconSetType: GC.Spread.Sheets.ConditionalFormatting.IconSetType.fiveArrowsColored, iconIndex: 1};
                     * icons[1] = {iconSetType: GC.Spread.Sheets.ConditionalFormatting.IconSetType.fiveArrowsColored, iconIndex: 2};
                     * icons[2] = {iconSetType: GC.Spread.Sheets.ConditionalFormatting.IconSetType.noIcons, iconIndex: 0};
                     * iconSetRule.reverseIconOrder(false);
                     * iconSetRule.showIconOnly(false);
                     * activeSheet.conditionalFormats.addRule(iconSetRule);
                     */
                    icons(value?:  GC.Spread.Sheets.ConditionalFormatting.IIconInfo[]): GC.Spread.Sheets.ConditionalFormatting.IIconInfo[];
                    /**
                     * Gets or sets the type of icon set.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.IconSetType} value The type of icon set.
                     * @returns {GC.Spread.Sheets.ConditionalFormatting.IconSetType | GC.Spread.Sheets.ConditionalFormatting.IconSetRule} If no value is set, returns the type of icon set; otherwise, returns the icon set rule.
                     * @example
                     * //This example creates a rule.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * //rule
                     * var iconSetRule = new GC.Spread.Sheets.ConditionalFormatting.IconSetRule();
                     * iconSetRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * iconSetRule.iconSetType(GC.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights);
                     * var iconCriteria = iconSetRule.iconCriteria();
                     * iconCriteria[0] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 1);
                     * iconCriteria[1] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 10);
                     * iconCriteria[2] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 20);
                     * iconSetRule.reverseIconOrder(false);
                     * iconSetRule.showIconOnly(false);
                     * activeSheet.conditionalFormats.addRule(iconSetRule);
                     */
                    iconSetType(value?:  IconSetType): any;
                    /**
                     * Resets the rule.
                     * @example
                     * //This example uses the reset method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * //rule
                     * var iconSetRule = new GC.Spread.Sheets.ConditionalFormatting.IconSetRule();
                     * iconSetRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * iconSetRule.iconSetType(GC.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights);
                     * var iconCriteria = iconSetRule.iconCriteria();
                     * iconCriteria[0] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 1);
                     * iconCriteria[1] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 10);
                     * iconCriteria[2] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 20);
                     * iconSetRule.reverseIconOrder(false);
                     * iconSetRule.showIconOnly(false);
                     * activeSheet.conditionalFormats.addRule(iconSetRule);
                     * iconSetRule.reset();
                     */
                    reset(): void;
                    /**
                     * Gets or sets whether to reverse icon order.
                     * @param {boolean} value Whether to reverse icon order.
                     * @returns {boolean | GC.Spread.Sheets.ConditionalFormatting.IconSetRule} If no value is set, returns the value that indicates whether to reverse icon order; otherwise, returns the icon set rule.
                     * @example
                     * //This example creates a rule.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * //rule
                     * var iconSetRule = new GC.Spread.Sheets.ConditionalFormatting.IconSetRule();
                     * iconSetRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * iconSetRule.iconSetType(GC.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights);
                     * var iconCriteria = iconSetRule.iconCriteria();
                     * iconCriteria[0] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 1);
                     * iconCriteria[1] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 10);
                     * iconCriteria[2] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 20);
                     * iconSetRule.reverseIconOrder(false);
                     * iconSetRule.showIconOnly(false);
                     * activeSheet.conditionalFormats.addRule(iconSetRule);
                     */
                    reverseIconOrder(value?:  boolean): any;
                    /**
                     * Gets or sets whether to display the icon only.
                     * @param {boolean} value Whether to display the icon only.
                     * @returns {boolean | GC.Spread.Sheets.ConditionalFormatting.IconSetRule} If no value is set, returns the value that indicates whether to display the icon only; otherwise, returns the icon set rule.
                     * @example
                     * //This example creates a rule.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * //rule
                     * var iconSetRule = new GC.Spread.Sheets.ConditionalFormatting.IconSetRule();
                     * iconSetRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * iconSetRule.iconSetType(GC.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights);
                     * var iconCriteria = iconSetRule.iconCriteria();
                     * iconCriteria[0] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 1);
                     * iconCriteria[1] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 10);
                     * iconCriteria[2] = new GC.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GC.Spread.Sheets.ConditionalFormatting.IconValueType.number, 20);
                     * iconSetRule.reverseIconOrder(false);
                     * iconSetRule.showIconOnly(false);
                     * activeSheet.conditionalFormats.addRule(iconSetRule);
                     */
                    showIconOnly(value?:  boolean): any;
                }

                export class NormalConditionRule extends ConditionRuleBase{
                    /**
                     * Represents a normal conditional rule.
                     * @class
                     * @extends GC.Spread.Sheets.ConditionalFormatting.ConditionRuleBase
                     * @param {GC.Spread.Sheets.ConditionalFormatting.RuleType} ruleType
                     * @param {Array.<GC.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GC.Spread.Sheets.Range.
                     * @param {GC.Spread.Sheets.Style} style The style that is applied to the cell when the condition is met.
                     * @param {object}operator The comparison operator.
                     * @param {object} value1 The first value.
                     * @param {object} value2 The second value.
                     * @param {string} text The text for comparison.
                     * @param {string} formula The condition formula.
                     * @param {object} type The average condition type.
                     * @param {number} rank The number of top or bottom items to apply the style to.
                     * @constructor
                     * @example
                     * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                     * var cell = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * cell.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * cell.operator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                     * cell.value1(5);
                     * cell.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * cell.style(style);
                     * activeSheet.conditionalFormats.addRule(cell);
                     * //button
                     * $("#button1").click(function () {
                     *      cell.reset();
                     *      activeSheet.suspendPaint();
                     *      activeSheet.resumePaint();
                     * });
                     */
                    constructor(ruleType:  RuleType,  ranges:  GC.Spread.Sheets.Range[],  style:  GC.Spread.Sheets.Style,  operator:  any,  value1:  Object,  value2:  Object,  text:  string,  formula:  string,  type:  any,  rank:  number);
                    /**
                     * Creates a condition for the rule.
                     * @returns {GC.Spread.Sheets.ConditionalFormatting.Condition} The condition.
                     */
                    createCondition(): Condition;
                    /**
                     * Gets or sets the condition formula.
                     * @param {string | number} formulaOrBaseRow The condition formula or the base row.
                     * @param {number} baseColumn The base column.
                     * @returns {string | GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule} If no value is set or baseRow and baseColumn is set, returns the condition formula; otherwise, returns the number condition rule.
                     * @example
                     * //This example uses the formula method.
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var rule = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * rule.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.formulaRule);
                     * rule.formula("=A1=B1+C1");
                     * rule.ranges([new GC.Spread.Sheets.Range(0, 0, 2, 1)]);
                     * rule.style(style);
                     * activeSheet.conditionalFormats.addRule(rule);
                     * activeSheet.setValue(0, 0, 2,3);
                     * activeSheet.setValue(0, 1, 1,3);
                     * activeSheet.setValue(0, 2,1,3);
                     * activeSheet.setValue(1, 0, 1,3);
                     * var formulaOfTheTopLeftCell = rule.formula();
                     * var formulaOfA1 = rule.formula(0, 0);
                     * var formulaOfA2 = rule.formula(1, 0);
                     */
                    formula(formulaOrBaseRow?:  string | number,  baseColumn ?:  number): any;
                    /**
                     * Gets or sets the comparison operator.
                     * @param {object} value The comparison operator.
                     * @returns {object | GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule} If no value is set, returns the comparison operator; otherwise, returns the number condition rule.
                     * @example
                     * //This example creates multiple rules.
                     * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * style.foreColor = "black";
                     * var cell = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * cell.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * cell.operator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                     * cell.value1(5);
                     * cell.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * cell.style(style);
                     * activeSheet.conditionalFormats.addRule(cell);
                     * var style1 = new GC.Spread.Sheets.Style();
                     * style1.foreColor = "red";
                     * var top = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * top.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.top10Rule);
                     * top.type(GC.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top);
                     * top.rank(3);
                     * top.style(style1);
                     * top.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * top.stopIfTrue(true);
                     * activeSheet.conditionalFormats.addRule(top);
                     */
                    operator(valueOrBaseRow?:  string | number,  baseColumn ?:  number): any;
                    /**
                     * Gets or sets the number of top or bottom items to apply the style to.
                     * @param {number} value The number of top or bottom items to apply the style to.
                     * @returns {number | GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule} If no value is set, returns the number of top or bottom items to apply the style to; otherwise, returns the number condition rule.
                     * @example
                     * //This example creates multiple rules.
                     * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * style.foreColor = "black";
                     * var cell = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * cell.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * cell.operator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                     * cell.value1(5);
                     * cell.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * cell.style(style);
                     * activeSheet.conditionalFormats.addRule(cell);
                     * var style1 = new GC.Spread.Sheets.Style();
                     * style1.foreColor = "red";
                     * var top = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * top.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.top10Rule);
                     * top.type(GC.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top);
                     * top.rank(3);
                     * top.style(style1);
                     * top.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * top.stopIfTrue(true);
                     * activeSheet.conditionalFormats.addRule(top);
                     */
                    rank(value?:  number): any;
                    /**
                     * Resets the rule.
                     * @example
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     * activeSheet.setValue(3,0, 2,3);
                     * activeSheet.setValue(4,0, 60,3);
                     * activeSheet.setValue(5,0, 90,3);
                     * activeSheet.setValue(6,0, 3,3);
                     * activeSheet.setValue(7,0, 40,3);
                     * activeSheet.setValue(8,0, 70,3);
                     * activeSheet.setValue(9,0, 5,3);
                     * activeSheet.setValue(10,0, 35,3);
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * style.borderLeft =new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                     * style.borderTop = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                     * style.borderRight = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                     * style.borderBottom = new GC.Spread.Sheets.LineBorder("blue",GC.Spread.Sheets.LineStyle.medium);
                     * var rule = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * rule.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.averageRule);
                     * rule.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 3)]);
                     * rule.style(style);
                     * rule.type(GC.Spread.Sheets.ConditionalFormatting.AverageConditionType.above);
                     * activeSheet.conditionalFormats.addRule(rule);
                     * rule.reset();
                     */
                    reset(): void;
                    /**
                     * Gets or sets the text for comparison.
                     * @param {string} value The text for comparison.
                     * @returns {string | GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule} If no value is set, returns the text for comparison; otherwise, returns the number condition rule.
                     * @example
                     * //This example creates a rule.
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var rule = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * rule.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.specificTextRule);
                     * rule.style(style);
                     * rule.text("test");
                     * rule.operator(GC.Spread.Sheets.ConditionalFormatting.TextComparisonOperators.contains);
                     * rule.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * activeSheet.conditionalFormats.addRule(rule);
                     * activeSheet.setValue(0, 0, "testing");
                     * activeSheet.setValue(1, 0, "test");
                     * activeSheet.setValue(2, 0, "a");
                     * activeSheet.setValue(3, 0, "t");
                     */
                    text(value?:  string): any;
                    /**
                     * Gets or sets the average condition type.
                     * @param {object} value The average condition type.
                     * @returns {object | GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule} If no value is set, returns the average condition type; otherwise, returns the number condition rule.
                     * @example
                     * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * style.foreColor = "black";
                     * var cell = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * cell.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * cell.operator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                     * cell.value1(5);
                     * cell.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * cell.style(style);
                     * activeSheet.conditionalFormats.addRule(cell);
                     * var style1 = new GC.Spread.Sheets.Style();
                     * style1.foreColor = "red";
                     * var top = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * top.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.top10Rule);
                     * top.type(GC.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top);
                     * top.rank(3);
                     * top.style(style1);
                     * top.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * top.stopIfTrue(true);
                     * activeSheet.conditionalFormats.addRule(top);
                     */
                    type(value?:  Object): any;
                    /**
                     * Gets or sets the first value.
                     * @param {object | number} valueOrBaseRow The first value or the base row.
                     * @param {number} baseColumn The base column.
                     * @returns {object | GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule} If no value is set or baseRow and baseColumn is set, returns the first value; otherwise, returns the number condition rule.
                     * @example
                     * //This example creates multiple rules.
                     * activeSheet.setArray(0,0,[[1,10],[2,9], [3,8],[4,7],[5,6],[6,5],[7,4],[8,3],[9,2],[10,1]]);
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * style.foreColor = "black";
                     * var cell = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * cell.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * cell.operator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                     * cell.value1("=B1");
                     * cell.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * cell.style(style);
                     * activeSheet.conditionalFormats.addRule(cell);
                     * var style1 = new GC.Spread.Sheets.Style();
                     * style1.foreColor = "red";
                     * var top = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * top.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.top10Rule);
                     * top.type(GC.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top);
                     * top.rank(3);
                     * top.style(style1);
                     * top.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * top.stopIfTrue(true);
                     * activeSheet.conditionalFormats.addRule(top);
                     * var formulaOfTheTopLeftCell = cell.value1();
                     * var formulaOfA5 = cell.value1(4, 0);
                     * var formulaOfA10 = cell.value1(9, 0);
                     */
                    value1(valueOrBaseRow ?:  string | number,  baseColumn ?:  number): any;
                    /**
                     * Gets or sets the first value.
                     * @param {object | number} valueOrBaseRow The first value or the base row.
                     * @param {number} baseColumn The base column.
                     * @returns {object | GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule} If no value is set or baseRow and baseColumn is set, returns the first value; otherwise, returns the number condition rule.
                     * @example
                     * //This example uses the value2 method.
                     * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                     * var cell = new GC.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * cell.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * cell.operator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between);
                     * cell.value1(5);
                     * cell.value2(7);
                     * cell.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * var style = new GC.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * style.foreColor = "black";
                     * cell.style(style);
                     * activeSheet.conditionalFormats.addRule(cell);
                     */
                    value2(valueOrBaseRow ?:  string | number,  baseColumn ?:  number): any;
                }

                export class ScaleRule extends ConditionRuleBase{
                    /**
                     * Represents a scale conditional rule.
                     * @@extends GC.Spread.Sheets.ConditionalFormatting.ConditionRuleBase
                     * @param {GC.Spread.Sheets.ConditionalFormatting.RuleType} ruleType The rule type.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.ScaleValueType} minType The minimum scale type.
                     * @param minValue The minimum scale value.
                     * @param {string} minColor The minimum scale color.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.ScaleValueType} midType The midpoint scale type.
                     * @param midValue The midpoint scale value.
                     * @param {string} midColor The midpoint scale color.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.ScaleValueType} maxType The maximum scale type.
                     * @param maxValue The maximum scale value.
                     * @param {string} maxColor The maximum scale color.
                     * @param {Array.<GC.Spread.Sheets.Range>} ranges The ranges.
                     * @constructor
                     * @example
                     * var scale = new GC.Spread.Sheets.ConditionalFormatting.ScaleRule();
                     * scale.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.threeScaleRule);
                     * scale.midColor("red");
                     * scale.midType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.midValue(50);
                     * scale.maxColor("blue");
                     * scale.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.maxValue(100);
                     * scale.minColor("yellow");
                     * scale.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.minValue(10);
                     * scale.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 3)]);
                     * activeSheet.conditionalFormats.addRule(scale);
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     */
                    constructor(ruleType:  RuleType,  minType:  ScaleValueType,  minValue:  Object,  minColor:  string,  midType:  ScaleValueType,  midValue:  Object,  midColor:  string,  maxType:  ScaleValueType,  maxValue:  Object,  maxColor:  string,  ranges:  GC.Spread.Sheets.Range[]);
                    /**
                     * Creates a condition for the rule.
                     * @returns {GC.Spread.Sheets.ConditionalFormatting.Condition} The condition.
                     */
                    createCondition(): Condition;
                    /**
                     * Returns a specified value of the rule if the cell satisfies the condition.
                     * @param {object} evaluator The evaluator.
                     * @param {number} baseRow The row index.
                     * @param {number} baseColumn The column index.
                     * @param {object} actual The actual value object for evaluation.
                     * @returns {string} A specified value of the rule if the cell satisfies the condition.
                     */
                    evaluate(evaluator:  Object,  baseRow:  number,  baseColumn:  number,  actual:  Object): Object;
                    /**
                     * Gets or sets the maximum color scale.
                     * @param {string} value The maximum color scale.
                     * @returns {string | GC.Spread.Sheets.ConditionalFormatting.ScaleRule} If no value is set, returns the maximum color scale; otherwise, returns the scale rule.
                     * @example
                     * var rule = new GC.Spread.Sheets.ConditionalFormatting.ScaleRule();
                     * rule.ranges([new GC.Spread.Sheets.Range(0,0,10,3)]);
                     * rule.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.twoScaleRule);
                     * rule.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * rule.minValue(10);
                     * rule.minColor("Yellow");
                     * rule.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * rule.maxValue(100);
                     * rule.maxColor("Blue");
                     * activeSheet.conditionalFormats.addRule(rule);
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     */
                    maxColor(value?:  string): any;
                    /**
                     * Gets or sets the maximum scale type.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.ScaleValueType} value The maximum scale type.
                     * @returns {GC.Spread.Sheets.ConditionalFormatting.ScaleValueType | GC.Spread.Sheets.ConditionalFormatting.ScaleRule} If no value is set, returns the maximum scale type; otherwise, returns the scale rule.
                     * @example
                     * var scale = new GC.Spread.Sheets.ConditionalFormatting.ScaleRule();
                     * scale.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.threeScaleRule);
                     * scale.midColor("red");
                     * scale.midType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.midValue(50);
                     * scale.maxColor("blue");
                     * scale.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.maxValue(100);
                     * scale.minColor("yellow");
                     * scale.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.minValue(10);
                     * scale.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 3)]);
                     * activeSheet.conditionalFormats.addRule(scale);
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     */
                    maxType(value?:  ScaleValueType): any;
                    /**
                     * Gets or sets the maximum scale value.
                     * @param {object} value The maximum scale value.
                     * @returns {object | GC.Spread.Sheets.ConditionalFormatting.ScaleRule} If no value is set, returns the maximum scale value; otherwise, returns the scale rule.
                     * @example
                     * var scale = new GC.Spread.Sheets.ConditionalFormatting.ScaleRule();
                     * scale.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.twoScaleRule);
                     * scale.maxColor("blue");
                     * scale.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.maxValue(100);
                     * scale.minColor("yellow");
                     * scale.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.minValue(10);
                     * scale.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 3)]);
                     * activeSheet.conditionalFormats.addRule(scale);
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     * alert("Color: " + scale.maxColor() + " Type: " + scale.maxType() + " Value: " + scale.maxValue());
                     */
                    maxValue(value?:  Object): any;
                    /**
                     * Gets or sets the midpoint scale color.
                     * @param {string} value The midpoint scale color.
                     * @returns {string | GC.Spread.Sheets.ConditionalFormatting.ScaleRule} If no value is set, returns the midpoint scale color; otherwise, returns the scale rule.
                     * @example
                     * var scale = new GC.Spread.Sheets.ConditionalFormatting.ScaleRule();
                     * scale.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.threeScaleRule);
                     * scale.midColor("red");
                     * scale.midType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.midValue(50);
                     * scale.maxColor("blue");
                     * scale.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.maxValue(100);
                     * scale.minColor("yellow");
                     * scale.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.minValue(10);
                     * scale.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 3)]);
                     * activeSheet.conditionalFormats.addRule(scale);
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     */
                    midColor(value?:  string): any;
                    /**
                     * Gets or sets the midpoint scale type.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.ScaleValueType} value The midpoint scale type.
                     * @returns {GC.Spread.Sheets.ConditionalFormatting.ScaleValueType | GC.Spread.Sheets.ConditionalFormatting.ScaleRule} If no value is set, returns the midpoint scale type; otherwise, returns the scale rule.
                     * @example
                     * var scale = new GC.Spread.Sheets.ConditionalFormatting.ScaleRule();
                     * scale.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.threeScaleRule);
                     * scale.midColor("red");
                     * scale.midType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.midValue(50);
                     * scale.maxColor("blue");
                     * scale.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.maxValue(100);
                     * scale.minColor("yellow");
                     * scale.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.minValue(10);
                     * scale.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 3)]);
                     * activeSheet.conditionalFormats.addRule(scale);
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     */
                    midType(value?:  ScaleValueType): any;
                    /**
                     * Gets or sets the midpoint scale value.
                     * @param {object} value The midpoint scale value.
                     * @returns {object | GC.Spread.Sheets.ConditionalFormatting.ScaleRule} If no value is set, returns the midpoint scale value; otherwise, returns the scale rule.
                     * @example
                     * var scale = new GC.Spread.Sheets.ConditionalFormatting.ScaleRule();
                     * scale.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.threeScaleRule);
                     * scale.midColor("red");
                     * scale.midType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.midValue(50);
                     * scale.maxColor("blue");
                     * scale.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.maxValue(100);
                     * scale.minColor("yellow");
                     * scale.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.minValue(10);
                     * scale.ranges([new GC.Spread.Sheets.Range(0, 0, 10, 3)]);
                     * activeSheet.conditionalFormats.addRule(scale);
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     */
                    midValue(value?:  Object): any;
                    /**
                     * Gets or sets the minimum scale color.
                     * @param {string} value The minimum scale color.
                     * @returns {string | GC.Spread.Sheets.ConditionalFormatting.ScaleRule} If no value is set, returns the minimum scale color; otherwise, returns the scale rule.
                     * @example
                     * var rule = new GC.Spread.Sheets.ConditionalFormatting.ScaleRule();
                     * rule.ranges([new GC.Spread.Sheets.Range(0,0,10,3)]);
                     * rule.ruleType(GC.Spread.Sheets.ConditionalFormatting.RuleType.twoScaleRule);
                     * rule.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * rule.minValue(10);
                     * rule.minColor("Yellow");
                     * rule.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * rule.maxValue(100);
                     * rule.maxColor("Blue");
                     * activeSheet.conditionalFormats.addRule(rule);
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     */
                    minColor(value?:  string): any;
                    /**
                     * Gets or sets the type of minimum scale.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.ScaleValueType} value The type of minimum scale.
                     * @returns {GC.Spread.Sheets.ConditionalFormatting.ScaleValueType | GC.Spread.Sheets.ConditionalFormatting.ScaleRule} If no value is set, returns the type of minimum scale; otherwise, returns the scale rule.
                     * @example
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var dataBarRule = new GC.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GC.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GC.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    minType(value?:  ScaleValueType): any;
                    /**
                     * Gets or sets the minimum scale value.
                     * @param {object} value The minimum scale value.
                     * @returns {object | GC.Spread.Sheets.ConditionalFormatting.ScaleRule} If no value is set, returns the minimum scale value; otherwise, returns the scale rule.
                     * @example
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var dataBarRule = new GC.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GC.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GC.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GC.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GC.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    minValue(value?:  Object): any;
                    /**
                     * Gets whether evaluation should stop if the condition evaluates to <c>true</c>.
                     */
                    stopIfTrue(value:  boolean): boolean;
                }

                export class ScaleValue{
                    /**
                     * Represents a scale value with the specified type and value.
                     * @class
                     * @param {object} type The scale value type.
                     * @param {object} value The scale value.
                     */
                    constructor(type:  Object,  value:  Object);
                    /** Gets the scale value type.
                     * @type {object}
                     */
                    type: Object;
                    /** Gets the scale value.
                     * @type {object}
                     */
                    value: Object;
                }
            }

            module ContextMenu{

                export interface IMenuItemData{
                    name?:string;
                    text?:string;
                    command?:string|Function;
                    disable?:boolean;
                    iconClass?:string;
                    group?:string;
                    subMenu?:IMenuItemData[];
                    type?:string;
                    workArea?:string;
                }


                export class ContextMenu{
                    /**
                     * Represents ContextMenu
                     * @class
                     */
                    constructor();
                    /**
                     * Represents the build-in menuData
                     * @type {GC.Spread.Sheets.ContextMenu.IMenuItemData[]}
                     */
                    menuData: GC.Spread.Sheets.ContextMenu.IMenuItemData[];
                    /**
                     * Represents the build-in menuView
                     * @type {Object}
                     */
                    menuView: Object;
                    /**
                     * open context menu
                     * @param {GC.Spread.Sheets.ContextMenu.IMenuItemData[]} menuData
                     * @param {GC.Spread.Sheets.ContextMenu.IMenuItemData[]} itemsDataForShown
                     * @param {Object} hitInfo
                     * @param {Object} spread
                     * @return {boolean} indicate whether or not the contextmenu event has been processed done
                     * @example
                     * $(document).ready(function () {
                     *    var spread = new GC.Spread.Sheets.Workbook(document.getElementById("ss"));
                     *    function ContextMenu(){}
                     *    ContextMenu.prototype = new GC.Spread.Sheets.ContextMenu.ContextMenu(spread);
                     *    ContextMenu.prototype.onOpenMenu = function (menuData, itemsDataForShown, hitInfo, spread) {
                     *           console.log(menuData);
                     *           console.log(itemsDataForShown);
                     *           console.log(hitInfo);
                     *           console.log(spread);
                     *           //you can change itemsDataForShown to change filter result
                     *           //if you only want to change filter result,return false or don't return anything
                     *           //you also can open your own context menu,if you want to do this,return true
                     *           //return true;
                     *    };
                     *    var contextMenu = new ContextMenu();
                     *    spread.contextMenu = contextMenu;
                     * });
                     */
                    onOpenMenu(menuData:  GC.Spread.Sheets.ContextMenu.IMenuItemData[],  itemsDataForShown:  GC.Spread.Sheets.ContextMenu.IMenuItemData[],  hitInfo:  Object,  spread:  Object): boolean;
                }

                export class MenuView{
                    /**
                     * Represents MenuView
                     * @class
                     */
                    constructor();
                    /**
                     * create menuitem view
                     * @param {GC.Spread.Sheets.ContextMenu.IMenuItemData} menuItemData the data of the menu item which needs to be shown
                     * @return {HTMLElement} menuitem view
                     * @example
                     * $(document).ready(function () {
                     *    var spread = new GC.Spread.Sheets.Workbook(document.getElementById("ss"));
                     *    function CustomMenuView() {
                     *   }
                     *   CustomMenuView.prototype = new GC.Spread.Sheets.ContextMenu.MenuView();
                     *   CustomMenuView.prototype.createMenuItemElement = function (menuItemData) {
                     *      var self = this;
                     *      var menuItemView = GC.Spread.Sheets.ContextMenu.MenuView.prototype.createMenuItemElement.call(self, menuItemData);
                     *      if (menuItemData.name === "markWithABg") {
                     *          var subMenuView = menuItemView.find(".gc-ui-contextmenu-container");
                     *          $(subMenuView[0]).colorpicker();
                     *      }
                     *      return menuItemView;
                     *  };
                     * });
                     */
                    createMenuItemElement(menuItemData:  GC.Spread.Sheets.ContextMenu.IMenuItemData):HTMLElement;
                    /**
                     * get command options of specified menu item
                     * @param {Object} menuItemData the data of the menu item which be clicked
                     * @param {HTMLElement} host the container of the menu item which be clicked
                     * @param {Object} event the mouse click event
                     * @return {Object} command options of specified menu item
                     * @example
                     *   var spread = new GC.Spread.Sheets.Workbook(document.getElementById("ss"));
                     *   function CustomMenuView() {
                     *   }
                     *   CustomMenuView.prototype = new GC.Spread.Sheets.ContextMenu.MenuView();
                     *   CustomMenuView.prototype.getCommandOptions = function (menuItemData, host, event) {
                     *      if (menuItemData &amp;&amp; menuItemData.name === "markWithABg") {
                     *          var ele = event.target || event.srcElement;
                     *          if (ele.className.indexOf("colorpicker-div-inner-colorcell") !== -1) {
                     *              ele = ele.parentElement;
                     *          }
                     *          return ele.style.background;
                     *      }
                     *   };
                     */
                    getCommandOptions(menuItemData:  GC.Spread.Sheets.ContextMenu.IMenuItemData,  host:  Object,  event:  Object):any;
                }
            }

            module DataValidation{
                /**
                 * Creates a validator based on the data.
                 * @static
                 * @param {GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators} typeOperator The type of ComparisonOperators compare operator.
                 * @param {object} v1 The first object.
                 * @param {object} v2 The second object.
                 * @returns {GC.Spread.Sheets.DataValidation.DefaultDataValidator} The validator.
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GC.Spread.Sheets.DataValidation.createDateValidator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between, new Date(2012, 11, 31), new Date(2013, 11, 31));
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Enter a date between 12/31/2012 and 12/31/2013.");
                 * dv.inputTitle("Tip");
                 * activeSheet.getCell(1, -1).validator(dv);
                 */
                function createDateValidator(typeOperator:  GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators,  v1:  Object,  v2:  Object): GC.Spread.Sheets.DataValidation.DefaultDataValidator;
                /**
                 * Creates a validator based on a formula list.
                 * @static
                 * @param {string} formula The formula list.
                 * @returns {GC.Spread.Sheets.DataValidation.DefaultDataValidator} The validator.
                 * @example
                 * activeSheet.setValue(0, 2, 5);
                 * activeSheet.setValue(1, 2, 4);
                 * activeSheet.setValue(2, 2, 5);
                 * spread.options.highlightInvalidData = true;
                 * var dv = GC.Spread.Sheets.DataValidation.createFormulaListValidator("$C$1:$C$3");
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Pick a value from the list.");
                 * dv.inputTitle("tip");
                 * activeSheet.setDataValidator(1, 1, 1,1,dv,GC.Spread.Sheets.SheetArea.viewport);
                 * var validList = activeSheet.getDataValidator(1, 1).getValidList(activeSheet, 1, 1);
                 * alert(validList);
                 */
                function createFormulaListValidator(formula:  string): GC.Spread.Sheets.DataValidation.DefaultDataValidator;
                /**
                 * Creates a validator based on a formula.
                 * @static
                 * @param {string} formula The formula condition.
                 * @returns {GC.Spread.Sheets.DataValidation.DefaultDataValidator} The validator.
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * //The formula validator is valid if the formula condition returns true.
                 * var dv = GC.Spread.Sheets.DataValidation.createFormulaValidator("A1>0");
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Enter a value greater than 0 in A1.");
                 * dv.inputTitle("Tip");
                 * activeSheet.setDataValidator(0, 0, 1,1,dv,GC.Spread.Sheets.SheetArea.viewport);
                 */
                function createFormulaValidator(formula:  string): GC.Spread.Sheets.DataValidation.DefaultDataValidator;
                /**
                 * Creates a validator based on a list.
                 * @static
                 * @param {string} source The list value.
                 * @returns {GC.Spread.Sheets.DataValidation.DefaultDataValidator} The validator.
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GC.Spread.Sheets.DataValidation.createListValidator("1,2,3");
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Value must be 1,2 or 3");
                 * dv.inputTitle("tip");
                 * activeSheet.setDataValidator(1,1,1,1,dv, GC.Spread.Sheets.SheetArea.viewport);
                 * alert(activeSheet.getDataValidator(1,1).getValidList(activeSheet,1,1));
                 */
                function createListValidator(source:  string): GC.Spread.Sheets.DataValidation.DefaultDataValidator;
                /**
                 * Creates a validator based on numbers.
                 * @static
                 * @param {GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators} typeOperator The type of ComparisonOperators compare operator.
                 * @param {object} v1 The first object.
                 * @param {object} v2 The second object.
                 * @param {boolean} isIntegerValue Set to <c>true</c> if the validator is set to a number.
                 * @returns {GC.Spread.Sheets.DataValidation.DefaultDataValidator} The validator.
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GC.Spread.Sheets.DataValidation.createNumberValidator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between, "5", "20", true);
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Value must be between 5 and 20.");
                 * dv.inputTitle("tip");
                 * activeSheet.setDataValidator(1, 1, 1,1,dv,GC.Spread.Sheets.SheetArea.viewport);
                 */
                function createNumberValidator(typeOperator:  GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators,  v1:  Object,  v2:  Object,  isIntegerValue:  boolean): GC.Spread.Sheets.DataValidation.DefaultDataValidator;
                /**
                 * Creates a validator based on text length.
                 * @static
                 * @param {GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators} typeOperator The type of ComparisonOperators compare operator.
                 * @param {object} v1 The first object.
                 * @param {object} v2 The second object.
                 * @returns {GC.Spread.Sheets.DataValidation.DefaultDataValidator} The validator.
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GC.Spread.Sheets.DataValidation.createTextLengthValidator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan, "4", "20");
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Number of characters must be greater than 4.");
                 * dv.inputTitle("tip");
                 * activeSheet.setDataValidator(1, 1, 1, 1, dv, GC.Spread.Sheets.SheetArea.viewport);
                 */
                function createTextLengthValidator(typeOperator:  GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators,  v1:  Object,  v2:  Object): GC.Spread.Sheets.DataValidation.DefaultDataValidator;
                /**
                 * Indicates the data validator criteria type.
                 * @enum {number}
                 * @example
                 * //This example uses the CriteriaType enumeration.
                 * var textLengthCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.textLengthCondition);
                 * textLengthCondition.compareType(GC.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators.greaterThan);
                 * textLengthCondition.formula("$C$1"); // formula used to calculate a number.
                 * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(textLengthCondition);
                 * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.custom);
                 * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                 * spread.options.highlightInvalidData = true;
                 * activeSheet.setValue(0, 0, "abcf");
                 * //Set value 3 to $C$1, after this code, the value in Cell(0,0) is valid.
                 * activeSheet.setValue(0, 2, 3);
                 * //Set value 5 to $C$1, after this code, the value in Cel(0,0) is invalid.
                 * // activeSheet.setValue(0, 2, 5);
                 */
                export enum CriteriaType{
                    /**
                     * Specifies that the data validation allows any type of value and does not check for a type or range of values.
                     */
                    anyValue= 0,
                    /**
                     * Specifies that the data validation checks for and allows whole number values satisfying the given condition.
                     */
                    wholeNumber= 0x1,
                    /**
                     * Specifies that the data validation checks for and allows decimal values satisfying the given condition.
                     */
                    decimalValues= 0x2,
                    /**
                     * Specifies that the data validation checks for and allows a value that matches one in a list of values.
                     */
                    list= 0x3,
                    /**
                     * Specifies that the data validation checks for and allows date values satisfying the given condition.
                     */
                    date= 0x4,
                    /**
                     * Specifies that the data validation checks for and allows time values satisfying the given condition.
                     */
                    time= 0x5,
                    /**
                     * Specifies that the data validation checks for and allows text values whose length satisfies the given condition.
                     */
                    textLength= 0x6,
                    /**
                     * Specifies that the data validation uses a custom formula to check the cell value.
                     */
                    custom= 0x7
                }

                /**
                 * Indicates the data validation result.
                 * @enum {number}
                 */
                export enum DataValidationResult{
                    /**
                     * Indicates to apply the value to a cell for a validation error.
                     */
                    forceApply= 0,
                    /**
                     * Indicates to discard the value and not apply it to the cell for a validation error.
                     */
                    discard= 1,
                    /**
                     * Indicates to retry multiple times to apply the value to the cell for a validation error.
                     */
                    retry= 2
                }

                /**
                 * Indicates the data validation error style.
                 * @enum {number}
                 */
                export enum ErrorStyle{
                    /**
                     * Specifies to use a stop icon in the error alert.
                     */
                    stop= 0,
                    /**
                     * Specifies to use a warning icon in the error alert.
                     */
                    warning= 1,
                    /**
                     * Specifies to use an information icon in the error alert.
                     */
                    information= 2
                }

                /**
                 * Indicates the data validation highlightposition.
                 * @enum {number}
                 */
                export enum HighlightPosition{
                    /**
                     * Specifies highlight flag on the topleft of the invalid data cell.
                     */
                    topLeft= 0,
                    /**
                     * Specifies highlight flag on the topright of the invalid data cell.
                     */
                    topRight= 1,
                    /**
                     * Specifies highlight flag on the bottomright of the invalid data cell.
                     */
                    bottomRight= 2,
                    /**
                     * Specifies highlight flag on the bottomleft of the invalid data cell.
                     */
                    bottomLeft= 3,
                    /**
                     * Specifies image which type is icon on the left of the invalid data cell.
                     */
                    outsideLeft= 4,
                    /**
                     * Specifies  image which type is icon on the Right of the invalid data cell.
                     */
                    outsideRight= 5
                }

                /**
                 * Indicates the data validation highlightType.
                 * @enum {number}
                 */
                export enum HighlightType{
                    /**
                     * Specifies to use a circle in the invalid data cell.
                     */
                    circle= 0,
                    /**
                     * Specifies to use a dogEar in the invalid data cell.
                     */
                    dogEar= 1,
                    /**
                     * Specifies to use a icon in the invalid data cell.
                     */
                    icon= 2
                }


                export class DefaultDataValidator{
                    /**
                     * Represents a data validator.
                     * @class
                     * @param {GC.Spread.Sheets.ConditionalFormatting.Condition} condition The condition.
                     * @example
                     * //This example validates the cell data.
                     * spread.options.highlightInvalidData = true;
                     * var dv = new GC.Spread.Sheets.DataValidation.createTextLengthValidator(GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan, 5);
                     * activeSheet.setDataValidator(0, 0, 1, 1, dv, GC.Spread.Sheets.SheetArea.viewport);
                     * activeSheet.setValue(0, 0, "abcf");
                     */
                    constructor(condition:  GC.Spread.Sheets.ConditionalFormatting.Condition);
                    /**
                     * Gets or sets the comparison operator.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators} value The comparison operator.
                     * @returns {GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators | GC.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns the comparison operator; otherwise, returns the data validator.
                     */
                    comparisonOperator(value?:  GC.Spread.Sheets.ConditionalFormatting.ComparisonOperators): any;
                    /**
                     * Gets or sets the condition to validate.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.Condition} value The condition to validate.
                     * @returns {GC.Spread.Sheets.ConditionalFormatting.Condition | GC.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns the condition to validate; otherwise, returns the data validator.
                     */
                    condition(value?:  GC.Spread.Sheets.ConditionalFormatting.Condition): any;
                    /**
                     * Gets or sets the error message.
                     * @param {string} value The error message.
                     * @returns {string | GC.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns the error message; otherwise, returns the data validator.
                     */
                    errorMessage(value?:  string): any;
                    /**
                     * Gets or sets the error style to display.
                     * @param {GC.Spread.Sheets.DataValidation.ErrorStyle} value The error style to display.
                     * @returns {GC.Spread.Sheets.DataValidation.ErrorStyle | GC.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns the error style to display; otherwise, returns the data validator.
                     */
                    errorStyle(value?:  GC.Spread.Sheets.DataValidation.ErrorStyle): any;
                    /**
                     * Gets or sets the error title.
                     * @param {string} value The error title.
                     * @returns {string | GC.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns the error title; otherwise, returns the data validator.
                     */
                    errorTitle(value?:  string): any;
                    /**
                     * Returns the valid data lists if the Data validation type is list; otherwise, returns null.
                     * @param {object} evaluator The object that can evaluate a condition.
                     * @param {number} baseRow The base row.
                     * @param {number} baseColumn The base column.
                     * @returns {Array} The valid data lists or null.
                     */
                    getValidList(evaluator:  Object,  baseRow:  number,  baseColumn:  number): any[];
                    /**
                     * Get or Sets the invalid data cell highlight style.
                     * @param {Object} style - the style object that invalid data cell
                     * @param {GC.Spread.Sheets.DataValidation.HighlightType} style.type - typeIndicates the data validation highlightType.
                     * @param {string} [style.color] - Indicates the data validation highlight color.
                     * @param {GC.Spread.Sheets.DataValidation.HighlightPosition} [style.position] - Indicates the data validation highlight position.
                     * @param {string} [style.image] - Indicates the data validation highlight image url or data.
                     * @returns {Object | GC.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns the hignlight style object; otherwise, returns the data validator.
                     * @example
                     * //This example uses the highlightStyle method.
                     * sheet.setValue(1, 1, "sss");
                     * var dv = new GC.Spread.Sheets.DataValidation.createListValidator('Fruit,Vegetable,Food');
                     * dv.highlightStyle({
                     *    type:GC.Spread.Sheets.DataValidation.HignlightType.dogEar,
                     *    color:'blue',
                     *    position:GC.Spread.Sheets.DataValidation.HighlightPosition.topLeft
                     * });
                     * sheet.setDataValidator(1,1, dv);
                     * spread.options.highlightInvalidData = true;
                     */
                    highlightStyle(style:  Object): Object;
                    /**
                     * Gets or sets whether to ignore an empty value.
                     * @param {boolean} value Indicates whether to ignore the empty value.
                     * @returns {boolean | GC.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns whether to ignore the empty value; otherwise, returns the data validator.
                     * @example
                     * //This example uses the IgnoreBlank method.
                     * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.cellValueCondition);
                     * nCondition.compareType(GC.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators.equalsTo);
                     * nCondition.expected(0);
                     * //When the option is false, the validation fails and the red alert is displayed.
                     * //When the option is true, the blank cell is treated as zero and the validation is successful.
                     * nCondition.treatNullValueAsZero(false);
                     * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * validator.ignoreBlank(false);
                     * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, null);
                     */
                    ignoreBlank(value?:  boolean): any;
                    /**
                     * Gets or sets whether to display a drop-down button.
                     * @param {boolean} value Indicates whether to display a drop-down button.
                     * @returns {boolean | GC.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns whether to display a drop-down button; otherwise, returns the data validator.
                     * @example
                     * //This example uses the inCellDropdown method.
                     * spread.options.highlightInvalidData = true;
                     * var dv = GC.Spread.Sheets.DataValidation.createListValidator("1,2,3");
                     * dv.showInputMessage(true);
                     * dv.inputMessage("Value must be 1,2 or 3");
                     * dv.inputTitle("tip");
                     * dv.inCellDropdown(true);
                     * activeSheet.setDataValidator(1,1,1,1,dv,GC.Spread.Sheets.SheetArea.viewport);
                     * var validList = activeSheet.getDataValidator(1, 1).getValidList(activeSheet, 1, 1);
                     * alert(validList);
                     */
                    inCellDropdown(value?:  boolean): any;
                    /**
                     * Gets or sets the input message.
                     * @param {string} value The input message.
                     * @returns {string | GC.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns the input message; otherwise, returns the data validator.
                     * @example
                     * spread.options.highlightInvalidData = true;
                     * var dv = GC.Spread.Sheets.DataValidation.createListValidator("1,2,3");
                     * dv.showInputMessage(true);
                     * dv.inputMessage("Value must be 1,2 or 3");
                     * dv.inputTitle("tip");
                     * activeSheet.setDataValidator(1,1,1,1,dv,GC.Spread.Sheets.SheetArea.viewport);
                     * alert(activeSheet.getDataValidator(1,1).getValidList(activeSheet,1,1));
                     */
                    inputMessage(value?:  string): any;
                    /**
                     * Gets or sets the input title.
                     * @param {string} value The input title.
                     * @returns {string | GC.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns the input title; otherwise, returns the data validator.
                     * @example
                     * spread.options.highlightInvalidData = true;
                     * var dv = GC.Spread.Sheets.DataValidation.createListValidator("1,2,3");
                     * dv.showInputMessage(true);
                     * dv.inputMessage("Value must be 1,2 or 3");
                     * dv.inputTitle("tip");
                     * activeSheet.setDataValidator(1,1,1,1,dv,GC.Spread.Sheets.SheetArea.viewport);
                     * alert(activeSheet.getDataValidator(1,1).getValidList(activeSheet,1,1));
                     */
                    inputTitle(value?:  string): any;
                    /**
                     * Determines whether the current value is valid.
                     * @param {object} evaluator The evaluator.
                     * @param {number} baseRow The base row.
                     * @param {number} baseColumn The base column.
                     * @param {object} actual The current value.
                     * @returns {boolean} <c>true</c> if the value is valid; otherwise, <c>false</c>.
                     */
                    isValid(evaluator:  Object,  baseRow:  number,  baseColumn:  number,  actual:  Object): boolean;
                    /**
                     * Resets the data validator.
                     * @example
                     * //This example uses the reset method.
                     * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.cellValueCondition);
                     * nCondition.compareType(GC.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators.equalsTo);
                     * nCondition.expected(0);
                     * //When the option is false, the validation fails and the red alert is displayed.
                     * //When the option is true, the blank cell is treated as zero and the validation is successful.
                     * nCondition.treatNullValueAsZero(false);
                     * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * validator.ignoreBlank(false);
                     * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, null);
                     * validator.reset();
                     */
                    reset(): void;
                    /**
                     * Gets or sets whether to display an error message.
                     * @param {boolean} value Indicates whether to display an error message.
                     * @returns {boolean | GC.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns whether to display an error message; otherwise, returns the data validator.
                     * @example
                     * spread.options.highlightInvalidData = true;
                     * //The formula validator is valid if the formula condition returns true.
                     * var dv = GC.Spread.Sheets.DataValidation.createFormulaValidator("A1&gt;0");
                     * dv.showInputMessage(true);
                     * dv.inputMessage("Enter a value greater than 0 in A1.");
                     * dv.inputTitle("Tip");
                     * dv.showErrorMessage(true);
                     * dv.errorMessage("Incorrect Value");
                     * activeSheet.setDataValidator(0, 0, 1, 1, dv, GC.Spread.Sheets.SheetArea.viewport);
                     * //bind
                     * activeSheet.bind(GC.Spread.Sheets.Events.ValidationError, function (sender, args) {
                     *     if (args.validator.showErrorMessage()) {
                     *         if (confirm(args.validator.errorMessage())) {
                     *             args.validationResult = GC.Spread.Sheets.DataValidation.DataValidationResult.retry;
                     *         } else {
                     *             args.validationResult = GC.Spread.Sheets.DataValidation.DataValidationResult.forceApply;
                     *         }
                     *     }
                     * });
                     */
                    showErrorMessage(value?:  boolean): any;
                    /**
                     * Gets or sets whether to display the input title and input message.
                     * @param {boolean} value Indicates whether to display the input title and input message.
                     * @returns {boolean | GC.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns whether to display the input title and input message; otherwise, returns the data validator.
                     * @example
                     * spread.options.highlightInvalidData = true;
                     * var dv = GC.Spread.Sheets.DataValidation.createListValidator("1,2,3");
                     * dv.showInputMessage(true);
                     * dv.inputMessage("Value must be 1,2 or 3");
                     * dv.inputTitle("tip");
                     * activeSheet.setDataValidator(1,1,1,1,dv,GC.Spread.Sheets.SheetArea.viewport);
                     * alert(activeSheet.getDataValidator(1,1).getValidList(activeSheet,1,1));
                     */
                    showInputMessage(value?:  boolean): any;
                    /**
                     * Gets or sets the criteria type of this data validator.
                     * @param {GC.Spread.Sheets.DataValidation.CriteriaType} value The criteria type of this data validator.
                     * @returns {GC.Spread.Sheets.DataValidation.CriteriaType | GC.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns the criteria type of this data validator; otherwise, returns the data validator.
                     */
                    type(value?:  GC.Spread.Sheets.DataValidation.CriteriaType): any;
                    /**
                     * Gets the first value of the data validation.
                     * @param {number} baseRow The base row.
                     * @param {number} baseColumn The base column.
                     * @returns {object} The first value.
                     * @example
                     * //This example validates a cell value.
                     * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.cellValueCondition);
                     * nCondition.compareType(GC.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators.equalsTo);
                     * nCondition.expected(0);
                     * //When the option is false, the validation fails and the red alert is displayed.
                     * //When the option is true, the blank cell is treated as zero and the validation is successful.
                     * nCondition.treatNullValueAsZero(false);
                     * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * validator.ignoreBlank(false);
                     * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, null);
                     * alert(validator.value1());
                     */
                    value1(baseRow ?:  number,  baseColumn ?:  number): any;
                    /**
                     * Gets the second value of the data validation.
                     * @param {number} baseRow The base row.
                     * @param {number} baseColumn The base column.
                     * @returns {object} The second value.
                     * @example
                     * //This example validates a cell value.
                     * var nCondition = new GC.Spread.Sheets.ConditionalFormatting.Condition(GC.Spread.Sheets.ConditionalFormatting.ConditionType.cellValueCondition);
                     * nCondition.compareType(GC.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators.equalsTo);
                     * nCondition.expected(0);
                     * //When the option is false, the validation fails and the red alert is displayed.
                     * //When the option is true, the blank cell is treated as zero and the validation is successful.
                     * nCondition.treatNullValueAsZero(false);
                     * var validator = new GC.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GC.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * validator.ignoreBlank(false);
                     * activeSheet.getCell(0, 0, GC.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, null);
                     * alert(validator.value2());
                     */
                    value2(baseRow ?:  number,  baseColumn ?:  number): any;
                }
            }

            module Fill{
                // <editor-fold desc="AutoFillType">
                 /**
                 * Represents the type of drag fill.
                 * @enum {number}
                 * @example
                 * //This example uses the AutoFillType enumeration.
                 * activeSheet.bind(GC.Spread.Sheets.Events.DragFillBlockCompleted, function (e, info) {
                 *         alert("Type (" + info.autoFillType + ")");
                 * });
                 */
                export enum AutoFillType{
                    /**
                     *  Fills cells with all data objects, including values, formatting, and formulas.
                     */
                    copyCells= 0,
                    /**
                     *   Fills cells with series.
                     */
                    fillSeries= 1,
                    /**
                     *   Fills cells only with formatting.
                     */
                    fillFormattingOnly= 2,
                    /**
                     *   Fills cells with values and not formatting.
                     */
                    fillWithoutFormatting= 3,
                    /**
                     *  Clears cell values.
                     */
                    clearValues= 4,
                    /**
                     *  Automatically fills cells.
                     */
                    auto= 5
                }

                // <editor-fold desc="FillDateUnit">
                 /**
                 * Represents the date fill unit.
                 * @enum {number}
                 * @example
                 * //This example uses the FillDateUnit enumeration.
                 * spread.options.allowUserDragFill = true;
                 * activeSheet.setValue(0, 0, new Date(2011, 1, 1));
                 * activeSheet.setValue(0, 1, new Date(2011, 2, 9));
                 * activeSheet.setValue(0, 2, 5);
                 * activeSheet.setValue(0, 3, 10);
                 * activeSheet.setValue(0, 4, 1);
                 *
                 * var start = new GC.Spread.Sheets.Range(0, 0, 1, 1);
                 * var r = new GC.Spread.Sheets.Range(0, 0, 4, 1);
                 * activeSheet.fillAuto(start, r, {
                 *     fillType: GC.Spread.Sheets.Fill.FillType.date,
                 *     series: GC.Spread.Sheets.Fill.FillSeries.column,
                 *     fillDirection: GC.Spread.Sheets.Fill.FillDirection.down,
                 *     unit: GC.Spread.Sheets.Fill.FillDateUnit.day,
                 *     step: 1,
                 *     stop: new Date(2011, 2, 11)
                 * });
                 *
                 * start = new GC.Spread.Sheets.Range(0, 1, 1, 1);
                 * var r2 = new GC.Spread.Sheets.Range(0, 1, 4, 1);
                 * activeSheet.fillAuto(start, r2, {
                 * fillType: GC.Spread.Sheets.Fill.FillType.date,
                 * series: GC.Spread.Sheets.Fill.FillSeries.column,
                 * fillDirection:GC.Spread.Sheets.Fill.FillDirection.down,
                 * unit: GC.Spread.Sheets.Fill.FillDateUnit.day,
                 * step: 1,
                 * stop: new Date(2011, 2, 11)
                 * });
                 *
                 * start = new GC.Spread.Sheets.Range(0, 2, 1, 1);
                 * var r3 = new GC.Spread.Sheets.Range(0, 2, 4, 1);
                 * activeSheet.fillAuto(start, r3, {
                 *     fillType: GC.Spread.Sheets.Fill.FillType.auto,
                 *     series: GC.Spread.Sheets.Fill.FillSeries.column,
                 * });
                 *
                 * start = new GC.Spread.Sheets.Range(0, 3, 1, 1);
                 * var r4 = new GC.Spread.Sheets.Range(0, 3, 4, 1);
                 * activeSheet.fillAuto(start, r4, {
                 *     fillType: GC.Spread.Sheets.Fill.FillType.growth,
                 *     series: GC.Spread.Sheets.Fill.FillSeries.column,
                 *     step:2,
                 *     stop:55
                 * });
                 *
                 * start = new GC.Spread.Sheets.Range(0, 4, 1, 1);
                 * var r5 = new GC.Spread.Sheets.Range(0, 4, 4, 1);
                 * activeSheet.fillAuto(start, r5, {
                 *     fillType: GC.Spread.Sheets.Fill.FillType.linear,
                 *     series: GC.Spread.Sheets.Fill.FillSeries.column,
                 *     step:3,
                 *     stop:20
                 * });
                 *
                 * activeSheet.setValue(0, 5, 123);
                 * var r6 = new GC.Spread.Sheets.Range(0, 5, 4, 1);
                 * activeSheet.fillAuto(new GC.Spread.Sheets.Range(0, 5, 1, 1), r6, {
                 *     fillType: GC.Spread.Sheets.Fill.FillType.auto,
                 *     series: GC.Spread.Sheets.Fill.FillSeries.column,
                 * });
                 */
                export enum FillDateUnit{
                    /** Sets the date fill unit to day.
                     * @type {number}
                     */
                    day= 0,
                    /** Sets the date fill unit to weekday.
                     * @type {number}
                     */
                    weekday= 1,
                    /** Sets the date fill unit to month.
                     * @type {number}
                     */
                    month= 2,
                    /** Sets the date fill unit to year.
                     * @type {number}
                     */
                    year= 3
                }

                // <editor-fold desc="FillDirection">
                 /**
                 * Represents the type of drag fill direction.
                 * @enum {number}
                 * @example
                 * var start = new GC.Spread.Sheets.Range(0, 2, 1, 1);
                 * activeSheet.setValue(0, 2, 5);
                 * var r3 = new GC.Spread.Sheets.Range(0, 2, 4, 1);
                 * activeSheet.fillAuto(start, r3, {fillType: GC.Spread.Sheets.Fill.FillType.auto, fillDirection:GC.Spread.Sheets.Fill.FillDirection.down, series: GC.Spread.Sheets.Fill.FillSeries.column});
                 */
                export enum FillDirection{
                    /**
                     *  Fills from the right to the left.
                     */
                    left= 0,
                    /**
                     *  Fills from the left to the right.
                     */
                    right= 1,
                    /**
                     *  Fills from the bottom to the top.
                     */
                    up= 2,
                    /**
                     *   Fills from the top to the bottom.
                     */
                    down= 3
                }

                // <editor-fold desc="FillSeries">
                 /**
                 * Represents the fill series for drag fill.
                 * @enum {number}
                 * @example
                 * //This example automatically fills the data in an area of the sheet.
                 * activeSheet.setValue(0, 0, 5);
                 * var start = new GC.Spread.Sheets.Range(0, 0, 1, 1);
                 * var r3 = new GC.Spread.Sheets.Range(0, 0, 4, 1);
                 * activeSheet.fillAuto(start,r3, {fillType:GC.Spread.Sheets.Fill.FillType.auto, series:GC.Spread.Sheets.Fill.FillSeries.column, fillDirection:GC.Spread.Sheets.Fill.FillDirection.down});
                 */
                export enum FillSeries{
                    /**
                     *  Fills the column data.
                     */
                    column= 0,
                    /**
                     *  Fills the row data.
                     */
                    row= 1
                }

                // <editor-fold desc="FillType">
                 /**
                 * Represents the type of fill data.
                 * @enum {number}
                 */
                export enum FillType{
                    /** Represents the direction fill type.
                     * @type {number}
                     */
                    direction= 0,
                    /** Represents the linear fill type.
                     * @type {number}
                     */
                    linear= 1,
                    /** Represents the growth fill type.
                     * @type {number}
                     */
                    growth= 2,
                    /** Represents the date fill type.
                     * @type {number}
                     */
                    date= 3,
                    /** Represents the auto fill type.
                     * @type {number}
                     */
                    auto= 4
                }

            }

            module Filter{

                export interface IFilterDialogVisibleInfo{
                    sortByValue? : boolean,
                    sortByColor? : boolean,
                    filterByColor? : boolean,
                    filterByValue? : boolean,
                    listFilterArea? : boolean
                }


                export interface IFilteredArgs{
                    action: FilterActionType;
                    sheet: Sheets.Worksheet;
                    range: Sheets.Range;
                    filteredRows: number[];
                    filteredOutRows: number[];
                    columns: number;
                }

                /**
                 * Defines the type of filter action.
                 * @enum {number}
                 */
                export enum FilterActionType{
                    /** Specifies the filter action.
                     */
                    filter= 0,
                    /** Specifies the unfilter action.
                     */
                    unfilter= 1
                }


                export class HideRowFilter extends RowFilterBase{
                    /**
                     * Represents a default row filter.
                     * @class GC.Spread.Sheets.Filter.HideRowFilter
                     * @extends GC.Spread.Sheets.Filter.RowFilterBase
                     * @param {GC.Spread.Sheets.Range} range The filter range.
                     * @example
                     * //The following example creates a new filter.
                     * sheet.rowFilter(new GC.Spread.Sheets.Filter.HideRowFilter(new GC.Spread.Sheets.Range(0,0,4,4)));
                     * sheet.repaint();
                     */
                    constructor(range?:  GC.Spread.Sheets.Range);
                    /**
                     * Gets or sets the visible info for the row filter.
                     * @param {Object} visibleInfo The visible info for row filter.
                     * @param {boolean} [visibleInfo.sortByValue] Whether to show the sort by value area in filter dialog.
                     * @param {boolean} [visibleInfo.sortByColor] Whether to show the sort by color area in filter dialog.
                     * @param {boolean} [visibleInfo.filterByColor] Whether to show the filter by color area in filter dialog.
                     * @param {boolean} [visibleInfo.filterByValue] Whether to show the filter by value area in filter dialog.
                     * @param {boolean} [visibleInfo.listFilterArea] Whether to show the list filter in filter dialog.
                     * @returns {Object | GC.Spread.Sheets.Filter.HideRowFilter} If no value is set filter dialog visible info; otherwise, returns the HideRowFilter.
                     * @example
                     * //This example creates a row filter.
                     *  sheet.rowFilter(new GC.Spread.Sheets.Filter.HideRowFilter(new GC.Spread.Sheets.Range(1,1,10,3)));
                     *  var filter = sheet.rowFilter();
                     *  filter.filterDialogVisibleInfo({
                     *           sortByValue : false,
                     *           sortByColor : true,
                     *           filterByColor : true,
                     *           filterByValue : true,
                     *           listFilterArea : false
                     *       })
                     */
                    filterDialogVisibleInfo(visibleInfo?:  GC.Spread.Sheets.Filter.IFilterDialogVisibleInfo): any;
                }

                export class RowFilterBase{
                    /**
                     * Represents a row filter base that supports row filters for filtering rows in a sheet.
                     * @class GC.Spread.Sheets.Filter.RowFilterBase
                     * @param {GC.Spread.Sheets.Range} range The filter range.
                     */
                    constructor(range?:  GC.Spread.Sheets.Range);
                    /**
                     * Represents the range for the row filter.
                     * @type {GC.Spread.Sheets.Range}
                     */
                    range: GC.Spread.Sheets.Range;
                    /**
                     * Represents the type name string used for supporting serialization.
                     * @type {string}
                     */
                    typeName: string;
                    /**
                     * Adds a specified filter to the row filter.
                     * @param {number} col The column index.
                     * @param {GC.Spread.Sheets.ConditionalFormatting.Condition} condition The condition to filter.
                     */
                    addFilterItem(col:  number,  condition:  GC.Spread.Sheets.ConditionalFormatting.Condition): void;
                    /**
                     * Filters the specified column.
                     * @param {number} col The index of the column to be filtered; if it is omitted, all the columns in the range will be filtered.
                     */
                    filter(col?:  number): void;
                    /**
                     * Gets or sets whether the sheet column's filter button is displayed.
                     * @param {number} col The column index of the filter button.
                     * @param {boolean} value Whether the filter button is displayed.
                     * @returns {boolean | GC.Spread.Sheets.Filter.RowFilterBase}
                     *      No parameter <c>false</c> if all filter buttons are invisible; otherwise, <c>true</c>.
                     *      One parameter col <c>false</c> if the specified column filter button is invisible; otherwise, <c>true</c>.
                     *      One parameter value <c>GC.Spread.Sheets.Filter.RowFilterBase</c> sets all filter buttons to be visible(true)/invisible(false).
                     *      Two parameters col,value <c>GC.Spread.Sheets.Filter.RowFilterBase</c> sets the specified column filter button to be visible(true)/invisible(false).
                     */
                    filterButtonVisible(col?:  number,  value?:  boolean): any;
                    /**
                     * Loads the object state from the specified JSON string.
                     * @param {object} settings The row filter data from deserialization.
                     */
                    fromJSON(settings:  Object): void;
                    /**
                     * Gets all the filtered conditions.
                     * @returns {Array} Returns a collection that contains all the filtered conditions.
                     */
                    getFilteredItems(): any[];
                    /**
                     * Gets the filters for the specified column.
                     * @param {number} col The column index.
                     * @returns {Array} Returns a collection that contains conditions that belong to a specified column.
                     */
                    getFilterItems(col:  number): any[];
                    /**
                     * Gets the current sort state.
                     * @param {number} col The column index.
                     * @returns {GC.Spread.Sheets.SortState} The sort state of the current filter.
                     */
                    getSortState(col:  number): GC.Spread.Sheets.SortState;
                    /**
                     * Gets a value that indicates whether any row or specified column is filtered.
                     * @param {number} col The column index.
                     * @returns {boolean}  No parameter <c>true</c> if some rows are filtered; otherwise, <c>false</c>.
                     *                     One parameter col <c>true</c> if the specified column is filtered; otherwise, <c>false</c>.
                     * @example
                     * //This example uses the isFiltered method.
                     * activeSheet.setValue(0, 0, "North");
                     * activeSheet.setValue(1, 0, "South");
                     * activeSheet.setValue(2, 0, "East");
                     * activeSheet.setValue(3, 0, "South");
                     * activeSheet.setValue(4, 0, "North");
                     * activeSheet.setValue(5, 0, "North");
                     * activeSheet.setValue(6, 0, "West");
                     * activeSheet.setColumnWidth(0, 80);
                     * //Set a row filter.
                     * activeSheet.rowFilter(new GC.Spread.Sheets.Filter.HideRowFilter(new GC.Spread.Sheets.Range(0, 0, 7, 1)));
                     * //button
                     * $("#button1").click(function () {
                     *     var rowFilter = spread.getActiveSheet().rowFilter();
                     *     if (rowFilter.isFiltered(0)) {
                     *         alert("Row-filtering executed for Column1");
                     *     } else {
                     *         alert("Row-filtering not executed for Column1");
                     *     }
                     * });
                     * //Add button control to page
                     * &lt;input type="button" id="button1" value="button1"/&gt;
                     */
                    isFiltered(col?:  number): boolean;
                    /**
                     * Determines whether the specified row is filtered out.
                     * @param {number} row The row index.
                     * @returns {boolean} <c>true</c> if the row is filtered out; otherwise, <c>false</c>.
                     */
                    isRowFilteredOut(row:  number): boolean;
                    /**
                     * Performs the action when some columns have just been filtered or unfiltered.
                     * @param {object} args An object that contains the <i>action</i>, <i>sheet</i>, <i>range</i>, <i>filteredRows</i>, and <i>filteredOutRows</i>. See the Remarks for additional information.
                     */
                    onFilter(args:  IFilteredArgs): void;
                    /**
                     * Opens the filter dialog when the user clicks the filter button.
                     * @param {object} filterButtonHitInfo The hit test information about the filter button.
                     */
                    openFilterDialog(filterButtonHitInfo:  IFilterButtonHitInfo): void;
                    /**
                     * Removes the specified filter.
                     * @param {number} col The column index.
                     */
                    removeFilterItems(col:  number): void;
                    /**
                     * Clears all filters.
                     */
                    reset(): any;
                    /**
                     * Sorts the specified column in the specified order.
                     * @param {number} col The column index.
                     * @param {boolean} ascending Set to <c>true</c> to sort as ascending.
                     */
                    sortColumn(col:  number,  ascending:  boolean): void;
                    /**
                     * Saves the object state to a JSON string.
                     * @returns {object} The row filter data.
                     */
                    toJSON(): Object;
                    /**
                     * Removes the filter from the specified column.
                     * @param {number} col The index of the column for which to remove the filter; if it is omitted, removes the filter for all columns in the range.
                     */
                    unfilter(col?:  number): void;
                }
            }

            module FloatingObjects{

                export class FloatingObject{
                    /**
                     * Represents a floating object.
                     * @class
                     * @param {string} name The name of the floating object.
                     * @param {number} x The <i>x</i> location of the floating object.
                     * @param {number} y The <i>y</i> location of the floating object.
                     * @param {number} width The width of the floating object.
                     * @param {number} height The height of the floating object.
                     * @remarks
                     * This is a base class that is intended for internal use.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    constructor(name:  string,  x:  number,  y:  number,  width:  number,  height:  number);
                    /** Represents the type name string used for supporting serialization.
                     * @type {string}
                     */
                    typeName: string;
                    /**
                     * Gets or sets whether to disable moving the floating object.
                     * @param {boolean} value The setting for whether to disable moving the floating object.
                     * @returns {boolean | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the setting for whether to disable moving the floating object; otherwise, returns the floating object.
                     * @example
                     * //This example prevents you from moving or resizing the floating object.
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.allowResize(false);
                     * customFloatingObject.allowMove(false);
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    allowMove(value?:  boolean): any;
                    /**
                     * Gets or sets whether to disable resizing the floating object.
                     * @param {boolean} value The setting for whether to disable resizing the floating object.
                     * @returns {boolean | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the setting for whether to disable resizing the floating object; otherwise, returns the floating object.
                     * @example
                     * //This example prevents you from moving or resizing the floating object.
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.allowResize(false);
                     * customFloatingObject.allowMove(false);
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    allowResize(value?:  boolean): any;
                    /**
                     * Gets a copy of the current content of the instance.
                     * @returns {HTMLElement} A copy of the current content of the instance.
                     */
                    cloneContent(): HTMLElement;
                    /**
                     * Gets or sets the content of the custom floating object.
                     * @param {HTMLElement} value The content of the custom floating object.
                     * @returns {object | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the content of the custom floating object; otherwise, returns the floating object.
                     */
                    content(value?:  HTMLElement): any;
                    /**
                     * Gets or sets whether the object moves when hiding or showing, resizing, or moving rows or columns.
                     * @param {boolean} value The value indicates whether the object moves when hiding or showing, resizing, or moving rows or columns.
                     * @returns {boolean | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns whether this floating object dynamically moves; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * customFloatingObject.isVisible(true);
                     * customFloatingObject.dynamicSize(true);
                     * customFloatingObject.dynamicMove(true);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    dynamicMove(value?:  boolean): any;
                    /**
                     * Gets or sets whether the size of the object changes when hiding or showing, resizing, or moving rows or columns.
                     * @param {boolean} value The value indicates whether the size of the object changes when hiding or showing, resizing, or moving rows or columns.
                     * @returns {boolean | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns whether this floating object dynamically changes size; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * customFloatingObject.isVisible(true);
                     * customFloatingObject.dynamicSize(true);
                     * customFloatingObject.dynamicMove(true);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    dynamicSize(value?:  boolean): any;
                    /**
                     * Gets or sets the end column index of the floating object position.
                     * @param {number} value The end column index of the floating object position.
                     * @returns {number | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the end column index of the floating object position; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     * //takes effect when added into the sheet.
                     * customFloatingObject.startRow(2);
                     * customFloatingObject.startColumn(2);
                     * customFloatingObject.startRowOffset(10);
                     * customFloatingObject.startColumnOffset(10);
                     * customFloatingObject.endRow(7);
                     * customFloatingObject.endColumn(5);
                     * customFloatingObject.endRowOffset(10);
                     * customFloatingObject.endColumnOffset(10);
                     */
                    endColumn(value?:  number): any;
                    /**
                     * Gets or sets the offset relative to the end column of the floating object.
                     * @param {number} value The offset relative to the end column of the floating object.
                     * @returns {number | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the offset relative to the end column of the floating object; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     * //takes effect when added into the sheet.
                     * customFloatingObject.startRow(2);
                     * customFloatingObject.startColumn(2);
                     * customFloatingObject.startRowOffset(10);
                     * customFloatingObject.startColumnOffset(10);
                     * customFloatingObject.endRow(7);
                     * customFloatingObject.endColumn(5);
                     * customFloatingObject.endRowOffset(10);
                     * customFloatingObject.endColumnOffset(10);
                     */
                    endColumnOffset(value?:  number): any;
                    /**
                     * Gets or sets the end row index of the floating object position.
                     * @param {number} value The end row index of the floating object position.
                     * @returns {number | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the end row index of the floating object position; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     * //takes effect when added into the sheet.
                     * customFloatingObject.startRow(2);
                     * customFloatingObject.startColumn(2);
                     * customFloatingObject.startRowOffset(10);
                     * customFloatingObject.startColumnOffset(10);
                     * customFloatingObject.endRow(7);
                     * customFloatingObject.endColumn(5);
                     * customFloatingObject.endRowOffset(10);
                     * customFloatingObject.endColumnOffset(10);
                     */
                    endRow(value?:  number): any;
                    /**
                     * Gets or sets the offset relative to the end row of the floating object.
                     * @param {number} value The offset relative to the end row of the floating object.
                     * @returns {number | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the offset relative to the end row of the floating object; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     * //takes effect when added into the sheet.
                     * customFloatingObject.startRow(2);
                     * customFloatingObject.startColumn(2);
                     * customFloatingObject.startRowOffset(10);
                     * customFloatingObject.startColumnOffset(10);
                     * customFloatingObject.endRow(7);
                     * customFloatingObject.endColumn(5);
                     * customFloatingObject.endRowOffset(10);
                     * customFloatingObject.endColumnOffset(10);
                     */
                    endRowOffset(value?:  number): any;
                    /**
                     * Gets or sets whether the position of the floating object is fixed. When fixedPosition is true, dynamicMove and dynamicSize are disabled.
                     * @param {boolean} value The value indicates whether the position of the floating object is fixed.
                     * @returns {boolean | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns whether the position of the floating object is fixed; otherwise, returns the floating object.
                     * @example
                     * //This example sets the position of the object to fixed.
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * customFloatingObject.fixedPosition(true);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    fixedPosition(value:  boolean): any;
                    /**
                     * Gets the dom host of the custom content.
                     * @returns {Array.<HTMLElement>}
                     */
                    getHost(): HTMLElement[];
                    /**
                     * Gets or sets the height of a floating object.
                     * @param {number} value The height of a floating object.
                     * @returns {number | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the height of a floating object; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1");
                     * customFloatingObject.x(10);
                     * customFloatingObject.y(10);
                     * customFloatingObject.width(60);
                     * customFloatingObject.height(64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    height(value?:  number): any;
                    /**
                     * Gets or sets whether this floating object is locked.
                     * @param {boolean} value The value that indicates whether this floating object is locked.
                     * @returns {boolean | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns whether this floating object is locked; otherwise, returns the floating object.
                     * @example
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1");
                     * customFloatingObject.x(10);
                     * customFloatingObject.y(10);
                     * customFloatingObject.width(60);
                     * customFloatingObject.height(64);
                     * customFloatingObject.isLocked(true);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     * activeSheet.options.isProtected = true;
                     */
                    isLocked(value?:  boolean): any;
                    /**
                     * Gets or sets whether this floating object is selected.
                     * @param {boolean} value The value that indicates whether this floating object is selected.
                     * @returns {boolean | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns whether this floating object is selected; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * customFloatingObject.isSelected(true);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    isSelected(value?:  boolean): any;
                    /**
                     * Gets or sets whether this floating object is visible.
                     * @param {boolean} value The value that indicates whether this floating object is visible.
                     * @returns {boolean | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns whether this floating object is visible; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * customFloatingObject.isVisible(true);
                     * customFloatingObject.dynamicSize(true);
                     * customFloatingObject.dynamicMove(true);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    isVisible(value?:  boolean): any;
                    /**
                     * Gets the name of the floating object.
                     * @param {string} value The name of the floating object.
                     * @returns {string | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the name of the floating object; otherwise, returns the floating object.
                     * @example
                     * //This example uses the name method.
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject();
                     * customFloatingObject.name("f1");
                     * customFloatingObject.x(10);
                     * customFloatingObject.y(10);
                     * customFloatingObject.width(60);
                     * customFloatingObject.height(64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    name(value?:  string): any;
                    /**
                     * Refresh the content in floatingObject.The user should override this method to make their content synchronize with the floatingObject.
                     */
                    refreshContent(): void;
                    /**
                     * Gets or sets the starting column index of the floating object position.
                     * @param {number} value The starting column index of the floating object position.
                     * @returns {number | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the starting column index of the floating object position; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     * //takes effect when added into the sheet.
                     * customFloatingObject.startRow(2);
                     * customFloatingObject.startColumn(2);
                     * customFloatingObject.startRowOffset(10);
                     * customFloatingObject.startColumnOffset(10);
                     */
                    startColumn(value?:  number): any;
                    /**
                     * Gets or sets the offset relative to the start column of the floating object.
                     * @param {number} value The offset relative to the start column of the floating object.
                     * @returns {number | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the offset relative to the start column of the floating object; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     * //takes effect when added into the sheet.
                     * customFloatingObject.startRow(2);
                     * customFloatingObject.startColumn(2);
                     * customFloatingObject.startRowOffset(10);
                     * customFloatingObject.startColumnOffset(10);
                     */
                    startColumnOffset(value?:  number): any;
                    /**
                     * Gets or sets the starting row index of the floating object position.
                     * @param {number} value The starting row index of the floating object position.
                     * @returns {number | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the starting row index of the floating object position; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     * //takes effect when added into the sheet.
                     * customFloatingObject.startRow(2);
                     * customFloatingObject.startColumn(2);
                     * customFloatingObject.startRowOffset(10);
                     * customFloatingObject.startColumnOffset(10);
                     */
                    startRow(value?:  number): any;
                    /**
                     * Gets or sets the offset relative to the start row of the floating object.
                     * @param {number} value The offset relative to the start row of the floating object.
                     * @returns {number | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the offset relative to the start row of the floating object; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     * //takes effect when added into the sheet.
                     * customFloatingObject.startRow(2);
                     * customFloatingObject.startColumn(2);
                     * customFloatingObject.startRowOffset(10);
                     * customFloatingObject.startColumnOffset(10);
                     */
                    startRowOffset(value?:  number): any;
                    /**
                     * Gets or sets the width of a floating object.
                     * @param {number} value The width of a floating object.
                     * @returns {number | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the width of a floating object; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1");
                     * customFloatingObject.x(10);
                     * customFloatingObject.y(10);
                     * customFloatingObject.width(60);
                     * customFloatingObject.height(64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    width(value?:  number): any;
                    /**
                     * Gets or sets the horizontal location of the floating object.
                     * @param {number} value The horizontal location of the floating object.
                     * @return {number | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the horizontal location of the floating object; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1");
                     * customFloatingObject.x(10);
                     * customFloatingObject.y(10);
                     * customFloatingObject.width(60);
                     * customFloatingObject.height(64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    x(value?:  number): any;
                    /**
                     * Gets or sets the vertical location of the floating object.
                     * @param {number} value The vertical location of the floating object.
                     * @return {number | GC.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the vertical location of the floating object; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1");
                     * customFloatingObject.x(10);
                     * customFloatingObject.y(10);
                     * customFloatingObject.width(60);
                     * customFloatingObject.height(64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    y(value?:  number): any;
                }

                export class FloatingObjectCollection{
                    /**
                     * Represents a floating object manager that managers all floating objects in a sheet.
                     * @class
                     * @param {GC.Spread.Sheets.Worksheet} sheet The worksheet.
                     * @param {string} typeName The type name.
                     */
                    constructor();
                    /**
                     * Adds a floating object to the sheet.
                     * The arguments has 2 modes.
                     * If there is 1 parameter, the parameter is floatingObject which is a GC.Spread.Sheets.FloatingObjects.FloatingObject type.
                     * If there are 6 parameters, the parameters are name, src, x, y, width, and height.
                     * @param {GC.Spread.Sheets.FloatingObjects.FloatingObject|string} floatingObjectOrName The floating object that will be added to the sheet, or the name of the picture that will be added to the sheet.
                     * @param {string} src The image source of the picture.
                     * @param {number} x The x location of the picture.
                     * @param {number} y The y location of the picture.
                     * @param {number} width The width of the picture.
                     * @param {number} height The height of the picture.
                     * @return {GC.Spread.Sheets.FloatingObjects.FloatingObject} The floating object that has been added to the sheet.
                     * @example
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    add(floatingObjectOrName:  Object,  src?:  string,  x?:  number,  y?:  number,  width?:  number,  height?:  number): Object;
                    /**
                     * Gets all of the floating objects in the sheet.
                     * @return {Array} The collection of all the floating objects in the sheet.
                     * @example
                     * activeSheet.pictures.add("p1", "pics/download.jpg", 1, 6, 400, 400);
                     * activeSheet.pictures.add("p2", "pics/download.jpg", 500, 150, 200, 300);
                     * var pictures = activeSheet.pictures.all();
                     * for (var i = 0; i &lt; pictures.length; i++) {
                     *     alert("Path of picture " + i + " is:  " + pictures[i].src())
                     * }
                     */
                    all(): GC.Spread.Sheets.FloatingObjects.FloatingObject[];
                    /**
                     * Removes all floating objects in the sheet.
                     */
                    clear(): void;
                    /**
                     * Gets a floating object from the sheet by the indicate name.
                     * @param {string} name The name of the floating object.
                     * @return {GC.Spread.Sheets.FloatingObjects.FloatingObject} The floating object in the sheet with the indicate name.
                     * @example
                     * activeSheet.pictures.add("f2","tsoutline.png",100,60,200,100);
                     * //button
                     * $("#button1").click(function () {
                     *  var pic = activeSheet.pictures.get("f2");
                     * });
                     */
                    get(name:  string): GC.Spread.Sheets.FloatingObjects.FloatingObject;
                    /**
                     * Removes a floating object from the sheet by the indicate name.
                     * @param {string} name The name of the floating object.
                     * @example
                     * activeSheet.pictures.add("f2","tsoutline.png",100,60,200,100);
                     * //button
                     * $("#button1").click(function () {
                     *      activeSheet.resumePaint();
                     *      activeSheet.pictures.remove("f2");
                     *      activeSheet.repaint();
                     * });
                     */
                    remove(name:  string): void;
                    /**
                     * Gets or sets the z-index of floating object.
                     * @param {string} name The name of the floatingObject.
                     * @param {number} zIndex The z-index of the floating object.
                     * @return {number | *} If the parameter 'zIndex' is null or undefined,it will return the z-index of the floating object with the indicate name.
                     * @example
                     * var customFloatingObject = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f1", 20, 20, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button1";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     * var customFloatingObject1 = new GC.Spread.Sheets.FloatingObjects.FloatingObject("f2", 5, 5, 30, 64);
                     * var btn1 = document.createElement('button');
                     * btn1.style.width = "60px";
                     * btn1.style.height = "30px";
                     * btn1.innerText = "button2";
                     * customFloatingObject1.content(btn1);
                     * activeSheet.floatingObjects.add(customFloatingObject1);
                     * activeSheet.floatingObjects.zIndex("f2", 897);
                     * activeSheet.floatingObjects.zIndex("f1", 898);
                     */
                    zIndex(name:  string,  zIndex?:  number): any;
                }

                export class Picture extends FloatingObject{
                    /**
                     * Represents a picture.
                     * @extends GC.Spread.Sheets.FloatingObjects.FloatingObject
                     * @class
                     * @param {string} name The name of the picture.
                     * @param {string} src The image source of the picture.
                     * @param {number} x The <i>x</i> location of the picture.
                     * @param {number} y The <i>y</i> location of the picture.
                     * @param {number} width The width of the picture.
                     * @param {number} height The height of the picture.
                     */
                    constructor(name:  string,  src:  string,  x:  number,  y:  number,  width:  number,  height:  number);
                    /**
                     * Gets or sets the background color of the picture.
                     * @param {string} value The backcolor of the picture.
                     * @returns {string | GC.Spread.Sheets.FloatingObjects.Picture} If no value is set, returns the backcolor of the picture; otherwise, returns the picture.
                     * @example
                     * //This example sets the backcolor of the picture.
                     * activeSheet.pictures.add("f2","Event.png",2,2,10,10);
                     * var picture = activeSheet.pictures.get("f2");
                     * picture.pictureStretch(GC.Spread.Sheets.ImageLayout.stretch);
                     * picture.backColor("Blue");
                     * picture.borderWidth(2);
                     * picture.borderColor("Red");
                     */
                    backColor(value?:  string): any;
                    /**
                     * Gets or sets the border color of the picture.
                     * @param {string} value The border color of the picture.
                     * @returns {Object | GC.Spread.Sheets.FloatingObjects.Picture} If no value is set, returns the border color of the picture; otherwise, returns the picture.
                     * @example
                     * //This example sets the border color of the picture.
                     * activeSheet.pictures.add("f2","Event.png",2,2,10,10);
                     * var picture = activeSheet.pictures.get("f2");
                     * picture.pictureStretch(GC.Spread.Sheets.ImageLayout.stretch);
                     * picture.backColor("Blue");
                     * picture.borderWidth(2);
                     * picture.borderColor("Red");
                     */
                    borderColor(value?:  string): any;
                    /**
                     * Gets or sets the border radius of the picture.
                     * @param {number} value The border radius of the picture.
                     * @returns {number | GC.Spread.Sheets.FloatingObjects.Picture} If no value is set, returns the border radius of the picture; otherwise, returns the picture.
                     * @example
                     * //This example uses the borderRadius method.
                     * activeSheet.pictures.add("f2","Event.png",2,2,10,10);
                     * var picture = activeSheet.pictures.get("f2");
                     * picture.pictureStretch(GC.Spread.Sheets.ImageLayout.center);
                     * picture.backColor("Blue");
                     * picture.borderWidth(2);
                     * picture.borderColor("Red");
                     * picture.borderStyle("dotted");
                     * picture.borderRadius(5);
                     */
                    borderRadius(value?:  number): any;
                    /**
                     * Gets or sets the border style of the picture.
                     * @param {string} value The css border style of the picture, such as dotted, dashed, solid, and so on.
                     * @returns {string | GC.Spread.Sheets.FloatingObjects.Picture} If no value is set, returns the border style of the picture; otherwise, returns the picture.
                     * @example
                     * //This example uses the borderStyle method.
                     * activeSheet.pictures.add("f2","Event.png",2,2,10,10);
                     * var picture = activeSheet.pictures.get("f2");
                     * picture.pictureStretch(GC.Spread.Sheets.ImageLayout.center);
                     * picture.backColor("Blue");
                     * picture.borderWidth(2);
                     * picture.borderColor("Red");
                     * picture.borderStyle("dotted");
                     * picture.borderRadius(5);
                     */
                    borderStyle(value?:  string): any;
                    /**
                     * Gets or sets the border width of the picture.
                     * @param {number} value The border width of the picture.
                     * @returns {number | GC.Spread.Sheets.FloatingObjects.Picture} If no value is set, returns the border width of the picture; otherwise, returns the picture.
                     * @example
                     * //This example uses the borderWidth method.
                     * activeSheet.pictures.add("f2","Event.png",2,2,10,10);
                     * var picture = activeSheet.pictures.get("f2");
                     * picture.pictureStretch(GC.Spread.Sheets.ImageLayout.stretch);
                     * picture.backColor("Blue");
                     * picture.borderWidth(2);
                     * picture.borderColor("Red");
                     */
                    borderWidth(value?:  number): any;
                    /**
                     * Gets the original height of the picture.
                     * @returns {number} The original height of the picture.
                     * @example
                     * activeSheet.pictures.add("f2","Event.png",2,2,6,6);
                     * activeSheet.pictures.add("f1","tsoutline.png",3,0,6,6);
                     * var picture = activeSheet.pictures.get("f2");
                     * picture.pictureStretch(GC.Spread.Sheets.ImageLayout.center);
                     * //button
                     * $("#button1").click(function () {
                     *   alert(picture.getOriginalHeight());
                     * });
                     */
                    getOriginalHeight(): number;
                    /**
                     * Gets the original width of the picture.
                     * @returns {number} The original width of the picture.
                     * @example
                     * activeSheet.pictures.add("f2","Event.png",2,2,6,6);
                     * activeSheet.pictures.add("f1","tsoutline.png",3,0,6,6);
                     * var picture = activeSheet.pictures.get("f2");
                     * picture.pictureStretch(GC.Spread.Sheets.ImageLayout.center);
                     * //button
                     * $("#button1").click(function () {
                     *      alert(picture.getOriginalWidth());
                     * });
                     */
                    getOriginalWidth(): number;
                    /**
                     * Gets or sets the stretch of the picture.
                     * @param {GC.Spread.Sheets.ImageLayout} value The stretch of the picture.
                     * @returns {GC.Spread.Sheets.ImageLayout | GC.Spread.Sheets.FloatingObjects.Picture} If no value is set, returns the stretch of the picture; otherwise, returns the picture.
                     * @example
                     * //This example uses the pictureStretch method.
                     * activeSheet.pictures.add("f2","Event.png",2,2,10,10);
                     * var picture = activeSheet.pictures.get("f2");
                     * picture.pictureStretch(GC.Spread.Sheets.ImageLayout.stretch);
                     * picture.backColor("Blue");
                     * picture.borderWidth(2);
                     * picture.borderColor("Red");
                     */
                    pictureStretch(value?:  GC.Spread.Sheets.ImageLayout): any;
                    /**
                     * Gets or sets the src of the picture.
                     * @param {string} value The src of the picture.
                     * @returns {string | GC.Spread.Sheets.FloatingObjects.Picture} If no value is set, returns the src of the picture; otherwise, returns the picture.
                     */
                    src(value?:  string): any;
                }
            }

            module FormulaTextBox{

                export class FormulaTextBox{
                    /**
                     * Represents a formula text box.
                     * @class
                     * @param {Object} host The DOM element. It can be INPUT, TEXTAREA, or editable DIV.
                     * @param {Object} options The options. Default is {rangeSelectMode: false, absoluteReference: false}
                     * @example
                     * window.onload = function(){
                     *      var spread = new GC.Spread.Sheets.Workbook(document.getElementById("ss"), { sheetCount: 1 });
                     *      rangeSelector = new GC.Spread.Sheets.FormulaTextBox.FormulaTextBox(document.getElementById("ftb"), {rangeSelectMode: true});
                     *      rangeSelector.workbook(spread);
                     * }
                     * function buttonClick(){
                     *      alert(rangeSelector.text());
                     * }
                     */
                    constructor(host:  Object,  options:  Object);
                    /**
                     * Adds a custom function description.
                     * @param {IFunctionDescription} functionDescription The function description to add. This can be an array. See the Remarks for more information.
                     */
                    add(fnd:  Object): void;
                    /**
                     * Gets or sets whether the text box uses automatic complete.
                     * @param {boolean} value Whether to use automatic complete when editing.
                     * @returns {boolean} If no value is set, returns whether the text box uses auto complete; otherwise, there is no return value.
                     */
                    autoComplete(value?:  boolean): any;
                    /**
                     * Binds an event.
                     * @param {string} type The event type.
                     * @param {Object} data Optional. Specifies additional data to pass along to the function.
                     * @param {Function} fn Specifies the function to run when the event occurs.
                     */
                    bind(type:  string,  data:  Object,  fn:  Function): void;
                    /**
                     * Gets or sets the cursor position.
                     * @param {number} value The cursor position.
                     * @returns {number} If no value is set, returns the cursor position; otherwise, there is no return value.
                     */
                    caret(value?:  number): any;
                    /**
                     * Removes host from formula text box and removes all binding events.
                     */
                    destroy(): void;
                    /**
                     * refresh the formula text box with the active cell.
                     */
                    refresh(): void;
                    /**
                     * Removes a custom function description.
                     * @param {string} name The custom function description name.
                     */
                    remove(name:  string): void;
                    /**
                     * Gets or sets whether to display the function's help tip.
                     * @param {boolean} value Whether to display the function's help tip when editing.
                     * @returns {boolean} If no value is set, returns whether the text box displays the function's help tip when editing; otherwise, there is no return value.
                     */
                    showHelp(value?:  boolean): any;
                    /**
                     * Gets or sets the text.
                     * @param {string} value The text.
                     * @returns {string} If no value is set, returns the text; otherwise, there is no return value.
                     */
                    text(value?:  string): any;
                    /**
                     * Removes the binding of an event.
                     * @param {string} type The event type.
                     * @param {Function} fn Specifies the function for which to remove the binding.
                     */
                    unbind(type:  string,  fn:  Function): void;
                    /**
                     * Removes the binding of all events.
                     */
                    unbindAll(): void;
                    /**
                     * Gets or sets the Workbook component to work with the formula text box.
                     * @param {object} value The Workbook component.
                     * @returns {object} If no value is set, returns the workbook component; otherwise, there is no return value.
                     * @example
                     * window.onload = function(){
                     *      var spread = new GC.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                     *      var activeSheet = spread.getActiveSheet();
                     *      activeSheet.setArray(0, 0, [1, 2, 3, 4, 5]);
                     *      var fbx = new GC.Spread.Sheets.FormulaTextBox.FormulaTextBox(document.getElementById("formulaTextBox"));
                     *      fbx.workbook(spread);
                     * };
                     */
                    workbook(value?:  Object): any;
                }
            }

            module OutlineColumn{

                export interface IOutlineColumnOptions{
                    columnIndex?: number; //OutlineColumn index.
                    showImage?: boolean; //Whether to display images.
                    images?: string[]; //The images by level (url or base64Image).
                    showCheckBox?: boolean; //Whether to display the check box.
                    showIndicator?: boolean; //Whether to display the indicator.
                    expandIndicator?: string; //The expand indicator (url or base64Image).
                    collapseIndicator?: string; //The collapse indicator (url or base64Image).
                    maxLevel?: number; //When the current row level is greater than maxLevel, the IncreaseCellIndent action does not take effect.
                }


                export class OutlineColumn{
                    /**
                     * Represents an indented column.
                     * @class
                     * @param {GC.Spread.Sheets.Worksheet} sheet The outlineColumn's WorkSheet.
                     */
                    constructor(sheet:  GC.Spread.Sheets.Worksheet);
                    /**
                     * Gets the check status of the row or all rows.
                     * @param {number} row The index of the row.
                     * @returns {boolean|Array.<boolean>} If row is undefined, returns all row's check status; otherwise, returns the check status of the row.
                     */
                    getCheckStatus(row?:  number): any;
                    /**
                     * Gets the collapsed setting of the row or all rows.
                     * @param {number} row The index of the collapsed row.
                     * @returns {boolean|Array.<boolean>} If row is undefined, returns all row's collapsed status; otherwise, returns the collapsed setting of the row.
                     */
                    getCollapsed(row?:  number): any;
                    /**
                     * Gets or sets the outlineColumn options.
                     * @param {Object} outlineColumnOptions The outlineColumn options.
                     * @param {number} outlineColumnOptions.columnIndex - The index of the indented column.
                     * @param {boolean} [outlineColumnOptions.showImage] - Whether to display images.
                     * @param {Array.<string>} [outlineColumnOptions.images] - The images by level (url or base64Image).
                     * @param {boolean} [outlineColumnOptions.showCheckBox] - Whether to display a check box.
                     * @param {boolean} [outlineColumnOptions.showIndicator] - Whether to display the indicator.
                     * @param {string} [outlineColumnOptions.expandIndicator] - The expand indicator (url or base64Image).
                     * @param {string} [outlineColumnOptions.collapseIndicator] - The collapse indicator (url or base64Image).
                     * @param {number} [outlineColumnOptions.maxLevel] - When the current row level is greater than maxLevel, the IncreaseCellIndent action does not take effect.
                     * @returns {Object} outlineColumnOptions|outlineColumn
                     * If no outlineColumnOptions item is set, returns outlineColumnOptions; otherwise, returns the outlineColumn instance.
                     * @example
                     * var rowCount = 38;
                     * var colCount = 10;
                     * activeSheet.setColumnCount(colCount);
                     * activeSheet.setRowCount(rowCount);
                     * activeSheet.setColumnWidth(0, 310);
                     * activeSheet.setColumnWidth(1, 150);
                     * activeSheet.setColumnWidth(2, 150);
                     * activeSheet.frozenColumnCount(1);
                     * activeSheet.setValue(0, 0, "Name", GC.Spread.Sheets.SheetArea.colHeader);
                     * activeSheet.setValue(0, 1, "Chapter", GC.Spread.Sheets.SheetArea.colHeader);
                     * activeSheet.setValue(0, 2, "Page", GC.Spread.Sheets.SheetArea.colHeader);
                     * var commands = [
                     *     {name: 'Preface', chapter: '1', page: 1, indent: 0},
                     *     {name: 'Java SE5 and SE6', chapter: '1.1', page: 2, indent: 1},
                     *     {name: 'Java SE6', chapter: '1.1.1', page: 2, indent: 2},
                     *     {name: 'The 4th edition', chapter: '1.2', page: 2, indent: 1},
                     *     {name: 'Changes', chapter: '1.2.1', page: 3, indent: 2},
                     *     {name: 'Note on the cover design', chapter: '1.3', page: 4, indent: 1},
                     *     {name: 'Acknowledgements', chapter: '1.4', page: 4, indent: 1},
                     *     {name: 'Introduction', chapter: '2', page: 9, indent: 0},
                     *     {name: 'Prerequisites', chapter: '2.1', page: 9, indent: 1},
                     *     {name: 'Learning Java', chapter: '2.2', page: 10, indent: 1},
                     *     {name: 'Goals', chapter: '2.3', page: 10, indent: 1},
                     *     {name: 'Teaching from this book', chapter: '2.4', page: 11, indent: 1},
                     *     {name: 'JDK HTML documentation', chapter: '2.5', page: 11, indent: 1},
                     *     {name: 'Exercises', chapter: '2.6', page: 12, indent: 1},
                     *     {name: 'Foundations for Java', chapter: '2.7', page: 12, indent: 1},
                     *     {name: 'Source code', chapter: '2.8', page: 12, indent: 1},
                     *     {name: 'Coding standards', chapter: '2.8.1', page: 14, indent: 2},
                     *     {name: 'Errors', chapter: '2.9', page: 14, indent: 1},
                     *     {name: 'Introduction to Objects', chapter: '3', page: 15, indent: 0},
                     *     {name: 'The progress of abstraction', chapter: '3.1', page: 15, indent: 1},
                     *     {name: 'An object has an interface', chapter: '3.2', page: 17, indent: 1},
                     *     {name: 'An object provides services', chapter: '3.3', page: 18, indent: 1},
                     *     {name: 'The hidden implementation', chapter: '3.4', page: 19, indent: 1},
                     *     {name: 'Reusing the implementation', chapter: '3.5', page: 20, indent: 1},
                     *     {name: 'Inheritance', chapter: '3.6', page: 21, indent: 1},
                     *     {name: 'Is-a vs. is-like-a relationships', chapter: '3.6.1', page: 24, indent: 2},
                     *     {name: 'Interchangeable objects with polymorphism', chapter: '3.7', page: 25, indent: 1},
                     *     {name: 'The singly rooted hierarchy', chapter: '3.8', page: 28, indent: 1},
                     *     {name: 'Containers', chapter: '3.9', page: 28, indent: 1},
                     *     {name: 'Parameterized types (Generics)', chapter: '3.10', page: 29, indent: 1},
                     *     {name: 'Object creation & lifetime', chapter: '3.11', page: 30, indent: 1},
                     *     {name: 'Exception handling: dealing with errors', chapter: '3.12', page: 31, indent: 1},
                     *     {name: 'Concurrent programming', chapter: '3.13', page: 32, indent: 1},
                     *     {name: 'Java and the Internet', chapter: '3.14', page: 33, indent: 1},
                     *     {name: 'What is the Web?', chapter: '3.14.1', page: 33, indent: 2},
                     *     {name: 'Client-side programming', chapter: '3.14.2', page: 34, indent: 2},
                     *     {name: 'Server-side programming', chapter: '3.14.3', page: 38, indent: 2},
                     *     {name: 'Summary', chapter: '3.15', page: 38, indent: 1},
                     * ];
                     * for (var r = 0; r &lt; commands.length; r++) {
                     *     activeSheet.setValue(r, 0, commands[r]['name']);
                     *     activeSheet.setValue(r, 1, commands[r]['chapter']);
                     *     activeSheet.setValue(r, 2, commands[r]['page']);
                     *     activeSheet.getRange(r, 0, 1, 1).textIndent(commands[r].indent);
                     * }
                     * activeSheet.outlineColumn.options({
                     *      columnIndex: 0,
                     *      showImage: true,
                     *      showCheckBox: true,
                     *      images: ['star2.png', 'box4.png', 'rating4.png'],
                     *      maxLevel: 2
                     * });
                     * activeSheet.showRowOutline(true);
                     * spread.invalidateLayout();
                     * spread.repaint();
                     */
                    options(outlineColumnOptions?:  GC.Spread.Sheets.OutlineColumn.IOutlineColumnOptions): void;
                    /**
                     * Refreshes the indented column.
                     */
                    refresh(): void;
                    /**
                     * Sets the check status of the row.
                     * @param {number} row The index of the row.
                     * @param {boolean} checkStatus The check status of the row.
                     */
                    setCheckStatus(row:  number,  checkStatus:  boolean): void;
                    /**
                     * Sets whether the row is collapsed.
                     * @param {number} row The index of the row.
                     * @param {boolean} collapsed The collapsed setting for the row.
                     */
                    setCollapsed(row:  number,  collapsed:  boolean): void;
                }
            }

            module Outlines{
                /**
                 * Specifies the status of an outline (range group) summary row or column position.
                 * @enum {number}
                 * @example
                 * sheet.suspendPaint();
                 * sheet.rowOutlines.group(3,2);
                 * sheet.columnOutlines.group(4,1);
                 * sheet.rowOutlines.direction(GC.Spread.Sheets.Outlines.OutlineDirection.backward);
                 * sheet.columnOutlines.direction(GC.Spread.Sheets.Outlines.OutlineDirection.forward);
                 * sheet.resumePaint();
                 */
                export enum OutlineDirection{
                    /** The summary row is above or to the left of the group detail.
                     * @type {number}
                     */
                    backward= 0,
                    /** The summary row is below or to the right of the group detail.
                     * @type {number}
                     */
                    forward= 1
                }

                /**
                 * Specifies the status of an outline (range group).
                 * @enum {number}
                 * @example
                 * //The following example specifies to display a range group as collapsed.
                 * sheet.rowOutlines.group(0,5);
                 * var rgi = sheet.rowOutlines.find(1, 0);
                 * rgi.state(GC.Spread.Sheets.Outlines.OutlineState.collapsed);
                 * spread.invalidateLayout();
                 * spread.repaint();
                 */
                export enum OutlineState{
                    /** Indicates expanded status with the minus sign.
                     * @type {number}
                     */
                    expanded= 0,
                    /** Indicates collapsed status with the plus sign.
                     * @type {number}
                     */
                    collapsed= 1
                }


                export class Outline{
                    /**
                     * Represents an outline (range group) for the worksheet.
                     * @param {number} count The number of rows or columns.
                     * @class
                     */
                    constructor(count:  number);
                    /**
                     * Gets or sets the outline's (range group) direction.
                     * @param {GC.Spread.Sheets.Outlines.OutlineDirection} direction The outline's (range group) direction.
                     * @returns {GC.Spread.Sheets.Outlines.OutlineDirection | GC.Spread.Sheets.Outlines.Outline} If no value is set, returns the outline's (range group) direction; otherwise, returns the outline.
                     * @example
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(3,2);
                     * activeSheet.columnOutlines.group(4,1);
                     * activeSheet.rowOutlines.direction(GC.Spread.Sheets.Outlines.OutlineDirection.forward);
                     * activeSheet.resumePaint();
                     */
                    direction(direction?:  GC.Spread.Sheets.Outlines.OutlineDirection): any;
                    /**
                     * Expands all outlines (range groups), using the specified level.
                     * @param {number} level The level of the outline to expand or collapse.
                     * @param {boolean} expand Whether to expand the groups.
                     * @example
                     * //This example uses the expand method.
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(0,5);
                     * activeSheet.rowOutlines.expand(0,false);
                     * activeSheet.resumePaint();
                     */
                    expand(level:  number,  expand:  boolean): void;
                    /**
                     * Expands or collapses the specified outline (range group) of rows or columns.
                     * @param {GC.Spread.Sheets.Outlines.OutlineInfo} groupInfo The group information of the range group.
                     * @param {boolean} expand Whether to expand the groups.
                     */
                    expandGroup(groupInfo:  GC.Spread.Sheets.Outlines.OutlineInfo,  expand:  boolean): void;
                    /**
                     * Gets the outline (range group) with the specified group level and row or column index.
                     * @param {number} index The index of the row or column.
                     * @param {number} level The level of the outline (range group).
                     * @returns {GC.Spread.Sheets.Outlines.OutlineInfo} The specified range group.
                     * @example
                     * //This example uses the find method.
                     * activeSheet.rowOutlines.group(0,5);
                     * var rgi = activeSheet.rowOutlines.find(1, 0);
                     * rgi.state(GC.Spread.Sheets.Outlines.OutlineState.collapsed);
                     * spread.invalidateLayout();
                     * spread.repaint();
                     */
                    find(index:  number,  level:  number): GC.Spread.Sheets.Outlines.OutlineInfo;
                    /**
                     * Gets the collapsed internal.
                     * @param {number} index The index.
                     * @returns {boolean} <c>true</c> if collapsed; otherwise, <c>false</c>.
                     * @example
                     * //This example uses the getCollapsed method.
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(0,5);
                     * activeSheet.rowOutlines.expand(0,true);
                     * activeSheet.resumePaint();
                     * alert(activeSheet.rowOutlines.isCollapsed(0));
                     */
                    getCollapsed(index:  number): boolean;
                    /**
                     * Gets the level of a specified row or column.
                     * The level's index is zero-based.
                     * @param {number} index The index of the row or column.
                     * @returns {number} The level for the row or column.
                     * @example
                     * //This example uses the getLevel method.
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(0,5);
                     * activeSheet.rowOutlines.expand(0,true);
                     * activeSheet.resumePaint();
                     * alert(activeSheet.rowOutlines.getLevel(0));
                     */
                    getLevel(index:  number): number;
                    /**
                     * Gets the number of the deepest level.
                     * @remarks The level index is zero-based.
                     * @returns {number} The number of the deepest level.
                     * @example
                     * //This example uses the getMaxLevel method.
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(0,5);
                     * activeSheet.rowOutlines.group(1,4);
                     * activeSheet.rowOutlines.expand(0,true);
                     * activeSheet.columnOutlines.group(0,1);
                     * activeSheet.resumePaint();
                     * alert(activeSheet.rowOutlines.getMaxLevel());
                     */
                    getMaxLevel(): number;
                    /**
                     * Gets the state for the specified group.
                     * @param {GC.Spread.Sheets.Outlines.OutlineInfo} groupInfo The group information.
                     * @returns {GC.Spread.Sheets.Outlines.OutlineState} The group state.
                     * @example
                     * //This example uses the getState method.
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(0,5);
                     * var rgi = activeSheet.rowOutlines.find(1, 0);
                     * rgi.state(GC.Spread.Sheets.Outlines.OutlineInfo.collapsed);
                     * alert(activeSheet.rowOutlines.getState(rgi));
                     * activeSheet.resumePaint();
                     */
                    getState(groupInfo:  GC.Spread.Sheets.Outlines.OutlineInfo): GC.Spread.Sheets.Outlines.OutlineState;
                    /**
                     * Groups a range of rows or columns into an outline (range group) from a specified start index.
                     * @param {number} index The group starting index.
                     * @param {number} count The number of rows or columns to group.
                     * @example
                     * //This example uses the group method.
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(0,5);
                     * activeSheet.rowOutlines.expand(0,false);
                     * activeSheet.resumePaint();
                     */
                    group(index:  number,  count:  number): void;
                    /**
                     * Determines whether the range group at the specified index is collapsed.
                     * @param {number} index The index of the row or column in the range group.
                     * @returns {boolean} <c>true</c> if the specified row or column is collapsed; otherwise, <c>false</c>.
                     * @example
                     * //This example uses the isCollapsed method.
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(0,5);
                     * activeSheet.rowOutlines.expand(0,true);
                     * activeSheet.resumePaint();
                     * alert(activeSheet.rowOutlines.isCollapsed(0));
                     */
                    isCollapsed(index:  number): boolean;
                    /**
                     * Determines whether the specified index is the end of the group.
                     * @param {number} index The index.
                     * @param {number} processLevel The process level.
                     * @returns {boolean} <c>true</c> if the specfied index is the end of the group; otherwise, <c>false</c>.
                     */
                    isGroupEnd(index:  number,  processLevel:  number): boolean;
                    /**
                     * Refreshes this range group.
                     */
                    refresh(): any;
                    /**
                     * Resumes the adding.
                     */
                    resumeAdding(): any;
                    /**
                     * Sets the collapsed level.
                     * @param {number} index The index.
                     * @param {boolean} collapsed Set to <c>true</c> to collapse the level.
                     * @example
                     * //This example uses the setCollapsed method.
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(0,5);
                     * activeSheet.rowOutlines.setCollapsed(0,false);
                     * activeSheet.resumePaint();
                     */
                    setCollapsed(index:  number,  collapsed:  boolean): void;
                    /**
                     * Suspends the adding.
                     */
                    suspendAdding(): any;
                    /**
                     * Removes all outlines (range groups).
                     * @example
                     * //This example uses the ungroup method.
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(0,5);
                     * activeSheet.rowOutlines.ungroup();
                     * activeSheet.resumePaint();
                     */
                    ungroup(): void;
                    /**
                     * Removes a range of rows or columns from the outline (range group) at the specified start index.
                     * @param {number} index The group starting index.
                     * @param {number} count The number of rows or columns to remove.
                     * @example
                     * //This example uses the ungroupRange method.
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(0,5);
                     * activeSheet.rowOutlines.ungroupRange(0,1);
                     * activeSheet.resumePaint();
                     */
                    ungroupRange(index:  number,  count:  number): void;
                }

                export class OutlineInfo{
                    /**
                     * Represents the outline (range group) information.
                     * @param {GC.Spread.Sheets.Outlines.Outline} model The owner of the outline.
                     * @param {number} start The start index of the outline.
                     * @param {number} end The end index of the outline.
                     * @param {number} level The level of the outline.
                     * @class
                     */
                    constructor(model:  GC.Spread.Sheets.Outlines.Outline,  start:  number,  end:  number,  level:  number);
                    /** The children of the group.
                     * @type {Array}
                     */
                    children: any[];
                    /** The end index of the group.
                     * @type {number}
                     */
                    end: number;
                    /** The level of the group.
                     * @type {number}
                     */
                    level: number;
                    /** The owner of the group.
                     * @type {GC.Spread.Sheets.Outlines.Outline}
                     */
                    model: GC.Spread.Sheets.Outlines.Outline;
                    /** The parent of the group.
                     * @type {GC.Spread.Sheets.Outlines.OutlineInfo}
                     */
                    parent: GC.Spread.Sheets.Outlines.OutlineInfo;
                    /** The start index of the group.
                     * @type {number}
                     */
                    start: number;
                    /**
                     * Adds the child.
                     * @param {object} child The child.
                     */
                    addChild(child:  Object): void;
                    /**
                     * Compares this instance to a specified OutlineInfo object and returns an indication of their relative values.
                     * @param {number} index The index of the group item.
                     * @returns {boolean} <c>true</c> if the range group contains the specified index; otherwise, <c>false</c>.
                     */
                    contains(index:  number): boolean;
                    /**
                     * Gets or sets the state of this outline (range group).
                     * @param {GC.Spread.Sheets.Outlines.OutlineState} value The state of this outline (range group).
                     * @returns {GC.Spread.Sheets.Outlines.OutlineState} The state of this outline (range group).
                     */
                    state(value?:  GC.Spread.Sheets.Outlines.OutlineState): GC.Spread.Sheets.Outlines.OutlineState;
                }
            }

            module PDF{
                module PDFFontsManager{
                    /**
                     *Provide a fallback font for the specific font.
                     *@param {string} font the css font string.
                     *@return {string | ArrayBuffer} The font file in base64 string or ArrayBuffer.
                     */
                    function fallbackFont(font:  string): string | ArrayBuffer;
                    /**
                     *Register a Font for export PDF.
                     *@param {string} name The font name.
                     *@param {Object} [font] The font object.
                     *@param {string | ArrayBuffer} [font.normal] The normal font file in base64 string or ArrayBuffer.
                     *@param {string | ArrayBuffer} [font.bold] The bold font file in base64 string or ArrayBuffer.
                     *@param {string | ArrayBuffer} [font.italic] The italic font file in base64 string or ArrayBuffer.
                     *@param {string | ArrayBuffer} [font.boldItalic] The boldItalic font file in base64 string or ArrayBuffer.
                     */
                    function registerFont(name:  string,  font:  Object): void;
                }

            }

            module Print{

                export interface PrintMargins{
                    top: number;
                    bottom: number;
                    left: number;
                    right: number;
                    header: number;
                    footer: number;
                }


                export interface PrintSize{
                    height: number;
                    width: number;
                }

                /**
                 * Specifies the paper kind for the printed page.
                 * @enum {number}
                 * @example
                 * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                 * printInfo.headerLeft("Header Left");
                 * printInfo.paperSize(new GC.Spread.Sheets.Print.PaperSize(GC.Spread.Sheets.Print.PaperKind.a4));
                 * spread.print(0);
                 */
                export enum PaperKind{
                    /**
                     * Specifies the paper size is 420 mm * 594 mm.
                     */
                    a2= 0x42,
                    /**
                     * Specifies the paper size is 297 mm * 420 mm.
                     */
                    a3= 8,
                    /**
                     * Specifies the paper size is 322 mm * 445 mm.
                     */
                    a3Extra= 0x3f,
                    /**
                     * Specifies the paper size is 322 mm * 445 mm.
                     */
                    a3ExtraTransverse= 0x44,
                    /**
                     * Specifies the paper size is 420 mm * 297 mm.
                     */
                    a3Rotated= 0x4c,
                    /**
                     * Specifies the paper size is 297 mm * 420 mm.
                     */
                    a3Transverse= 0x43,
                    /**
                     * Specifies the paper size is 210 mm * 297 mm.
                     */
                    a4= 9,
                    /**
                     * Specifies the paper size is 236 mm * 322 mm.
                     */
                    a4Extra= 0x35,
                    /**
                     * Specifies the paper size is 210 mm * 330 mm.
                     */
                    a4Plus= 60,
                    /**
                     * Specifies the paper size is 297 mm * 210 mm.
                     */
                    a4Rotated= 0x4d,
                    /**
                     * Specifies the paper size is 210 mm * 297 mm.
                     */
                    a4Small= 10,
                    /**
                     * Specifies the paper size is 210 mm * 297 mm.
                     */
                    a4Transverse= 0x37,
                    /**
                     * Specifies the paper size is 148 mm * 210 mm.
                     */
                    a5= 11,
                    /**
                     * Specifies the paper size is 174 mm * 235 mm.
                     */
                    a5Extra= 0x40,
                    /**
                     * Specifies the paper size is 210 mm * 148 mm.
                     */
                    a5Rotated= 0x4e,
                    /**
                     * Specifies the paper size is 148 mm * 210 mm.
                     */
                    a5Transverse= 0x3d,
                    /**
                     * Specifies the paper size is 105 mm * 148 mm.
                     */
                    a6= 70,
                    /**
                     * Specifies the paper size is 148 mm * 105 mm.
                     */
                    a6Rotated= 0x53,
                    /**
                     * Specifies the paper size is 227 mm * 356 mm.
                     */
                    aPlus= 0x39,
                    /**
                     * Specifies the paper size is 250 mm * 353 mm.
                     */
                    b4= 12,
                    /**
                     * Specifies the paper size is 250 mm * 353 mm.
                     */
                    b4Envelope= 0x21,
                    /**
                     * Specifies the paper size is 364 mm * 257 mm.
                     */
                    b4JisRotated= 0x4f,
                    /**
                     * Specifies the paper size is 176 mm * 250 mm.
                     */
                    b5= 13,
                    /**
                     * Specifies the paper size is 176 mm * 250 mm.
                     */
                    b5Envelope= 0x22,
                    /**
                     * Specifies the paper size is 201 mm * 276 mm.
                     */
                    b5Extra= 0x41,
                    /**
                     * Specifies the paper size is 257 mm * 182 mm.
                     */
                    b5JisRotated= 80,
                    /**
                     * Specifies the paper size is 182 mm * 257 mm.
                     */
                    b5Transverse= 0x3e,
                    /**
                     * Specifies the paper size is 176 mm * 125 mm.
                     */
                    b6Envelope= 0x23,
                    /**
                     * Specifies the paper size is 128 mm * 182 mm.
                     */
                    b6Jis= 0x58,
                    /**
                     * Specifies the paper size is 182 mm * 128 mm.
                     */
                    b6JisRotated= 0x59,
                    /**
                     * Specifies the paper size is 305 mm * 487 mm.
                     */
                    bPlus= 0x3a,
                    /**
                     * Specifies the paper size is 324 mm * 458 mm.
                     */
                    c3Envelope= 0x1d,
                    /**
                     * Specifies the paper size is 229 mm * 324 mm.
                     */
                    c4Envelope= 30,
                    /**
                     * Specifies the paper size is 162 mm * 229 mm.
                     */
                    c5Envelope= 0x1c,
                    /**
                     * Specifies the paper size is 114 mm * 229 mm.
                     */
                    c65Envelope= 0x20,
                    /**
                     * Specifies the paper size is 114 mm * 162 mm.
                     */
                    c6Envelope= 0x1f,
                    /**
                     * Specifies the paper size is 17 in. * 22 in.
                     */
                    cSheet= 0x18,
                    /**
                     * Specifies the paper size is defined by the user.
                     */
                    custom= 0,
                    /**
                     * Specifies the paper size is 110 mm * 220 mm.
                     */
                    dlEnvelope= 0x1b,
                    /**
                     * Specifies the paper size is 22 in. * 34 in.
                     */
                    dSheet= 0x19,
                    /**
                     * Specifies the paper size is 34 in. * 44 in.
                     */
                    eSheet= 0x1a,
                    /**
                     * Specifies the paper size is 7.25 in. * 10.5 in.
                     */
                    executive= 7,
                    /**
                     * Specifies the paper size is 8.5 in. * 13 in.
                     */
                    folio= 14,
                    /**
                     * Specifies the paper size is 8.5 in. * 13 in.
                     */
                    germanLegalFanfold= 0x29,
                    /**
                     * Specifies the paper size is 8.5 in. * 12 in.
                     */
                    germanStandardFanfold= 40,
                    /**
                     * Specifies the paper size is 220 mm * 220 mm.
                     */
                    inviteEnvelope= 0x2f,
                    /**
                     * Specifies the paper size is 250 mm * 353 mm.
                     */
                    isoB4= 0x2a,
                    /**
                     * Specifies the paper size is 110 mm * 230 mm.
                     */
                    italyEnvelope= 0x24,
                    /**
                     * Specifies the paper size is 200 mm * 148 mm.
                     */
                    japaneseDoublePostcard= 0x45,
                    /**
                     * Specifies the paper size is 148 mm * 200 mm.
                     */
                    japaneseDoublePostcardRotated= 0x52,
                    /**
                     * Specifies the paper size is Japanese Chou #3 envelope, 120 mm * 235 mm.
                     */
                    japaneseEnvelopeChouNumber3= 0x49,
                    /**
                     * Specifies the paper size is Japanese rotated Chou #3 envelope, 235 mm * 120 mm.
                     */
                    japaneseEnvelopeChouNumber3Rotated= 0x56,
                    /**
                     * Specifies the paper size is Japanese Chou #4 envelope, 90 mm * 205 mm.
                     */
                    japaneseEnvelopeChouNumber4= 0x4a,
                    /**
                     * Specifies the paper size is Japanese rotated Chou #4 envelope, 205 mm * 90 mm.
                     */
                    japaneseEnvelopeChouNumber4Rotated= 0x57,
                    /**
                     * Specifies the paper size is Japanese Kaku #2 envelope, 240 mm * 332 mm.
                     */
                    japaneseEnvelopeKakuNumber2= 0x47,
                    /**
                     * Specifies the paper size is Japanese rotated Kaku #2 envelope, 332 mm * 240 mm.
                     */
                    japaneseEnvelopeKakuNumber2Rotated= 0x54,
                    /**
                     * Specifies the paper size is Japanese Kaku #3 envelope, 216 mm * 277 mm.
                     */
                    japaneseEnvelopeKakuNumber3= 0x48,
                    /**
                     * Specifies the paper size is Japanese rotated Kaku #3 envelope, 277 mm * 216 mm.
                     */
                    japaneseEnvelopeKakuNumber3Rotated= 0x55,
                    /**
                     * Specifies the paper size is Japanese You #4 envelope, 235 mm * 105 mm.
                     */
                    japaneseEnvelopeYouNumber4= 0x5b,
                    /**
                     * Specifies the paper size is Japanese You #4 rotated envelope, 105 mm * 235 mm.
                     */
                    japaneseEnvelopeYouNumber4Rotated= 0x5c,
                    /**
                     * Specifies the paper size is 100 mm * 148 mm.
                     */
                    japanesePostcard= 0x2b,
                    /**
                     * Specifies the paper size is 148 mm * 100 mm.
                     */
                    japanesePostcardRotated= 0x51,
                    /**
                     * Specifies the paper size is 17 in. * 11 in.
                     */
                    ledger= 4,
                    /**
                     * Specifies the paper size is 8.5 in. * 14 in.
                     */
                    legal= 5,
                    /**
                     * Specifies the paper size is legal extra paper (9.275 in. * 15 in.).
                     * This value is specific to the PostScript driver and is used only by Linotronic printers in order to conserve paper.
                     */
                    legalExtra= 0x33,
                    /**
                     * Specifies the paper size is 8.5 in. * 11 in.
                     */
                    letter= 1,
                    /**
                     * Specifies the paper size is letter extra paper (9.275 in. * 12 in.).
                     * This value is specific to the PostScript driver and is used only by Linotronic printers in order to conserve paper.
                     */
                    letterExtra= 50,
                    /**
                     * Specifies the paper size 9.275 in. * 12 in.
                     */
                    letterExtraTransverse= 0x38,
                    /**
                     * Specifies the paper size is 8.5 in. * 12.69 in.
                     */
                    letterPlus= 0x3b,
                    /**
                     * Specifies the paper size is 11 in. * 8.5 in.
                     */
                    letterRotated= 0x4b,
                    /**
                     * Specifies the paper size is 8.5 in. * 11 in.
                     */
                    letterSmall= 2,
                    /**
                     * Specifies the paper size is 8.275 in. * 11 in.
                     */
                    letterTransverse= 0x36,
                    /**
                     * Specifies the paper size is 3.875 in. * 7.5 in.
                     */
                    monarchEnvelope= 0x25,
                    /**
                     * Specifies the paper size is 8.5 in. * 11 in.
                     */
                    note= 0x12,
                    /**
                     * Specifies the paper size is 4.125 in. * 9.5 in.
                     */
                    number10Envelope= 20,
                    /**
                     * Specifies the paper size is 4.5 in. * 10.375 in.
                     */
                    number11Envelope= 0x15,
                    /**
                     * Specifies the paper size is 4.75 in. * 11 in.
                     */
                    number12Envelope= 0x16,
                    /**
                     * Specifies the paper size is 5 in. * 11.5 in.
                     */
                    number14Envelope= 0x17,
                    /**
                     * Specifies the paper size is 3.875 in. * 8.875 in.
                     */
                    number9Envelope= 0x13,
                    /**
                     * Specifies the paper size is 3.625 in. * 6.5 in.
                     */
                    personalEnvelope= 0x26,
                    /**
                     * Specifies the paper size is 146 mm * 215 mm.
                     */
                    prc16K= 0x5d,
                    /**
                     * Specifies the paper size is 146 mm * 215 mm.
                     */
                    prc16KRotated= 0x6a,
                    /**
                     * Specifies the paper size is 97 mm * 151 mm.
                     */
                    prc32K= 0x5e,
                    /**
                     * Specifies the paper size is 97 mm * 151 mm.
                     */
                    prc32KBig= 0x5f,
                    /**
                     * Specifies the paper size is 97 mm * 151 mm.
                     */
                    prc32KBigRotated= 0x6c,
                    /**
                     * Specifies the paper size is 97 mm * 151 mm.
                     */
                    prc32KRotated= 0x6b,
                    /**
                     * Specifies the paper size is 102 mm * 165 mm.
                     */
                    prcEnvelopeNumber1= 0x60,
                    /**
                     * Specifies the paper size is 324 mm * 458 mm.
                     */
                    prcEnvelopeNumber10= 0x69,
                    /**
                     * Specifies the paper size is 458 mm * 324 mm.
                     */
                    prcEnvelopeNumber10Rotated= 0x76,
                    /**
                     * Specifies the paper size is 165 mm * 102 mm.
                     */
                    prcEnvelopeNumber1Rotated= 0x6d,
                    /**
                     * Specifies the paper size is 102 mm * 176 mm.
                     */
                    prcEnvelopeNumber2= 0x61,
                    /**
                     * Specifies the paper size is 176 mm * 102 mm.
                     */
                    prcEnvelopeNumber2Rotated= 110,
                    /**
                     * Specifies the paper size is 125 mm * 176 mm.
                     */
                    prcEnvelopeNumber3= 0x62,
                    /**
                     * Specifies the paper size is 176 mm * 125 mm.
                     */
                    prcEnvelopeNumber3Rotated= 0x6f,
                    /**
                     * Specifies the paper size is 110 mm * 208 mm.
                     */
                    prcEnvelopeNumber4= 0x63,
                    /**
                     * Specifies the paper size is 208 mm * 110 mm.
                     */
                    prcEnvelopeNumber4Rotated= 0x70,
                    /**
                     * Specifies the paper size is 110 mm * 220 mm.
                     */
                    prcEnvelopeNumber5= 100,
                    /**
                     * Specifies the paper size is 220 mm * 110 mm.
                     */
                    prcEnvelopeNumber5Rotated= 0x71,
                    /**
                     * Specifies the paper size is 120 mm * 230 mm.
                     */
                    prcEnvelopeNumber6= 0x65,
                    /**
                     * Specifies the paper size is 230 mm * 120 mm.
                     */
                    prcEnvelopeNumber6Rotated= 0x72,
                    /**
                     * Specifies the paper size is 160 mm * 230 mm.
                     */
                    prcEnvelopeNumber7= 0x66,
                    /**
                     * Specifies the paper size is 230 mm * 160 mm.
                     */
                    prcEnvelopeNumber7Rotated= 0x73,
                    /**
                     * Specifies the paper size is 120 mm * 309 mm.
                     */
                    prcEnvelopeNumber8= 0x67,
                    /**
                     * Specifies the paper size is 309 mm * 120 mm.
                     */
                    prcEnvelopeNumber8Rotated= 0x74,
                    /**
                     * Specifies the paper size is 229 mm * 324 mm.
                     */
                    prcEnvelopeNumber9= 0x68,
                    /**
                     * Specifies the paper size is 324 mm * 229 mm.
                     */
                    prcEnvelopeNumber9Rotated= 0x75,
                    /**
                     * Specifies the paper size is 215 mm * 275 mm.
                     */
                    quarto= 15,
                    /**
                     * Specifies the paper size is 10 in. * 11 in.
                     */
                    standard10x11= 0x2d,
                    /**
                     * Specifies the paper size is 10 in. * 14 in.
                     */
                    standard10x14= 0x10,
                    /**
                     * Specifies the paper size is 11 in. * 17 in.
                     */
                    standard11x17= 0x11,
                    /**
                     * Specifies the paper size is 12 in. * 11 in.
                     */
                    standard12x11= 90,
                    /**
                     * Specifies the paper size is 15 in. * 11 in.
                     */
                    standard15x11= 0x2e,
                    /**
                     * Specifies the paper size is 9 in. * 11 in.
                     */
                    standard9x11= 0x2c,
                    /**
                     * Specifies the paper size is 5.5 in. * 8.5 in.
                     */
                    statement= 6,
                    /**
                     * Specifies the paper size is 11 in. * 17 in.
                     */
                    tabloid= 3,
                    /**
                     * Specifies the paper size is 11.69 in. * 18 in.
                     */
                    tabloidExtra= 0x34,
                    /**
                     * Specifies the paper size is 14.875 in. * 11 in.
                     */
                    usStandardFanfold= 0x27
                }

                /**
                 * Specifics the type of centering for the printed page.
                 * @enum {number}
                 * @example
                 * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                 * printInfo.columnStart(0);
                 * printInfo.columnEnd(2);
                 * printInfo.centering(GC.Spread.Sheets.Print.PrintCentering.horizontal);
                 * activeSheet.printInfo(printInfo);
                 * spread.print(0);
                 */
                export enum PrintCentering{
                    /**
                     * Does not center the printed page at all.
                     */
                    none= 0,
                    /**
                     * Centers the printed layout horizontally on the page.
                     */
                    horizontal= 1,
                    /**
                     * Centers the printed layout vertically on the page.
                     */
                    vertical= 2,
                    /**
                     * Centers the printed layout both horizontally and vertically on the page.
                     */
                    both= 3
                }

                /**
                 * Specifies the order in which pages are printed.
                 * @enum {number}
                 * @example
                 * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                 * printInfo.pageOrder(GC.Spread.Sheets.Print.PrintPageOrder.auto);
                 * activeSheet.printInfo(printInfo);
                 * spread.print(0);
                 */
                export enum PrintPageOrder{
                    /**
                     * Automatically determines the best order for printing pages.
                     */
                    auto= 0,
                    /**
                     * Prints pages down then across.
                     */
                    downThenOver= 1,
                    /**
                     * Prints pages across then down.
                     */
                    overThenDown= 2
                }

                /**
                 * Specifies the page orientation used for printing.
                 * @enum {number}
                 * @example
                 * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                 * printInfo.bestFitColumns(true);
                 * printInfo.orientation(GC.Spread.Sheets.Print.PrintPageOrientation.landscape);
                 * printInfo.footerCenter("GrapeCity");
                 * activeSheet.printInfo(printInfo);
                 * spread.print(0);
                 */
                export enum PrintPageOrientation{
                    /**
                     * Prints portrait orientation.
                     */
                    portrait= 1,
                    /**
                     * Prints landscape orientation.
                     */
                    landscape= 2
                }

                /**
                 * Specifies whether the area is visible.
                 * @enum {number}
                 * @example
                 * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                 * printInfo.showColumnHeader(GC.Spread.Sheets.Print.PrintVisibilityType.hide);
                 * spread.print(0);
                 */
                export enum PrintVisibilityType{
                    /**
                     * Inherits the setting from the Worksheet class.
                     */
                    inherit= 0,
                    /**
                     * Hides the area.
                     */
                    hide= 1,
                    /**
                     * Shows in each page.
                     */
                    show= 2,
                    /**
                     * Shows once.
                     */
                    showOnce= 3
                }


                export class PaperSize{
                    /**
                     * Specifies the paper size.
                     * The constructor has 3 modes.
                     * If there are 2 parameters, the parameters are width and height with a type of number;
                     * If there is 1 parameter, the parameter is kind which is a GC.Spread.Sheets.Print.PaperKind type;
                     * If there is no parameter, the result is the same as the second mode and the kind option is GC.Spread.Sheets.Print.PaperKind.letter.
                     * @class
                     * @param {number|GC.Spread.Sheets.Print.PaperKind} widthOrKind The width of the paper, in hundredths of an inch; or the kind of the paper and the type is GC.Spread.Sheets.Print.PaperKind.
                     * @param {number} height The height of the paper, in hundredths of an inch.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeft("Header Left");
                     * printInfo.paperSize(new GC.Spread.Sheets.Print.PaperSize(GC.Spread.Sheets.Print.PaperKind.a4));
                     * spread.print(0);
                     */
                    constructor(widthOrKind?:  any,  height?:  number);
                    /**
                     * Gets the paper size, in hundredths of an inch.
                     * @param {GC.Spread.Sheets.Print.PaperKind} kind The kind of the paper.
                     * @returns {Object} The size which contains width and height of the paper.<br/>
                     * size.width {number} The width of the size, in hundredths of an inch.<br/>
                     * size.height {number} The height of the size, in hundredths of an inch.
                     */
                    getPageSize(kind:  GC.Spread.Sheets.Print.PaperKind): GC.Spread.Sheets.Print.PrintSize;
                    /**
                     * Gets or sets the height of the paper, in hundredths of an inch.
                     * @param {number} value The height of the paper.
                     * @returns {number | GC.Spread.Sheets.Print.PaperSize} If no value is set, returns the height of the paper; otherwise, returns the paper size.
                     */
                    height(value?:  number): any;
                    /**
                     * Gets or sets the kind of the paper.
                     * @param {GC.Spread.Sheets.Print.PaperKind} value The kind of the paper.
                     * @returns {GC.Spread.Sheets.Print.PaperKind | GC.Spread.Sheets.Print.PaperSize} If no value is set, returns the kind of the paper; otherwise, returns the paper size.
                     */
                    kind(value?:  GC.Spread.Sheets.Print.PaperKind): any;
                    /**
                     * Gets or sets the width of the paper, in hundredths of an inch.
                     * @param {number} value The width of the paper.
                     * @returns {number | GC.Spread.Sheets.Print.PaperSize} If no value is set, returns the width of the paper; otherwise, returns the paper size.
                     */
                    width(value?:  number): any;
                }

                export class PrintInfo{
                    /**
                     * Represents the information to use when printing a Worksheet.
                     * @class
                     */
                    constructor();
                    /**
                     * Gets or sets whether column widths are adjusted to fit the longest text width for printing.
                     * @param {boolean} value Whether column widths are adjusted to fit the longest text width for printing.
                     * @returns {boolean | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns whether column widths are adjusted to fit the longest text width for printing; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.bestFitColumns(true);
                     * printInfo.orientation(GC.Spread.Sheets.Print.PrintPageOrientation.landscape);
                     * printInfo.footerCenter("GrapeCity");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    bestFitColumns(value?:  boolean): any;
                    /**
                     * Gets or sets whether row heights are adjusted to fit the tallest text height for printing.
                     * @param {boolean} value Whether row heights are adjusted to fit the tallest text height for printing.
                     * @returns {boolean | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns whether row heights are adjusted to fit the tallest text height for printing; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.bestFitRows(true);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    bestFitRows(value?:  boolean): any;
                    /**
                     * Gets or sets whether to print in black and white.
                     * @param {boolean} value Whether to print in black and white.
                     * @returns {boolean | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns whether to print in black and white; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.blackAndWhite(true);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    blackAndWhite(value?:  boolean): any;
                    /**
                     * Gets or sets how the printed page is centered.
                     * @param {GC.Spread.Sheets.Print.PrintCentering} value How the printed page is centered.
                     * @returns {GC.Spread.Sheets.Print.PrintCentering | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns how the printed page is centered; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.columnStart(0);
                     * printInfo.columnEnd(2);
                     * printInfo.centering(GC.Spread.Sheets.Print.PrintCentering.horizontal);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    centering(value?:  GC.Spread.Sheets.Print.PrintCentering): any;
                    /**
                     * Gets or sets the last column to print when printing a cell range.
                     * @param {number} value The last column to print when printing a cell range.
                     * @returns {number | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the last column to print when printing a cell range; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.columnStart(0);
                     * printInfo.columnEnd(2);
                     * printInfo.centering(GC.Spread.Sheets.Print.PrintCentering.horizontal);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    columnEnd(value?:  number): any;
                    /**
                     * Gets or sets the first column to print when printing a cell range.
                     * @param {number} value The first column to print when printing a cell range.
                     * @returns {number | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the first column to print when printing a cell range; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.columnStart(0);
                     * printInfo.columnEnd(2);
                     * printInfo.centering(GC.Spread.Sheets.Print.PrintCentering.horizontal);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    columnStart(value?:  number): any;
                    /**
                     * Gets or sets the page number to print on the first page.
                     * @param {number} value The page number to print on the first page.
                     * @returns {number | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the page number to print on the first page; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.firstPageNumber(1);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    firstPageNumber(value?:  number): any;
                    /**
                     * Gets or sets the number of vertical pages to check when optimizing printing.
                     * @param {number} value The number of vertical pages to check when optimizing printing.
                     * @returns {number | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the number of vertical pages to check; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.fitPagesTall(1);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    fitPagesTall(value?:  number): any;
                    /**
                     * Gets or sets the number of horizontal pages to check when optimizing the printing.
                     * @param {number} value The number of horizontal pages to check when optimizing the printing.
                     * @returns {number | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the number of horizontal pages to check; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.fitPagesWide(1);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    fitPagesWide(value?:  number): any;
                    /**
                     * Gets or sets the text and format of the center footer on printed pages.
                     * @param {string} value The text and format of the center footer on printed pages.
                     * @returns {string | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the text and format of the center footer on printed pages; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.bestFitColumns(true);
                     * printInfo.orientation(GC.Spread.Sheets.Print.PrintPageOrientation.landscape);
                     * printInfo.footerCenter("GrapeCity");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    footerCenter(value?:  string): any;
                    /**
                     * Gets or sets the image for the center section of the footer.
                     * @param {string} value The image for the center section of the footer.
                     * @returns {string | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the image for the center section of the footer; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.footerCenter("&amp;G");
                     * printInfo.footerCenterImage("tsoutline.png");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    footerCenterImage(value?:  string): any;
                    /**
                     * Gets or sets the text and format of the left footer on printed pages.
                     * @param {string} value The text and format of the left footer on printed pages.
                     * @returns {string | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the text and format of the left footer on printed pages; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.footerLeft("&amp;BFooter");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    footerLeft(value?:  string): any;
                    /**
                     * Gets or sets the image for the left section of the footer.
                     * @param {string} value The image for the left section of the footer.
                     * @returns {string | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the image for the left section of the footer; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.footerLeft("&amp;G");
                     * printInfo.footerLeftImage("logo.jpg");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    footerLeftImage(value?:  string): any;
                    /**
                     * Gets or sets the text and format of the right footer on printed pages.
                     * @param {string} value The text and format of the right footer on printed pages.
                     * @returns {string | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the text and format of the right footer on printed pages; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.footerRight("&amp;G");
                     * printInfo.footerRightImage("logo.jpg");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    footerRight(value?:  string): any;
                    /**
                     * Gets or sets the image for the right section of the footer.
                     * @param {string} value The image for the right section of the footer.
                     * @returns {string | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the image for the right section of the footer; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.footerRight("&amp;G");
                     * printInfo.footerRightImage("logo.jpg");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    footerRightImage(value?:  string): any;
                    /**
                     * Gets or sets the text and format of the center header on printed pages.
                     * @param {string} value The text and format of the center header on printed pages.
                     * @returns {string | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the text and format of the center header on printed pages; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerCenter("&amp;SThis is text.");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    headerCenter(value?:  string): any;
                    /**
                     * Gets or sets the image for the center section of the header.
                     * @param {string} value The image for the center section of the header.
                     * @returns {string | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the image for the center section of the header; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerCenter("&amp;G");
                     * printInfo.headerCenterImage("logo.jpg");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    headerCenterImage(value?:  string): any;
                    /**
                     * Gets or sets the text and format of the left header on printed pages.
                     * @param {string} value The text and format of the left header on printed pages.
                     * @returns {string | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the text and format of the left header on printed pages; otherwise, returns the print setting information.
                     * @example
                     * activeSheet.printInfo().headerLeft("It is &amp;T.");
                     * spread.print(0);
                     */
                    headerLeft(value?:  string): any;
                    /**
                     * Gets or sets the image for the left section of the header.
                     * @param {string} value The image for the left section of the header.
                     * @returns {string | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the image for the left section of the header; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeftImage("logo.jpg");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    headerLeftImage(value?:  string): any;
                    /**
                     * Gets or sets the text and format of the right header on printed pages.
                     * @param {string} value The text and format of the right header on printed pages.
                     * @returns {string | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the text and format of the right header on printed pages; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerRight("&amp;BHeader");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    headerRight(value?:  string): any;
                    /**
                     * Gets or sets the image for the right section of the header.
                     * @param {string} value The image for the right section of the header.
                     * @returns {string | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the image for the right section of the header; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerRight("&amp;G");
                     * printInfo.headerRightImage("logo.jpg");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    headerRightImage(value?:  string): any;
                    /**
                     * Gets or sets the margins for printing, in hundredths of an inch.
                     * @param {Object} value The margins for printing.
                     * @param {number} [value.top] - The top margin, in hundredths of an inch.
                     * @param {number} [value.bottom] -  bottom The bottom margin, in hundredths of an inch.
                     * @param {number} [value.left] - left The left margin, in hundredths of an inch.
                     * @param {number} [value.right] - right The right margin, in hundredths of an inch.
                     * @param {number} [value.header] - header The header offset, in hundredths of an inch.
                     * @param {number} [value.footer] - footer The footer offset, in hundredths of an inch.
                     * @returns {Object | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the margins for printing; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeft("Header Left");
                     * printInfo.headerCenter("Header Center");
                     * printInfo.headerRight("Header Right");
                     * printInfo.footerLeft("Footer Left");
                     * printInfo.footerCenter("Footer Center");
                     * printInfo.footerRight("Footer Right");
                     * printInfo.margin({top:75, bottom:75, left:20, right:20, header:10, footer:20});
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    margin(value?:  GC.Spread.Sheets.Print.PrintMargins): any;
                    /**
                     * Gets or sets the page orientation used for printing.
                     * @param {GC.Spread.Sheets.Print.PrintPageOrientation} value The page orientation used for printing.
                     * @returns {GC.Spread.Sheets.Print.PrintPageOrientation | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the page orientation used for printing; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.bestFitColumns(true);
                     * printInfo.orientation(GC.Spread.Sheets.Print.PrintPageOrientation.landscape);
                     * printInfo.footerCenter("GrapeCity");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    orientation(value?:  GC.Spread.Sheets.Print.PrintPageOrientation): any;
                    /**
                     * Gets or sets the order in which pages print.
                     * @param {GC.Spread.Sheets.Print.PrintPageOrder} value The order in which pages print.
                     * @returns {GC.Spread.Sheets.Print.PrintPageOrder | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns a value that specifies the order in which pages print; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.pageOrder(GC.Spread.Sheets.Print.PrintPageOrder.auto);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    pageOrder(value?:  GC.Spread.Sheets.Print.PrintPageOrder): any;
                    /**
                     * Gets or sets the page range for printing.
                     * @param {string} value The page numbers or page ranges separated by commas counting from the beginning of the document. For example, type "1,3,5-12".
                     * @returns {string | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns a string that provides page numbers or page ranges; otherwise, returns the print setting information.}
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.pageRange("1-3");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    pageRange(value?:  string): any;
                    /**
                     * Gets or sets the paper size for printing.
                     * @param {GC.Spread.Sheets.Print.PaperSize} value The paper size for printing.
                     * @param {number} value.width - The width, in hundredths of an inch.
                     * @param {number} value.height - The height, in hundredths of an inch.
                     * @param @returns {GC.Spread.Sheets.Print.PaperSize | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the paper size for printing; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeft("Header Left");
                     * printInfo.paperSize(new GC.Spread.Sheets.Print.PaperSize(300, 300));
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    paperSize(value?:  GC.Spread.Sheets.Print.PaperSize): any;
                    /**
                     * Gets or sets the quality factor for printing.
                     * @param {number} value The quality factor for printing is a positive integer between 1 and 8. The greater the quality factor, the better the printing quality. When the quality factor is bigger, the printing efficiency is affected.
                     * @returns {number | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the quality factor for printing; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeft("Header Left");
                     * printInfo.qualityFactor(6);
                     * activeSheet.printInfo(printInfo);
                     * spread.print();
                     */
                    qualityFactor(value?:  number): any;
                    /**
                     * Gets or sets the last column of a range of columns to print on the left of each page.
                     * @param {number} value The last column of a range of columns to print on the left of each page.
                     * @returns {number | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the last column of a range of columns to print on the left of each page; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeft("Header Left");
                     * printInfo.repeatColumnStart(0);
                     * printInfo.repeatColumnEnd(2);
                     * printInfo.repeatRowStart(0);
                     * printInfo.repeatRowEnd(2);
                     * activeSheet.printInfo(printInfo);
                     * spread.print();
                     */
                    repeatColumnEnd(value?:  number): any;
                    /**
                     * Gets or sets the first column of a range of columns to print on the left of each page.
                     * @param {number} value The first column of a range of columns to print on the left of each page.
                     * @returns {number | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the first column of a range of columns to print on the left of each page; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeft("Header Left");
                     * printInfo.repeatColumnStart(0);
                     * printInfo.repeatColumnEnd(2);
                     * printInfo.repeatRowStart(0);
                     * printInfo.repeatRowEnd(2);
                     * activeSheet.printInfo(printInfo);
                     * spread.print();
                     */
                    repeatColumnStart(value?:  number): any;
                    /**
                     * Gets or sets the last row of a range of rows to print at the top of each page.
                     * @param {number} value The last row of a range of rows to print at the top of each page.
                     * @returns {number | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the last row of a range of rows to print at the top of each page; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeft("Header Left");
                     * printInfo.repeatColumnStart(0);
                     * printInfo.repeatColumnEnd(2);
                     * printInfo.repeatRowStart(0);
                     * printInfo.repeatRowEnd(2);
                     * activeSheet.printInfo(printInfo);
                     * spread.print();
                     */
                    repeatRowEnd(value?:  number): any;
                    /**
                     * Gets or sets the first row of a range of rows to print at the top of each page.
                     * @param {number} value The first row of a range of rows to print at the top of each page.
                     * @returns {number | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the first row of a range of rows to print at the top of each page; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeft("Header Left");
                     * printInfo.repeatColumnStart(0);
                     * printInfo.repeatColumnEnd(2);
                     * printInfo.repeatRowStart(0);
                     * printInfo.repeatRowEnd(2);
                     * activeSheet.printInfo(printInfo);
                     * spread.print();
                     */
                    repeatRowStart(value?:  number): any;
                    /**
                     * Gets or sets the last row to print when printing a cell range.
                     * @param {number} value The last row to print when printing a cell range.
                     * @returns {number | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the last row to print when printing a cell range; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeft("Header Left");
                     * printInfo.rowStart(0);
                     * printInfo.rowEnd(2);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    rowEnd(value?:  number): any;
                    /**
                     * Gets or sets the first row to print when printing a cell range.
                     * @param {number} value The first row to print when printing a cell range.
                     * @returns {number | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns the first row to print when printing a cell range; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeft("Header Left");
                     * printInfo.rowStart(0);
                     * printInfo.rowEnd(2);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    rowStart(value?:  number): any;
                    /**
                     * Gets or sets whether to print an outline border around the entire control.
                     * @param {boolean} value Whether to print an outline border around the entire control.
                     * @returns {boolean | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns whether to print an outline border around the entire control; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.showBorder(false);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    showBorder(value?:  boolean): any;
                    /**
                     * Gets or sets whether to print the column header.
                     * @param {GC.Spread.Sheets.Print.PrintVisibilityType} value Whether to print the column header.
                     * @returns {GC.Spread.Sheets.Print.PrintVisibilityType | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns whether to print the column header; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.showColumnHeader(GC.Spread.Sheets.Print.PrintVisibilityType.hide);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    showColumnHeader(value?:  GC.Spread.Sheets.Print.PrintVisibilityType): any;
                    /**
                     * Gets or sets whether to print the grid lines.
                     * @param {boolean} value Whether to print the grid lines.
                     * @returns {boolean | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns whether to print the grid lines; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.showGridLine(false);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    showGridLine(value?:  boolean): any;
                    /**
                     * Gets or sets whether to print the row header.
                     * @param {GC.Spread.Sheets.Print.PrintVisibilityType} value Whether to print the row header.
                     * @returns {GC.Spread.Sheets.Print.PrintVisibilityType | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns whether to print the row header; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.showRowHeader(GC.Spread.Sheets.Print.PrintVisibilityType.hide);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    showRowHeader(value?:  GC.Spread.Sheets.Print.PrintVisibilityType): any;
                    /**
                     * Gets or sets whether to print only rows and columns that contain data.
                     * @param {boolean} value Whether to print only rows and columns that contain data.
                     * @returns {boolean | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns whether to print only rows and columns that contain data; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.useMax(true);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    useMax(value?:  boolean): any;
                    /**
                     * Gets or sets the zoom factor used for printing.
                     * @param {number} value The zoom factor used for printing.
                     * @returns {number | GC.Spread.Sheets.Print.PrintInfo} If no value is set, returns a value that specifies the amount to enlarge or reduce the printed worksheet; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GC.Spread.Sheets.Print.PrintInfo();
                     * printInfo.zoomFactor(2);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    zoomFactor(value?:  number): any;
                }
            }

            module Search{
                /**
                 * Specifies the type of search flags.
                 * @enum {number}
                 * @example
                 * //This example uses the SearchFlags enumeration.
                 * activeSheet.getCell(2,3).value("testSearch");
                 * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                 * searchCondition.searchString = "testSearch";
                 * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                 * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                 * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                 * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                 * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.ignoreCase| GC.Spread.Sheets.Search.SearchFlags.useWildCards;
                 * var searchresult= activeSheet.search(searchCondition);
                 * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" +
                 * searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundSheetIndex+"]";
                 * alert(str);
                 */
                export enum SearchFlags{
                    /** Specifies no search flags.
                     * @type {number}
                     */
                    none= 0,
                    /** Determines whether the search considers the case of the letters in the search string.
                     * @type {number}
                     */
                    ignoreCase= 1,
                    /** Determines whether the search considers only an exact match.
                     * @type {number}
                     */
                    exactMatch= 2,
                    /** Determines whether the search considers wildcard characters (*, ?) in the search string.
                     * @type {number}
                     */
                    useWildCards= 4,
                    /** Determines whether to search within a cell range.
                     * @type {number}
                     */
                    blockRange= 8
                }

                /**
                 * Specifies where the search string is found.
                 * @enum {number}
                 * @example
                 * //This example uses the SearchFlags enumeration.
                 * activeSheet.getCell(2,3).value("testSearch");
                 * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                 * searchCondition.searchString = "testSearch";
                 * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                 * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                 * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                 * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                 * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.ignoreCase| GC.Spread.Sheets.Search.SearchFlags.useWildCards;
                 * var searchresult= activeSheet.search(searchCondition);
                 * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" +
                 * searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundSheetIndex+"]";
                 * alert(str);
                 */
                export enum SearchFoundFlags{
                    /**
                     * Indicates that no string is found.
                     * @type {number}
                     */
                    none= 0,
                    /**
                     * Indicates that the string is found in the cell text.
                     * @type {number}
                     */
                    cellText= 1,
                    /**
                     * Indicates that the string is found in the cell tag.
                     * @type {number}
                     */
                    cellTag= 4,
                    /**
                     * Indicates that the string is found in the cell formula.
                     * @type {number}
                     */
                    cellFormula= 8
                }

                /**
                 * Specifies the type of search direction.
                 * @enum {number}
                 * @example
                 * //This example uses the SearchFlags enumeration.
                 * activeSheet.getCell(2,3).value("testSearch");
                 * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                 * searchCondition.searchString = "testSearch";
                 * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                 * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                 * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                 * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                 * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.ignoreCase| GC.Spread.Sheets.Search.SearchFlags.useWildCards;
                 * var searchresult= activeSheet.search(searchCondition);
                 * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" +
                 * searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundSheetIndex+"]";
                 * alert(str);
                 */
                export enum SearchOrder{
                    /** Determines whether the search goes by column, row coordinates.
                     * @type {number}
                     */
                    zOrder= 0,
                    /** Determines whether the search goes by row, column coordinates.
                     * @type {number}
                     */
                    nOrder= 1
                }


                export class SearchCondition{
                    /**
                     * Defines the search condition.
                     * @class
                     * @example
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.ignoreCase| GC.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", * foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    constructor();
                    /** The index of the column at which to end.
                     * @type {number}
                     * @example
                     * //This example searches a block of cells.
                     * activeSheet.getCell(0,0).text("testSearch");
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.columnStart = 1;
                     * searchCondition.columnEnd = 10;
                     * searchCondition.rowStart = 1;
                     * searchCondition.rowEnd = 10;
                     * searchCondition.sheetArea = GC.Spread.Sheets.SheetArea.viewport;
                     * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.blockRange;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    columnEnd: number;
                    /** The index of the column at which to start.
                     * @type {number}
                     * @example
                     * //This example searches a block of cells.
                     * activeSheet.getCell(0,0).text("testSearch");
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.columnStart = 1;
                     * searchCondition.columnEnd = 10;
                     * searchCondition.rowStart = 1;
                     * searchCondition.rowEnd = 10;
                     * searchCondition.sheetArea = GC.Spread.Sheets.SheetArea.viewport;
                     * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.blockRange;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    columnStart: number;
                    /** Index of the sheet on which to end searching.
                     * @type {number}
                     * @example
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.ignoreCase| GC.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    endSheetIndex: number;
                    /** The index of the row at which to end.
                     * @type {number}
                     * @example
                     * //This example searches a block of cells.
                     * activeSheet.getCell(0,0).text("testSearch");
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.columnStart = 1;
                     * searchCondition.columnEnd = 10;
                     * searchCondition.rowStart = 1;
                     * searchCondition.rowEnd = 10;
                     * searchCondition.sheetArea = GC.Spread.Sheets.SheetArea.viewport;
                     * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.blockRange;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    rowEnd: number;
                    /** The index of the row at which to start.
                     * @type {number}
                     * @example
                     * //This example searches a block of cells.
                     * activeSheet.getCell(0,0).text("testSearch");
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.columnStart = 1;
                     * searchCondition.columnEnd = 10;
                     * searchCondition.rowStart = 1;
                     * searchCondition.rowEnd = 10;
                     * searchCondition.sheetArea = GC.Spread.Sheets.SheetArea.viewport;
                     * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.blockRange;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    rowStart: number;
                    /** The enumeration that specifies the options of the search.
                     * @type {GC.Spread.Sheets.Search.SearchFlags}
                     * @example
                     * //This example sets the searchFlags property.
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.ignoreCase| GC.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    searchFlags: GC.Spread.Sheets.Search.SearchFlags;
                    /** The enumeration that specifies whether the search goes by coordinates of (column, row) or (row, column).
                     * @type {GC.Spread.Sheets.Search.SearchOrder}
                     * @example
                     * //This example sets the searchFlags property.
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.ignoreCase| GC.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    searchOrder: GC.Spread.Sheets.Search.SearchOrder;
                    /** The string for which to search.
                     * @type {string}
                     * @example
                     * //This example sets the searchFlags property.
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.ignoreCase| GC.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    searchString: string;
                    /** The enumeration that indicates whether the search includes the content in the cell notes, tags, or text.
                     * @type {GC.Spread.Sheets.Search.SearchFoundFlags}
                     * @example
                     * //This example sets the searchFlags property.
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.ignoreCase| GC.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    searchTarget: GC.Spread.Sheets.Search.SearchFoundFlags;
                    /** The area of the sheet for search.
                     * @type {GC.Spread.Sheets.SheetArea}
                     * @example
                     * //This example searches a block of cells.
                     * activeSheet.getCell(0,0).text("testSearch");
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.columnStart = 1;
                     * searchCondition.columnEnd = 10;
                     * searchCondition.rowStart = 1;
                     * searchCondition.rowEnd = 10;
                     * searchCondition.sheetArea = GC.Spread.Sheets.SheetArea.viewport;
                     * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.blockRange;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    sheetArea: GC.Spread.Sheets.SheetArea;
                    /** Index of the sheet on which to start searching.
                     * @type {number}
                     * @example
                     * //This example searches a block of cells.
                     * activeSheet.getCell(0,0).text("testSearch");
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.columnStart = 1;
                     * searchCondition.columnEnd = 10;
                     * searchCondition.rowStart = 1;
                     * searchCondition.rowEnd = 10;
                     * searchCondition.sheetArea = GC.Spread.Sheets.SheetArea.viewport;
                     * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.blockRange;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    startSheetIndex: number;
                }

                export class SearchResult{
                    /**
                     * Defines the search result.
                     * @class
                     */
                    constructor();
                    /** The index of the column at which a match is found.
                     * @type {number}
                     * @example
                     * //This example gets the foundColumnIndex property.
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.ignoreCase| GC.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    foundColumnIndex: number;
                    /** The index of the row at which a match is found.
                     * @type {number}
                     * @example
                     * //This example gets the foundColumnIndex property.
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.ignoreCase| GC.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    foundRowIndex: number;
                    /** The index of the sheet in which a match is found.
                     * @type {number}
                     * @example
                     * //This example gets the foundColumnIndex property.
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.ignoreCase| GC.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    foundSheetIndex: number;
                    /** The found string.
                     * @type {object}
                     * @example
                     * //This example gets the foundColumnIndex property.
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.ignoreCase| GC.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    foundString: Object;
                    /**
                     * An enumeration that specifies what is matched.
                     * @type {GC.Spread.Sheets.Search.SearchFoundFlags}
                     * @example
                     * //This example gets the foundColumnIndex property.
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GC.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GC.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GC.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GC.Spread.Sheets.Search.SearchFlags.ignoreCase| GC.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    searchFoundFlag: GC.Spread.Sheets.Search.SearchFoundFlags;
                }
            }

            module Shapes{

                export interface IControlInfo{
                    x: number | string; // A number value or a formula string (starts with =) will get a number value
                    y: number | string; // A number value or a formula string (starts with =) will get a number value
                    xBehavior: 0 | 1;   // 0 if can do adjust in x (horizontal), otherwise 1
                    yBehavior: 0 | 1;   // 0 if can do adjust in y (vertical), otherwise 1
                }


                export interface IPointInfo{
                    x: number | string; // A number value or a formula string (starts with =) will get a number value
                    y: number | string; // A number value or a formula string (starts with =) will get a number value
                }


                export interface IShapeBorder{
                    color: string;
                    lineStyle: GC.Spread.Sheets.Shapes.PresetLineDashStyle;
                    width: number;
                    capType: GC.Spread.Sheets.Shapes.LineCapStyle;
                    joinType: GC.Spread.Sheets.Shapes.LineJoinStyle;
                }


                export interface IShapeFill{
                    color?: string;
                    transparency?: number | string;
                }


                export interface IShapeFillOption{
                    type: GC.Spread.Sheets.Shapes.ShapeFillType;
                    color?: string;
                    transparency?: number; // 0 ~ 1
                }


                export interface IShapeLine{
                    color?: string;
                    lineStyle?: GC.Spread.Sheets.Shapes.PresetLineDashStyle | string;
                    width?: number | string;
                    capType?: GC.Spread.Sheets.Shapes.LineCapStyle | string;
                    joinType?: GC.Spread.Sheets.Shapes.LineJoinStyle | string;
                    transparency?: number | string;
                    beginArrowheadStyle?: GC.Spread.Sheets.Shapes.ArrowheadStyle;
                    beginArrowheadWidth?: GC.Spread.Sheets.Shapes.ArrowheadWidth;
                    beginArrowheadLength?: GC.Spread.Sheets.Shapes.ArrowheadLength;
                    endArrowheadStyle?: GC.Spread.Sheets.Shapes.ArrowheadStyle;
                    endArrowheadWidth?: GC.Spread.Sheets.Shapes.ArrowheadWidth;
                    endArrowheadLength?: GC.Spread.Sheets.Shapes.ArrowheadLength;
                }


                export interface IShapeLineArrowConfig{
                    type: GC.Spread.Sheets.Shapes.ArrowheadStyle;
                    widthType: GC.Spread.Sheets.Shapes.ArrowheadWidth;
                    lengthType: GC.Spread.Sheets.Shapes.ArrowheadLength;
                }


                export interface IShapeLineArrowOption{
                    beginArrow?: GC.Spread.Sheets.Shapes.IShapeLineArrowConfig;
                    endArrow?: GC.Spread.Sheets.Shapes.IShapeLineArrowConfig;
                }


                export interface IShapeModel{
                    id?: string;
                    left?: number | string; // A number value or a formula string (starts with =) will get a number value
                    top?: number | string; // A number value or a formula string (starts with =) will get a number value
                    width?: number | string; // A number value or a formula string (starts with =) will get a number value
                    height?: number | string; // A number value or a formula string (starts with =) will get a number value
                    angle?: number | string; // A number value or a formula string (starts with =) will get a number value
                    options?: GC.Spread.Sheets.Shapes.IShapeOptions;
                    path: string[][];
                    controls?: GC.Spread.Sheets.Shapes.IControlInfo[];
                    connectionPoints?: GC.Spread.Sheets.Shapes.IPointInfo[];
                    variables?: Object;    // a key-value pairs object, value can be a number or formula string (starts with =), can be referred by variables[key] in formula
                    textRect?: {left: number, top: number, bottom: number, right: number }; // specify the rectangle for shape text
                }


                export interface IShapeOptions{
                    fill?: GC.Spread.Sheets.Shapes.IShapeFillOption;
                    textFormatOptions?: GC.Spread.Sheets.Shapes.IShapeTextFormatOption;
                    stroke?: GC.Spread.Sheets.Shapes.IShapeStrokeOption;
                    endPoints?: GC.Spread.Sheets.Shapes.IShapeLineArrowOption
                }


                export interface IShapeStrokeOption{
                    type: 0 | 1;   // 0: none, 1: solid
                    color?: string;
                    width?: number;
                    capType?: 0 | 1 | 2;    // 0: round, 1: square, 2: butt
                    joinType?: 0 | 1 | 2;   // 0: round, 1: miter, 2: bevel
                    lineStyle?: GC.Spread.Sheets.Shapes.PresetLineDashStyle;
                }


                export interface IShapeTextEffect{
                    color?: string;
                    transparency?: number | string;
                    font?: string;
                }


                export interface IShapeTextFormatOption{
                    text?: string;
                    fill?: GC.Spread.Sheets.Shapes.IShapeFillOption;
                    font?: string;     // css font string
                    margins?: [number, number, number, number];
                    textDirection?:  "horizontal" | "vertical" | "rotate90" | "rotate270";
                    horizontalAlignment?: 0 | 1 | 2;   // 0: left, 1: center, 2: right
                    verticalAlignment?: 0 | 1 | 2;     // 0: top, 1: center, 2: bottom
                    wrapTextInShape?: boolean;
                    allowTextToOverflowShape?: boolean;
                }


                export interface IShapeTextFrame{
                    vAlign?: GC.Spread.Sheets.VerticalAlign | string;
                    hAlign?: GC.Spread.Sheets.HorizontalAlign | string;
                }

                /**
                 * Specifies the length of the arrowhead at the end of a line.
                 * @enum {number}
                 */
                export enum ArrowheadLength{
                    /**
                     * Short
                     */
                    short= 0,
                    /**
                     * Medium
                     */
                    medium= 1,
                    /**
                     * Long
                     */
                    long= 2
                }

                /**
                 * Specifies the style of the arrowhead at the end of a line.
                 * @enum {number}
                 */
                export enum ArrowheadStyle{
                    /**
                     * No arrowhead
                     */
                    none= 0,
                    /**
                     * Triangular
                     */
                    triangle= 1,
                    /**
                     * Stealth-shaped
                     */
                    stealth= 2,
                    /**
                     * Diamond-shaped
                     */
                    diamond= 3,
                    /**
                     * Oval-shaped
                     */
                    oval= 4,
                    /**
                     * Open
                     */
                    open= 5
                }

                /**
                 * Specifies the width of the arrowhead at the end of a line.
                 * @enum {number}
                 */
                export enum ArrowheadWidth{
                    /**
                     * Narrow
                     */
                    narrow= 0,
                    /**
                     * Medium
                     */
                    medium= 1,
                    /**
                     * Wide
                     */
                    wide= 2
                }

                /**
                 * Defines all the types of build-in shapes.
                 * @enum {number}
                 */
                export enum AutoShapeType{
                    /**
                     * Specifies a rectangle.
                     */
                    rectangle= 1,
                    /**
                     * Specifies a parallelogram.
                     */
                    parallelogram= 2,
                    /**
                     * Specifies a trapezoid.
                     */
                    trapezoid= 3,
                    /**
                     * Specifies a diamond.
                     */
                    diamond= 4,
                    /**
                     * Specifies a rounded rectangle.
                     */
                    roundedRectangle= 5,
                    /**
                     * Specifies an octagon.
                     */
                    octagon= 6,
                    /**
                     * Specifies an isosceles triangle.
                     */
                    isoscelesTriangle= 7,
                    /**
                     * Specifies a right triangle.
                     */
                    rightTriangle= 8,
                    /**
                     * Specifies an oval.
                     */
                    oval= 9,
                    /**
                     * Specifies a hexagon.
                     */
                    hexagon= 10,
                    /**
                     * Specifies a cross.
                     */
                    cross= 11,
                    /**
                     * Specifies a pentagon.
                     */
                    regularPentagon= 12,
                    /**
                     * Specifies a can.
                     */
                    can= 13,
                    /**
                     * Specifies a cube.
                     */
                    cube= 14,
                    /**
                     * Specifies a bevel.
                     */
                    bevel= 15,
                    /**
                     * Specifies a folded corner.
                     */
                    foldedCorner= 16,
                    /**
                     * Specifies a smiley face.
                     */
                    smileyFace= 17,
                    /**
                     * Specifies a donut.
                     */
                    donut= 18,
                    /**
                     * Specifies the "No" symbol.
                     */
                    noSymbol= 19,
                    /**
                     * Specifies a block arc.
                     */
                    blockArc= 20,
                    /**
                     * Specifies a heart.
                     */
                    heart= 21,
                    /**
                     * Specifies a lightning bolt.
                     */
                    lightningBolt= 22,
                    /**
                     * Specifies a sun.
                     */
                    sun= 23,
                    /**
                     * Specifies a moon.
                     */
                    moon= 24,
                    /**
                     * Specifies an arc.
                     */
                    arc= 25,
                    /**
                     * Specifies a double bracket.
                     */
                    doubleBracket= 26,
                    /**
                     * Specifies a double brace.
                     */
                    doubleBrace= 27,
                    /**
                     * Specifies a plaque.
                     */
                    plaque= 28,
                    /**
                     * Specifies the left bracket.
                     */
                    leftBracket= 29,
                    /**
                     * Specifies the right bracket.
                     */
                    rightBracket= 30,
                    /**
                     * Specifies the left brace.
                     */
                    leftBrace= 31,
                    /**
                     * Specifies the right brace.
                     */
                    rightBrace= 32,
                    /**
                     * Specifies a block arrow that points right.
                     */
                    rightArrow= 33,
                    /**
                     * Specifies a block arrow that points left.
                     */
                    leftArrow= 34,
                    /**
                     * Specifies a block arrow that points up.
                     */
                    upArrow= 35,
                    /**
                     * Specifies a block arrow that points down.
                     */
                    downArrow= 36,
                    /**
                     * Specifies a block arrow with arrowheads that point both left and right.
                     */
                    leftRightArrow= 37,
                    /**
                     * Specifies a block arrow that points up and down.
                     */
                    upDownArrow= 38,
                    /**
                     * Specifies block arrows that point up, down, left, and right.
                     */
                    quadArrow= 39,
                    /**
                     * Specifies a block arrow with arrowheads that point left, right, and up.
                     */
                    leftRightUpArrow= 40,
                    /**
                     * Specifies a block arrow that follows a curved 90-degree angle.
                     */
                    bentArrow= 41,
                    /**
                     * Specifies a block arrow forming a U shape.
                     */
                    uTurnArrow= 42,
                    /**
                     * Specifies a block arrow with arrowheads that point left and up.
                     */
                    leftUpArrow= 43,
                    /**
                     * Specifies a block arrow that follows a sharp 90-degree angle. Points up by default.
                     */
                    bentUpArrow= 44,
                    /**
                     * Specifies a block arrow that curves right
                     */
                    curvedRightArrow= 45,
                    /**
                     * Specifies a block arrow that curves left.
                     */
                    curvedLeftArrow= 46,
                    /**
                     * Specifies a block arrow that curves up.
                     */
                    curvedUpArrow= 47,
                    /**
                     * Specifies a block arrow that curves down.
                     */
                    curvedDownArrow= 48,
                    /**
                     * Specifies a block arrow that points right with stripes at the tail.
                     */
                    stripedRightArrow= 49,
                    /**
                     * Specifies a notched block arrow that points right
                     */
                    notchedRightArrow= 50,
                    /**
                     * Specifies a pentagon.
                     */
                    pentagon= 51,
                    /**
                     * Specifies a chevron.
                     */
                    chevron= 52,
                    /**
                     * Specifies a callout with an arrow that points right.
                     */
                    rightArrowCallout= 53,
                    /**
                     * Specifies a callout with an arrow that points left.
                     */
                    leftArrowCallout= 54,
                    /**
                     * Specifies a callout with an arrow that points up.
                     */
                    upArrowCallout= 55,
                    /**
                     * Specifies a callout with an arrow that points down.
                     */
                    downArrowCallout= 56,
                    /**
                     * Specifies a callout with arrowheads that point both left and right.
                     */
                    leftRightArrowCallout= 57,
                    /**
                     * Specifies a callout with arrows that point up and down.
                     */
                    upDownArrowCallout= 58,
                    /**
                     * Specifies a callout with arrows that point up, down, left, and right.
                     */
                    quadArrowCallout= 59,
                    /**
                     * Specifies a block arrow that follows a curved 180-degree angle.
                     */
                    circularArrow= 60,
                    /**
                     * Specifies a process flowchart symbol.
                     */
                    flowchartProcess= 61,
                    /**
                     * Specifies an alternate process flowchart symbol.
                     */
                    flowchartAlternateProcess= 62,
                    /**
                     * Specifies a decision flowchart symbol.
                     */
                    flowchartDecision= 63,
                    /**
                     * Specifies a data flowchart symbol.
                     */
                    flowchartData= 64,
                    /**
                     * Specifies a predefined process flowchart symbol.
                     */
                    flowchartPredefinedProcess= 65,
                    /**
                     * Specifies an internal storage flowchart symbol.
                     */
                    flowchartInternalStorage= 66,
                    /**
                     * Specifies a document flowchart symbol.
                     */
                    flowchartDocument= 67,
                    /**
                     * Specifies a multi-document flowchart symbol.
                     */
                    flowchartMultidocument= 68,
                    /**
                     * Specifies a terminator flowchart symbol.
                     */
                    flowchartTerminator= 69,
                    /**
                     * Specifies a preparation flowchart symbol.
                     */
                    flowchartPreparation= 70,
                    /**
                     * Specifies a manual input flowchart symbol.
                     */
                    flowchartManualInput= 71,
                    /**
                     * Specifies a manual operation flowchart symbol.
                     */
                    flowchartManualOperation= 72,
                    /**
                     * Specifies a connector flowchart symbol.
                     */
                    flowchartConnector= 73,
                    /**
                     * Specifies an off-page connector flowchart symbol.
                     */
                    flowchartOffpageConnector= 74,
                    /**
                     * Specifies a card flowchart symbol.
                     */
                    flowchartCard= 75,
                    /**
                     * Specifies a punched tape flowchart symbol.
                     */
                    flowchartPunchedTape= 76,
                    /**
                     * Specifies a summing junction flowchart symbol.
                     */
                    flowchartSummingJunction= 77,
                    /**
                     * Specifies the "Or" flowchart symbol.
                     */
                    flowchartOr= 78,
                    /**
                     * Specifies a collate flowchart symbol.
                     */
                    flowchartCollate= 79,
                    /**
                     * Specifies a sort flowchart symbol.
                     */
                    flowchartSort= 80,
                    /**
                     * Specifies an extract flowchart symbol.
                     */
                    flowchartExtract= 81,
                    /**
                     * Specifies a merge flowchart symbol.
                     */
                    flowchartMerge= 82,
                    /**
                     * Specifies a stored data flowchart symbol.
                     */
                    flowchartStoredData= 83,
                    /**
                     * Specifies a delay flowchart symbol.
                     */
                    flowchartDelay= 84,
                    /**
                     * Specifies a sequential access storage flowchart symbol.
                     */
                    flowchartSequentialAccessStorage= 85,
                    /**
                     * Specifies a magnetic disk flowchart symbol.
                     */
                    flowchartMagneticDisk= 86,
                    /**
                     * Specifies a direct access storage flowchart symbol.
                     */
                    flowchartDirectAccessStorage= 87,
                    /**
                     * Specifies a display flowchart symbol.
                     */
                    flowchartDisplay= 88,
                    /**
                     * Specifies an explosion.
                     */
                    explosion1= 89,
                    /**
                     * Specifies an explosion.
                     */
                    explosion2= 90,
                    /**
                     * Specifies a 4-point star.
                     */
                    shape4pointStar= 91,
                    /**
                     * Specifies a 5-point star.
                     */
                    shape5pointStar= 92,
                    /**
                     * Specifies an 8-point star.
                     */
                    shape8pointStar= 93,
                    /**
                     * Specifies a 16-point star.
                     */
                    shape16pointStar= 94,
                    /**
                     * Specifies a 24-point star.
                     */
                    shape24pointStar= 95,
                    /**
                     * Specifies a 32-point star.
                     */
                    shape32pointStar= 96,
                    /**
                     * Specifies a ribbon banner with a center area above the ribbon ends.
                     */
                    upRibbon= 97,
                    /**
                     * Specifies a ribbon banner with a center area below the ribbon ends.
                     */
                    downRibbon= 98,
                    /**
                     * Specifies a ribbon banner that curves up.
                     */
                    curvedUpRibbon= 99,
                    /**
                     * Specifies a ribbon banner that curves down.
                     */
                    curvedDownRibbon= 100,
                    /**
                     * Specifies a vertical scroll shape.
                     */
                    verticalScroll= 101,
                    /**
                     * Specifies a horizontal scroll shape.
                     */
                    horizontalScroll= 102,
                    /**
                     * Specifies a wave shape.
                     */
                    wave= 103,
                    /**
                     * Specifies a double wave shape.
                     */
                    doubleWave= 104,
                    /**
                     * Specifies a rectangular callout.
                     */
                    rectangularCallout= 105,
                    /**
                     * Specifies a rounded rectangle-shaped callout.
                     */
                    roundedRectangularCallout= 106,
                    /**
                     * Specifies an oval-shaped callout.
                     */
                    ovalCallout= 107,
                    /**
                     * Specifies a cloud callout.
                     */
                    cloudCallout= 108,
                    /**
                     * Specifies a callout with border and horizontal callout lines.
                     */
                    lineCallout1= 109,
                    /**
                     * Specifies a callout with a diagonal straight line.
                     */
                    lineCallout2= 110,
                    /**
                     * Specifies a callout with an angled line.
                     */
                    lineCallout3= 111,
                    /**
                     * Specifies a callout with callout line segments forming a U-shape.
                     */
                    lineCallout4= 112,
                    /**
                     * Specifies a callout with a horizontal accent bar.
                     */
                    lineCallout1AccentBar= 113,
                    /**
                     * Specifies a callout with a diagonal callout line and accent bar.
                     */
                    lineCallout2AccentBar= 114,
                    /**
                     * Specifies a callout with an angled callout line and accent bar.
                     */
                    lineCallout3AccentBar= 115,
                    /**
                     * Specifies a callout with an accent bar and callout line segments forming a U-shape.
                     */
                    lineCallout4AccentBar= 116,
                    /**
                     * Specifies a callout with a horizontal line.
                     */
                    lineCallout1NoBorder= 117,
                    /**
                     * Specifies a callout with no border and a diagonal callout line.
                     */
                    lineCallout2NoBorder= 118,
                    /**
                     * Specifies a callout with no border and an angled callout line.
                     */
                    lineCallout3NoBorder= 119,
                    /**
                     * Specifies a callout with no border and callout line segments forming a U-shape.
                     */
                    lineCallout4NoBorder= 120,
                    /**
                     * Specifies a callout with a border and horizontal accent bar.
                     */
                    lineCallout1BorderandAccentBar= 121,
                    /**
                     * Specifies a callout with border, diagonal straight line, and accent bar.
                     */
                    lineCallout2BorderandAccentBar= 122,
                    /**
                     * Specifies a callout with border, angled callout line, and accent bar.
                     */
                    lineCallout3BorderandAccentBar= 123,
                    /**
                     * Specifies a callout with border, accent bar, and callout line segments forming a U-shape.
                     */
                    lineCallout4BorderandAccentBar= 124,
                    /**
                     * Specifies a button with no default picture or text. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonCustom= 125,
                    /**
                     * Specifies the Home button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonHome= 126,
                    /**
                     * Specifies the Help button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonHelp= 127,
                    /**
                     * Specifies the Information button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonInformation= 128,
                    /**
                     * Specifies the Back or Previous button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonBackorPrevious= 129,
                    /**
                     * Specifies the Forward or Next button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonForwardorNext= 130,
                    /**
                     * Specifies the Beginning button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonBeginning= 131,
                    /**
                     * Specifies the End button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonEnd= 132,
                    /**
                     * Specifies the Return button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonReturn= 133,
                    /**
                     * Specifies the Document button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonDocument= 134,
                    /**
                     * Specifies the Sound button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonSound= 135,
                    /**
                     * Specifies the Movie button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonMovie= 136,
                    /**
                     * Specifies a balloon.
                     */
                    balloon= 137,
                    /**
                     * Specifies an offline storage flowchart symbol.
                     */
                    flowchartOfflineStorage= 138,
                    /**
                     * Specifies a ribbon with an arrow at both ends.
                     */
                    leftRightRibbon= 139,
                    /**
                     * Specifies a rectangle with two triangle-shapes removed; a diagonal stripe.
                     */
                    diagonalStripe= 140,
                    /**
                     * Specifies a circle (\u2018pie\u2019) with a portion missing.
                     */
                    pie= 141,
                    /**
                     * Specifies a trapezoid with asymmetrical non-parallel sides.
                     */
                    nonIsoscelesTrapezoid= 142,
                    /**
                     * Specifies a decagon.
                     */
                    decagon= 143,
                    /**
                     * Specifies a heptagon.
                     */
                    heptagon= 144,
                    /**
                     * Specifies a dodecagon
                     */
                    dodecagon= 145,
                    /**
                     * Specifies a 6-point star.
                     */
                    star6Point= 146,
                    /**
                     * Specifies a 7-point star.
                     */
                    star7Point= 147,
                    /**
                     * Specifies a 10-point star.
                     */
                    star10Point= 148,
                    /**
                     * Specifies a 12-point star.
                     */
                    star12Point= 149,
                    /**
                     * Specifies a rectangle with one rounded corner.
                     */
                    round1Rectangle= 150,
                    /**
                     * Specifies a rectangle with two-rounded corners that share a side.
                     */
                    round2SameRectangle= 151,
                    /**
                     * Specifies a rectangle with two rounded corners, diagonally-opposed.
                     */
                    round2DiagRectangle= 152,
                    /**
                     * Specifies a rectangle with one snipped corner and one rounded corner.
                     */
                    snipRoundRectangle= 153,
                    /**
                     * Specifies a rectangle with one snipped corner.
                     */
                    snip1Rectangle= 154,
                    /**
                     * Specifies a rectangle with two snipped corners that share a side.
                     */
                    snip2SameRectangle= 155,
                    /**
                     * Specifies a rectangle with two snipped corners, diagonally-opposed.
                     */
                    snip2DiagRectangle= 156,
                    /**
                     * Specifies a rectangular picture frame.
                     */
                    frame= 157,
                    /**
                     * Specifies half of a rectangular picture frame.
                     */
                    halfFrame= 158,
                    /**
                     * Specifies a water droplet.
                     */
                    tear= 159,
                    /**
                     * Specifies a circle with a line connecting two points on the perimeter through the interior of the circle; a circle with a chord.
                     */
                    chord= 160,
                    /**
                     * Specifies a rectangle with a rectangular-shaped hole.
                     */
                    corner= 161,
                    /**
                     * Specifies the addition symbol \u2018+\u2019.
                     */
                    mathPlus= 162,
                    /**
                     * Specifies the subtraction symbol \u2018-\u2018.
                     */
                    mathMinus= 163,
                    /**
                     * Specifies the multiplication symbol \u2018x\u2019.
                     */
                    mathMultiply= 164,
                    /**
                     * Specifies the division symbol \u2018\xf7\u2019.
                     */
                    mathDivide= 165,
                    /**
                     * Specifies the equivalence symbol \u2018=\u2019.
                     */
                    mathEqual= 166,
                    /**
                     * Specifies the non-equivalence symbol \u2018\u2260\u2019.
                     */
                    mathNotEqual= 167,
                    /**
                     * Specifies four right triangles aligning along a rectangular path with four \u2018snipped\u2019 corners.
                     */
                    cornerTabs= 168,
                    /**
                     * Specifies four small squares that define a rectangular shape.
                     */
                    squareTabs= 169,
                    /**
                     * Specifies four quarter-circles defining a rectangular shape.
                     */
                    plaqueTabs= 170,
                    /**
                     * Specifies a gear with six teeth.
                     */
                    gear6= 171,
                    /**
                     * Specifies a gear with nine teeth
                     */
                    gear9= 172,
                    /**
                     * Specifies a funnel.
                     */
                    funnel= 173,
                    /**
                     * Specifies a quarter of a circular shape.
                     */
                    pieWedge= 174,
                    /**
                     * Specifies a circular arrow pointing counter-clockwise.
                     */
                    leftCircularArrow= 175,
                    /**
                     * Specifies a circular arrow pointing clockwise and counter-clockwise; a curved arrow with points at both ends.
                     */
                    leftRightCircularArrow= 176,
                    /**
                     * Specifies a curved arrow.
                     */
                    swooshArrow= 177,
                    /**
                     * Specifies a cloud shape.
                     */
                    cloud= 178,
                    /**
                     * Specifies a square divided into four parts along diagonal lines.
                     */
                    chartX= 179,
                    /**
                     * Specifies a square divided six parts along vertical and diagonal lines.
                     */
                    chartStar= 180,
                    /**
                     * Specifies a square divided vertically and horizontally into four quarters.
                     */
                    chartPlus= 181,
                    /**
                     * Specifies an inverse line.
                     */
                    lineInverse= 182
                }

                /**
                 * Defines the type of Connector.
                 * @enum {number}
                 */
                export enum ConnectorType{
                    /**
                     * Specifies a straight line connector.
                     */
                    straight= 0,
                    /**
                     * Specifies an elbow connector.
                     */
                    elbow= 1
                }

                /**
                 * Specifies the cap type for a line.
                 * @enum {number}
                 */
                export enum LineCapStyle{
                    /**
                     * Specifies the end of the line is flat.
                     */
                    flat= 2,
                    /**
                     * Specifies the end of the line is capped with a square shape.
                     */
                    square= 1,
                    /**
                     * Specifies the end of the line is rounded.
                     */
                    round= 0
                }

                /**
                 * Specifies the corners style of two intersecting lines.
                 * @enum {number}
                 */
                export enum LineJoinStyle{
                    /**
                     * Specifies the corners where the two lines intersect are rounded.
                     */
                    round= 0,
                    /**
                     * Specifies the corners where the two lines intersect are squared off.
                     */
                    miter= 1,
                    /**
                     * Specifies the corners where the two lines intersect are cut off at a 45 degree angle.
                     */
                    bevel= 2
                }

                /**
                 * Specifies the dash style for a line.
                 * @enum {number}
                 */
                export enum PresetLineDashStyle{
                    /**
                     * Line is solid.
                     */
                    solid= 0,
                    /**
                     * Line is made up of square dots.
                     */
                    squareDot= 1,
                    /**
                     * Line consists of dashes only.
                     */
                    dash= 2,
                    /**
                     * Line consists of long dashes.
                     */
                    longDash= 3,
                    /**
                     * Line is a dash-dot pattern.
                     */
                    dashDot= 4,
                    /**
                     * Line is a long dash-dot pattern.
                     */
                    longDashDot= 5,
                    /**
                     * Line is a long dash-dot-dot pattern.
                     */
                    longDashDotDot= 6,
                    /**
                     * Line is a system dash pattern.
                     */
                    sysDash= 7,
                    /**
                     * Line is a system dot pattern.
                     */
                    sysDot= 8,
                    /**
                     * Line is a system dash-dot pattern.
                     */
                    sysDashDot= 9,
                    /**
                     * Line is a dash-dot-dot pattern.
                     */
                    dashDotDot= 10
                }

                /**
                 * Defines fill type of shape.
                 * @enum {number}
                 */
                export enum ShapeFillType{
                    /**
                     * No Fill
                     */
                    none= 0,
                    /**
                     * Solid Fill
                     */
                    solid= 1
                }


                export class ConnectorShape extends GC.Spread.Sheets.Shapes.ShapeBase{
                    
                     /**
                     * Represents a ConnectorShape.
                     * @param {GC.Spread.Sheets.Worksheet} worksheet The host sheet of the shape.
                     * @param {string} name The name of shape.
                     * @param {GC.Spread.Sheets.Shapes.ConnectorType} connectorType The type of the connector shape.
                     * @param {number} beginX The <i>x</i> location of the start point for the connector shape.
                     * @param {number} beginY The <i>y</i> location of the start point for the connector shape.
                     * @param {number} endX  The <i>x</i> location of the end point for the connector shape.
                     * @param {number} endY The <i>y</i> location of the end point for the connector shape.
                     */
                    constructor(worksheet:  GC.Spread.Sheets.Worksheet,  name:  string);
                    /**
                     * Gets or sets the adjustment values of the connector shape.
                     * @param {number[]} arrayValue The adjustment values in array.
                     * @return {number[] | void} if no value is set, returns the current adjustment values of the shape.
                     * @example
                     * var myConnector = sheet.shapes.addConnector("myConnector", GC.Spread.Sheets.Shapes.ConnectorType.elbow, 50, 50, 200, 500);
                     * var adjustments = myConnector.adjustments();
                     * console.log(adjustments);
                     * adjustments = [-0.8];
                     * myConnector.adjustments(adjustments);
                     */
                    adjustments(arrayValue?:  number[]): number[] | void;
                    /**
                     * Gets or sets the end connector info of the connectorShape.
                     * @param {object} connector The end connector info of the connectorShape.
                     * @param {string} connector.name The name of the end connector.
                     * @param {number} connector.index The connect point index of the end connector.
                     * @returns {object} connectorInfo - If no value is set, returns the end connector info of the connectorShape. When the connectorShape has no end connector returns null.
                     * connectorInfo.name {string} The name of the end connector.
                     * connectorInfo.index {number} The connect point index of the end connector.
                     * connectorInfo.shape {GC.Spread.Sheets.Shapes.Shape} The end connector.
                     * @example
                     * var shape1 = sheet.shapes.add("myShape1", GC.Spread.Sheets.Shapes.AutoShapeType.rectangle, 62 * 9, 0, 200, 200);
                     * var shape2 = sheet.shapes.addConnector("myShape", GC.Spread.Sheets.Shapes.ConnectorType.straight, 220, 120, 300, 120);
                     * var endConnector = shape.endConnector();
                     * shape2.endConnector({name: shape1.name(), index: 2});
                     */
                    endConnector(connector?:  Object): Object | void;
                    /**
                     * Gets or sets the start connector info of the connectorShape.
                     * @param {object} connector The start connector info of the connectorShape.
                     * @param {string} connector.name The name of the start connector.
                     * @param {number} connector.index The connect point index of the start connector.
                     * @returns {object} connectorInfo - If no value is set, returns the start connector info of the connectorShape. When the connectorShape has no start connector returns return null.
                     * connectorInfo.name {string} The name of the start connector.
                     * connectorInfo.index {number} The connect point index of the start connector.
                     * connectorInfo.shape {GC.Spread.Sheets.Shapes.Shape} The start connector.
                     * @example
                     * var shape1 = sheet.shapes.add("myShape1", GC.Spread.Sheets.Shapes.AutoShapeType.rectangle, 62 * 9, 0, 200, 200);
                     * var shape2 = sheet.shapes.addConnector("myShape", GC.Spread.Sheets.Shapes.ConnectorType.straight, 220, 120, 300, 120);
                     * var startConnector = shape.startConnector();
                     * shape2.startConnector({name: shape1.name(), index: 2});
                     */
                    startConnector(connector?:  Object): Object | void;
                    /**
                     * Gets or sets the style of the connector shape.
                     * @param {GC.Spread.Sheets.Shapes.ShapeStyle} value The connector shape style.
                     * @return {GC.Spread.Sheets.Shapes.ShapeStyle | void} If no value is set, returns the current style of the connector shape.
                     *
                     * @example
                     * //This sample sets style for the connector shape.
                     * var shape = sheet.shapes.addConnector("Shape1", GC.Spread.Sheets.Shapes.ConnectorType.straight, 100, 60, 200, 160);
                     * var oldStyle = shape.style();
                     * oldStyle.line.color = "red";
                     * oldStyle.line.lineStyle = GC.Spread.Sheets.Shapes.PresetLineDashStyle.dashDot;
                     * oldStyle.line.width = 5;
                     * oldStyle.line.capType = GC.Spread.Sheets.Shapes.LineCapStyle.square;
                     * oldStyle.line.joinType = GC.Spread.Sheets.Shapes.LineJoinStyle.miter;
                     * oldStyle.line.transparency = 0.5;
                     * oldStyle.line.beginArrowheadStyle = GC.Spread.Sheets.Shapes.ArrowheadStyle.triangle;
                     * oldStyle.line.beginArrowheadWidth = GC.Spread.Sheets.Shapes.ArrowheadWidth.narrow;
                     * oldStyle.line.beginArrowheadLength = GC.Spread.Sheets.Shapes.ArrowheadLength.short;
                     * oldStyle.line.endArrowheadStyle = GC.Spread.Sheets.Shapes.ArrowheadStyle.diamond;
                     * oldStyle.line.endArrowheadWidth = GC.Spread.Sheets.Shapes.ArrowheadWidth.wide;
                     * oldStyle.line.endArrowheadLength = GC.Spread.Sheets.Shapes.ArrowheadLength.long;
                     * shape.style(oldStyle);
                     */
                    style(value?:  GC.Spread.Sheets.Shapes.ShapeStyle): GC.Spread.Sheets.Shapes.ShapeStyle | void;
                    /**
                     * Gets the connector type of the connectorShape.
                     * @returns {GC.Spread.Sheets.Shapes.ConnectorType} returns the connector type of the shape.
                     * @example
                     * var shape = sheet.shapes.addConnector("myShape", GC.Spread.Sheets.Shapes.ConnectorType.straight, 220, 120, 300, 120);
                     * var shapeName = shape.type();
                     */
                    type(): GC.Spread.Sheets.Shapes.ConnectorType;
                }

                export class GroupShape extends GC.Spread.Sheets.Shapes.ShapeBase{
                    /**
                     * Represents a groupShape.
                     * @class
                     * @param {GC.Spread.Sheets.Worksheet} worksheet The host sheet of the groupShape.
                     * @param {string} name The name of groupShape
                     */
                    constructor(worksheet:  GC.Spread.Sheets.Worksheet,  name:  string);
                    /**
                     * add a shape to groupShape.
                     * @param {GC.Spread.Sheets.Shapes.Shape} shape The shape which added to groupShape.
                     * @returns {void}
                     */
                    add(value?:  GC.Spread.Sheets.Shapes.Shape): GC.Spread.Sheets.Shapes.GroupShape;
                    /**
                     * get all shapes of group shape.
                     * @returns {Array.<GC.Spread.Sheets.Shapes.Shape>} all shapes
                     * @example
                     * // This sample shows how to get all shapes in group shape.
                     * var shape1 = sheet.shapes.add("myShape1", GC.Spread.Sheets.Shapes.AutoShapeType.rectangle, 62 * 9, 0, 200, 200);
                     * var shape2 = sheet.shapes.add("myShape2", GC.Spread.Sheets.Shapes.AutoShapeType.rectangle, 20, 20, 200, 200);
                     * var groupShape = sheet.shapes.group([shape1, shape2]);
                     * var shapes = groupShape.all();
                     */
                    all(): any;
                    /**
                     * Get shape of shapes in groupShape by name.
                     * @param name The name of shape in groupShape.
                     * @return {GC.Spread.Sheets.Shapes.Shape} The Shape instance if the name belongs to a shape of group shapes; otherwise, <c>null</c>.
                     */
                    find(name?:  string): GC.Spread.Sheets.Shapes.Shape;
                    /**
                     * remove a shape from groupShape.
                     * @param {GC.Spread.Sheets.Shapes.Shape} shape The shape which remove to groupShape.
                     * @returns {void}
                     */
                    remove(value?:  GC.Spread.Sheets.Shapes.Shape): GC.Spread.Sheets.Shapes.GroupShape;
                    /**
                     * Gets or sets the rotate of groupShape.
                     * @param {string} value The rotate of the groupShape.The unit of measurement is the angle.
                     * @return {number | void} If the parameter 'value' is null or undefined,it will return the rotate of the groupShape.
                     * @example
                     * var shape1 = sheet.shapes.add("myShape1", GC.Spread.Sheets.Shapes.AutoShapeType.rectangle, 62 * 9, 0, 200, 200);
                     * var shape2 = sheet.shapes.add("myShape2", GC.Spread.Sheets.Shapes.AutoShapeType.rectangle, 20, 20, 200, 200);
                     * var shape = sheet.shapes.group([shape1, shape2]);
                     * shape.rotate(60);
                     * var angle = shape.rotate();
                     */
                    rotate(value?:  number): number | void;
                    /**
                     *  Get or set the z-index for a shape in a groupShape.
                     * @param shapeName {string} The name of the shape.
                     * @param zIndex {number} The z-index for the shape. The zIndex should be between 0 to all shapes length(not contains). A shape with greater zIndex is always in front of a shape with a lower zIndex.
                     * @example
                     * //This is a sample shows how to use zIndex in groupShape.
                     * var shape1 = activeSheet.shapes.add("shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 50, 100, 150);
                     * var shape2 = activeSheet.shapes.add("shape2", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 150, 50, 100, 150);
                     * var style = shape1.style();
                     * style.fill.color = "red";
                     * shape1.style(style);
                     * var myGroup = activeSheet.shapes.group([shape1, shape2]);
                     * myGroup.zIndex("shape2"); // 1
                     * myGroup.zIndex("shape2", 0);
                     */
                    zIndex(shapeName:  string,  zIndex:  number): number;
                }

                export class Shape extends GC.Spread.Sheets.Shapes.ShapeBase{
                    /**
                     *
                     * @param {GC.Spread.Sheets.Worksheet} worksheet The host worksheet of the shape.
                     * @param {string} name The name of the shape. If leave blank an unique name will be generated.
                     * @param {GC.Spread.Sheets.Shapes.AutoShapeType | Object} autoShapeTypeOrModel The type of the shape (for one of the buildin types) or the model for custom shape.
                     * @param {number} left The <i>x</i> location of the shape.
                     * @param {number} top The <i>y</i> location of the shape.
                     * @param {number} width The width of the shape.
                     * @param {number} height The height of the shape.
                     */
                    constructor(worksheet:  GC.Spread.Sheets.Worksheet,  name:  string,  autoShapeTypeOrModel:  GC.Spread.Sheets.Shapes.AutoShapeType | GC.Spread.Sheets.Shapes.IShapeModel,  left?:  number,  top?:  number,  width?:  number,  height?:  number);
                    /**
                     * Gets or sets the adjustment values of the shape.
                     * @param {number[]} arrayValue The adjustment values in array.
                     * @return {number[] | void} if no value is set, returns the current adjustment values of the shape.
                     * @example
                     * var blockArc = sheet.shapes.add("", GC.Spread.Sheets.Shapes.AutoShapeType.blockArc, 100, 60, 200, 160);
                     * var adjustments = blockArc.adjustments();
                     * console.log(adjustments);
                     * adjustments[0] = 150;
                     * adjustments[1] = 15;
                     * adjustments[2] = 0.35;
                     * blockArc.adjustments(adjustments);
                     * blockArc.isSelected(true);
                     */
                    adjustments(arrayValue?:  number[]): number[] | void;
                    /**
                     * Gets or sets the rotated angle of the shape (unit in degree).
                     * @param {number | string} value The rotated angle of the shape (unit in degree) specified by a number or formula (starts with =) can get a number value.
                     * @returns {number | void} If no value is set, returns the rotated angle of the shape (unit in degree).
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.rotate();
                     * heart.rotate(n + 30);
                     */
                    rotate(value?:  number | string): number | void;
                    /**
                     * Gets or sets the style of the shape.
                     * @param {GC.Spread.Sheets.Shapes.ShapeStyle} value The shape style.
                     * @return {GC.Spread.Sheets.Shapes.ShapeStyle | void} If no value is set, returns the current style of the shape.
                     * @example
                     * //This sample sets style for the shape.
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var oldStyle = heart.style();
                     * oldStyle.fill.color = "red";
                     * oldStyle.fill.transparency = 0.5;
                     * oldStyle.line.color = "green";
                     * oldStyle.line.lineStyle = GC.Spread.Sheets.Shapes.PresetLineDashStyle.dashDot;
                     * oldStyle.line.width = 5;
                     * oldStyle.line.capType = GC.Spread.Sheets.Shapes.LineCapStyle.square;
                     * oldStyle.line.joinType = GC.Spread.Sheets.Shapes.LineJoinStyle.miter;
                     * oldStyle.line.transparency = 0.5;
                     * oldStyle.textEffect.color = "yellow";
                     * oldStyle.textEffect.transparency = 0.5;
                     * oldStyle.textEffect.font = "20px Arial";
                     * oldStyle.textFrame.vAlign = GC.Spread.Sheets.VerticalAlign.center;
                     * oldStyle.textFrame.hAlign = GC.Spread.Sheets.HorizontalAlign.center;
                     * heart.style(oldStyle);
                     * heart.text("Heart");
                     */
                    style(value?:  GC.Spread.Sheets.Shapes.ShapeStyle): GC.Spread.Sheets.Shapes.ShapeStyle | void;
                    /**
                     * Gets or sets the text of the shape.
                     * @param {string} value The text of the shape specified by a string or formula (starts with =) can get a string.
                     * @returns {string | void} If no value is set, returns the text of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * heart.text("My Shape");
                     * var s = heart.text();
                     */
                    text(value?:  string): string | void;
                    /**
                     * Gets or sets the type of the shape.
                     * @param {GC.Spread.Sheets.Shapes.AutoShapeType} value The type of the shape.
                     * @returns {GC.Spread.Sheets.Shapes.AutoShapeType | void} If no value is set, returns the type of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.type();
                     * heart.type(GC.Spread.Sheets.Shapes.AutoShapeType.cloud);
                     */
                    type(value?:  GC.Spread.Sheets.Shapes.AutoShapeType): GC.Spread.Sheets.Shapes.AutoShapeType | void;
                }

                export class ShapeBase{
                    /**
                     * Represents the base class for Shape, GroupShape and ConnectorShape.
                     * @class
                     */
                    constructor();
                    /**
                     * Gets or sets whether to disable moving the shape.
                     * @param {boolean} value The setting for whether to disable moving the shape.
                     * @returns {boolean | void} If no value is set, returns the setting for whether to disable moving the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var state = heart.allowMove();
                     * heart.allowMove(!state);
                     */
                    allowMove(value?:  boolean): boolean | void;
                    /**
                     * Gets or sets whether to disable resizing the shape.
                     * @param {boolean} value The setting for whether to disable resizing the shape.
                     * @returns {boolean | void} If no value is set, returns the setting for whether to disable resizing the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var state = heart.allowResize();
                     * heart.allowResize(!state);
                     */
                    allowResize(value?:  boolean): boolean | void;
                    /**
                     * Gets or sets whether this shape is printable.
                     * @param {boolean} value The value that indicates whether this shape is printable.
                     * @returns {boolean | void} If no value is set, returns whether this shape is printable.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var state = heart.canPrint();
                     * heart.canPrint(!state);
                     */
                    canPrint(value?:  boolean): boolean | void;
                    /**
                     * Gets or sets whether the shape moves when hiding or showing, resizing, or moving rows or columns.
                     * @param {boolean} value The value indicates whether the shape moves when hiding or showing, resizing, or moving rows or columns.
                     * @returns {boolean | void} If no value is set, returns whether this shape dynamically moves.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var state = heart.dynamicMove();
                     * heart.dynamicMove(!state);
                     */
                    dynamicMove(value?:  boolean): boolean | void;
                    /**
                     * Gets or sets whether the size of the shape changes when hiding or showing, resizing, or moving rows or columns.
                     * @param {boolean} value The value indicates whether the size of the shape changes when hiding or showing, resizing, or moving rows or columns.
                     * @returns {boolean | void} If no value is set, returns whether this shape dynamically changes size.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var state = heart.dynamicSize();
                     * heart.dynamicSize(!state);
                     */
                    dynamicSize(value?:  boolean): boolean | void;
                    /**
                     * Gets or sets the end column index of the shape position.
                     * @param {number} value The end column index of the shape position.
                     * @returns {number | void} If no value is set, returns the end column index of the shape position.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.endColumn();
                     * heart.endColumn(n + 1);
                     */
                    endColumn(value?:  number): number | void;
                    /**
                     * Gets or sets the offset relative to the end column of the shape.
                     * @param {number} value The offset relative to the end column of the shape.
                     * @returns {number | void} If no value is set, returns the offset relative to the end column of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.endColumnOffset();
                     * heart.endColumnOffset(0);
                     */
                    endColumnOffset(value?:  number): number | void;
                    /**
                     * Gets or sets the end row index of the shape position.
                     * @param {number} value The end row index of the shape position.
                     * @returns {number | void} If no value is set, returns the end row index of the shape position.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.endRow();
                     * heart.endRow(n + 2);
                     */
                    endRow(value?:  number): number | void;
                    /**
                     * Gets or sets the offset relative to the end row of the shape.
                     * @param {number} value The offset relative to the end row of the shape.
                     * @returns {number | void} If no value is set, returns the offset relative to the end row of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.endRowOffset();
                     * heart.endRowOffset(0);
                     */
                    endRowOffset(value?:  number): number | void;
                    /**
                     * Gets or sets the height of the shape.
                     * @param {number | string} value The height of the shape specified by a number or formula (starts with =) can get a number value.
                     * @returns {number | void} If no value is set, returns the height of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.height();
                     * heart.height(n + 50);
                     */
                    height(value?:  number | string): number | void;
                    /**
                     * Gets or sets whether this shape is locked.
                     * @param {boolean} value The value that indicates whether this shape is locked.
                     * @returns {boolean | void} If no value is set, returns whether this shape is locked.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var state = heart.isLocked();
                     * heart.isLocked(!state);
                     */
                    isLocked(value?:  boolean): boolean | void;
                    /**
                     * Gets or sets whether this shape is selected.
                     * @param {boolean} value The value that indicates whether this shape is selected.
                     * @returns {boolean | void} If no value is set, returns whether this shape is selected.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var state = heart.isSelected();
                     * heart.isSelected(!state);
                     */
                    isSelected(value?:  boolean): boolean | void;
                    /**
                     * Gets or sets whether this shape is visible.
                     * @param {boolean} value The value that indicates whether this shape is visible.
                     * @returns {boolean | void} If no value is set, returns whether this shape is visible.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var state = heart.isVisible();
                     * heart.isVisible(!state);
                     */
                    isVisible(value?:  boolean): boolean | void;
                    /**
                     * Gets or sets the name of the shape.
                     * @param {string} value The name of the shape.
                     * @returns {string | void} If no value is set, returns the name of the shape.
                     * @example
                     * var shape1 = sheet.shapes.add("myShape1", GC.Spread.Sheets.Shapes.AutoShapeType.rectangle, 62 * 9, 0, 200, 200);
                     * var shape2 = sheet.shapes.add("myShape2", GC.Spread.Sheets.Shapes.AutoShapeType.rectangle, 20, 20, 200, 200);
                     * var shape = sheet.shapes.group([shape1, shape2]);
                     * shape.name("myGroupShape");
                     * var shapeName = shape.name();
                     */
                    name(value?:  string): number | void;
                    /**
                     * Gets or sets the starting column index of the shape position.
                     * @param {number} value The starting column index of the shape position.
                     * @returns {number | void} If no value is set, returns the starting column index of the shape position.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.startColumn();
                     * heart.startColumn(n + 2);
                     */
                    startColumn(value?:  number): number | void;
                    /**
                     * Gets or sets the offset relative to the start column of the shape.
                     * @param {number} value The offset relative to the start column of the shape.
                     * @returns {number | void} If no value is set, returns the offset relative to the start column of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.startColumnOffset();
                     * heart.startColumnOffset(0);
                     */
                    startColumnOffset(value?:  number): number | void;
                    /**
                     * Gets or sets the starting row index of the shape position.
                     * @param {number} value The starting row index of the shape position.
                     * @returns {number | void} If no value is set, returns the starting row index of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.startRow();
                     * heart.startRow(n + 2);
                     */
                    startRow(value?:  number): number | void;
                    /**
                     * Gets or sets the offset relative to the start row of the shape.
                     * @param {number} value The offset relative to the start row of the shape.
                     * @returns {number | void} If no value is set, returns the offset relative to the start row of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.startRowOffset();
                     * heart.startRowOffset(0);
                     */
                    startRowOffset(value?:  number): number | void;
                    /**
                     * Gets or sets the width of the shape.
                     * @param {number | string} value The width of the shape specified by a number or formula (starts with =) can get a number value.
                     * @returns {number | void} If no value is set, returns the width of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.width();
                     * heart.width(n + 50);
                     */
                    width(value?:  number | string): number | void;
                    /**
                     * Gets or sets the horizontal location of the shape.
                     * @param {number | string} value The horizontal location of the shape specified by a number or formula (starts with =) can get a number value.
                     * @return {number | void} If no value is set, returns the horizontal location of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.x();
                     * heart.x(n + 50);
                     */
                    x(value?:  number | string): number | void;
                    /**
                     * Gets or sets the vertical location of the shape.
                     * @param {number | string} value The vertical location of the shape specified by a number or formula (starts with =) can get a number value.
                     * @return {number | void} If no value is set, returns the vertical location of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.y();
                     * heart.y(n + 50);
                     */
                    y(value?:  number | string): number | void;
                }

                export class ShapeCollection{
                    /**
                     * Represents a shape manager that managers all shapes in a sheet.
                     * @class
                     * @param {GC.Spread.Sheets.Worksheet} sheet The worksheet.
                     */
                    constructor();
                    /**
                     * Add a new shape to shape collection
                     * @param {string} name The name of the shape. If leave blank an unique name will be generated.
                     * @param {GC.Spread.Sheets.Shapes.AutoShapeType | Object} autoShapeTypeOrModel The type of the shape (for one of the buildin types) or the model for custom shape.
                     * @param {number} left The <i>x</i> location of the shape.
                     * @param {number} top The <i>y</i> location of the shape.
                     * @param {number} width The width of the shape.
                     * @param {number} height The height of the shape.
                     * @return {GC.Spread.Sheets.Shapes.Shape} The shape that has been added to the sheet.
                     * @example
                     * // This example shows how to add a new shape
                     * var shape = activeSheet.shapes.add("shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 50, 100, 150);
                     */
                    add(name:  string,  autoShapeTypeOrModel:  GC.Spread.Sheets.Shapes.AutoShapeType | GC.Spread.Sheets.Shapes.IShapeModel,  left?:  number,  top?:  number,  width?:  number,  height?:  number): GC.Spread.Sheets.Shapes.Shape;
                    /**
                     * Add a Connector Shape to shape collection
                     * @param {string} name The name of the shape. If leave blank an unique name will be generated.
                     * @param {GC.Spread.Sheets.Shapes.ConnectorType} connectorType The type of the connector.
                     * @param {number} beginX The <i>x</i> location of the start point for the connector shape.
                     * @param {number} beginY The <i>y</i> location of the start point for the connector shape.
                     * @param {number} endX  The <i>x</i> location of the end point for the connector shape.
                     * @param {number} endY The <i>y</i> location of the end point for the connector shape.
                     * @return {GC.Spread.Sheets.Shapes.ConnectorShape} The connector shape that has been added to the sheet.
                     * @example
                     * //This example shows how to add a connector shape
                     * var shape1 = activeSheet.shapes.addConnector("shape1", GC.Spread.Sheets.Shapes.ConnectorType.elbow, 200, 50, 300, 200);
                     */
                    addConnector(name:  string,  connectorType:  GC.Spread.Sheets.Shapes.ConnectorType,  beginX?:  number,  beginY?:  number,  endX?:  number,  endY?:  number): GC.Spread.Sheets.Shapes.ConnectorShape;
                    /**
                     * get all shapes
                     * @returns {Array.<GC.Spread.Sheets.Shapes.Shape>} all shapes
                     * @example
                     * // This sample shows how to get all shapes in shape collection
                     * activeSheet.shapes.add("shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 50, 100, 150);
                     * activeSheet.shapes.addConnector("shape2", GC.Spread.Sheets.Shapes.ConnectorType.elbow, 200, 50, 300, 200);
                     * var shapes = activeSheet.shapes.all();
                     */
                    all(): any;
                    /**
                     * clear all shapes
                     * @example
                     * //This example shows how to clear all shapes in shape collection
                     * activeSheet.shapes.add("shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 50, 100, 150);
                     * activeSheet.shapes.addConnector("shape2", GC.Spread.Sheets.Shapes.ConnectorType.elbow, 200, 50, 300, 200);
                     * activeSheet.shapes.clear();
                     */
                    clear(): void;
                    /**
                     * Get a shape with name
                     * @param {string} name The name of the shape.
                     * @returns {GC.Spread.Sheets.Shapes.Shape} The Shape
                     * @example
                     * //This example shows how to get a shape with name.
                     * activeSheet.shapes.add("shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 50, 100, 150);
                     * activeSheet.shapes.get("shape1");
                     */
                    get(name:  string): GC.Spread.Sheets.Shapes.Shape;
                    /**
                     * Groups the Shapes.
                     * @param {Array.<GC.Spread.Sheets.Shapes.Shape>} shapes The shapes to group.
                     * @returns {GC.Spread.Sheets.Shapes.Shape} The Shape group.
                     * @example
                     * //This sample shows how to group some shapes
                     * var shape1 = activeSheet.shapes.add("shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 50, 100, 150);
                     * var shape2 = activeSheet.shapes.addConnector("shape2", GC.Spread.Sheets.Shapes.ConnectorType.elbow, 200, 50, 300, 200);
                     * var shapes = [shape1, shape2];
                     * var groupShape = activeSheet.shapes.group(shapes)
                     */
                    group(shapes:  GC.Spread.Sheets.Shapes.Shape []): GC.Spread.Sheets.Shapes.GroupShape;
                    /**
                     * remove a shape
                     * @param {string} name The name of the shape.
                     * @example
                     * //This example shows how to remove a shape
                     * activeSheet.shapes.add("shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 50, 100, 150);
                     * activeSheet.shapes.remove("shape1");
                     */
                    remove(name:  string): void;
                    /**
                     * Separate a groupShape to some shapes
                     * @param {GC.Spread.Sheets.Shapes.GroupShape} groupShape The groupShape to separate.
                     * @example
                     * //This sample shows how to separate a groupShape to some shapes
                     * var shape1 = activeSheet.shapes.add("shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 50, 100, 150);
                     * var shape2 = activeSheet.shapes.addConnector("shape2", GC.Spread.Sheets.Shapes.ConnectorType.elbow, 200, 50, 300, 200);
                     * var shapes = [shape1, shape2];
                     * var groupShape = activeSheet.shapes.group(shapes);
                     * activeSheet.shapes.ungroup(groupShape);
                     */
                    ungroup(groupShape:  GC.Spread.Sheets.Shapes.GroupShape): void;
                    /**
                     *  Get or set the z-index for a shape
                     * @param shapeName {string} The name of the shape
                     * @param zIndex {number} The z-index for the shape. The zIndex should be between 0 to all shapes length(not contains). A shape with greater zIndex is always in front of a shape with a lower zIndex.
                     * @example
                     * //This is a sample shows how to use zIndex.
                     * var shape1 = activeSheet.shapes.add("shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 50, 100, 150);
                     * var style = shape1.style();
                     * style.fill.color = "red";
                     * shape1.style(style);
                     * var shape2 = activeSheet.shapes.addConnector("shape2", GC.Spread.Sheets.Shapes.ConnectorType.elbow, 100, 50, 200, 200);
                     * activeSheet.shapes.zIndex("shape2"); // 1
                     * activeSheet.shapes.zIndex("shape2", 0);
                     */
                    zIndex(shapeName:  string,  zIndex:  number): number;
                }

                export class ShapeStyle{
                    /**
                     * Represents a shape style.
                     * @param {Object} style The style is an object that has same structure with a ShapeStyle instance, it is optional.
                     * @class
                     */
                    constructor(style?:  Object);
                    /**
                     * Indicates the fill options.
                     * @property {string} [color] - The background color, it is a color string or formula(starts with =).
                     * @property {number | string} [transparency] - The background color transparency, it is a number that is between 0 and 1 or formula(starts with =).
                     * @type {Object}
                     * @example
                     * //This sample sets background color and background color transparency for the shape.
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var oldStyle = heart.style();
                     * oldStyle.fill.color = "red";
                     * oldStyle.fill.transparency = 0.5;
                     * heart.style(oldStyle);
                     *
                     * //This sample sets background color and background color transparency with formula for the shape.
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * sheet.setValue(0, 1, "red");
                     * sheet.setValue(1, 1, 0.5);
                     * var oldStyle = heart.style();
                     * oldStyle.fill.color = "=Sheet1!B1";
                     * oldStyle.fill.transparency = "=Sheet1!B2";
                     * heart.style(oldStyle);
                     */
                    fill: GC.Spread.Sheets.Shapes.IShapeFill;
                    /**
                     * Indicates the line options.
                     * @property {string} [color] - The line color, it is a color string or formula(starts with =).
                     * @property {GC.Spread.Sheets.Shapes.PresetLineDashStyle | string} [lineStyle] - The line style, it is PresetLineDashStyle enum or formula(starts with =).
                     * @property {number | string} [width] - The line width, it is a number or formula(starts with =).
                     * @property {GC.Spread.Sheets.Shapes.LineCapStyle | string} [capType] - The line cap type, it is LineCapStyle enum or formula(starts with =).
                     * @property {GC.Spread.Sheets.Shapes.LineJoinStyle | string} [joinType] - The line join type, it is LineJoinStyle enum or formula(starts with =).
                     * @property {number | string} [transparency] - The line color transparency, it is a number that is between 0 and 1 or formula(starts with =).
                     * @property {GC.Spread.Sheets.Shapes.ArrowheadStyle} [beginArrowheadStyle] - The begin arrowhead style, it is ArrowheadStyle enum.
                     * @property {GC.Spread.Sheets.Shapes.ArrowheadWidth} [beginArrowheadWidth] - The begin arrowhead width, it is ArrowheadWidth enum.
                     * @property {GC.Spread.Sheets.Shapes.ArrowheadLength} [beginArrowheadLength] - The begin arrowhead length, it is ArrowheadLength enum.
                     * @property {GC.Spread.Sheets.Shapes.ArrowheadStyle} [endArrowheadStyle] - The end arrowhead style, it is ArrowheadStyle enum.
                     * @property {GC.Spread.Sheets.Shapes.ArrowheadWidth} [endArrowheadWidth] - The end arrowhead width, it is ArrowheadWidth enum.
                     * @property {GC.Spread.Sheets.Shapes.ArrowheadLength} [endArrowheadLength] - The end arrowhead length, it is ArrowheadLength enum.
                     * @type {Object}
                     * @example
                     * //This sample sets line color, line style, line width, cap type, join type and line color transparency for the shape.
                     * var shape = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * //var shape = sheet.shapes.addConnector("Shape1", GC.Spread.Sheets.Shapes.ConnectorType.straight, 100, 60, 200, 160);
                     * var oldStyle = shape.style();
                     * oldStyle.line.color = "red";
                     * oldStyle.line.lineStyle = GC.Spread.Sheets.Shapes.PresetLineDashStyle.dashDot;
                     * oldStyle.line.width = 5;
                     * oldStyle.line.capType = GC.Spread.Sheets.Shapes.LineCapStyle.square;
                     * oldStyle.line.joinType = GC.Spread.Sheets.Shapes.LineJoinStyle.miter;
                     * oldStyle.line.transparency = 0.5;
                     * shape.style(oldStyle);
                     *
                     * //This sample sets line color, line style, line width, cap type, join type and line color transparency with formula for the shape.
                     * var shape = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * //var shape = sheet.shapes.addConnector("Shape1", GC.Spread.Sheets.Shapes.ConnectorType.straight, 100, 60, 200, 160);
                     * sheet.setValue(0, 1, "red");
                     * sheet.setValue(1, 1, 4);
                     * sheet.setValue(2, 1, 5);
                     * sheet.setValue(3, 1, 1);
                     * sheet.setValue(4, 1, 1);
                     * sheet.setValue(5, 1, 0.5);
                     * var oldStyle = shape.style();
                     * oldStyle.line.color = "=Sheet1!B1";
                     * oldStyle.line.lineStyle = "=Sheet1!B2";
                     * oldStyle.line.width = "=Sheet1!B3";
                     * oldStyle.line.capType = "=Sheet1!B4";
                     * oldStyle.line.joinType = "=Sheet1!B5";
                     * oldStyle.line.transparency = "=Sheet1!B6";
                     * shape.style(oldStyle);
                     *
                     * //This sample sets line's begin arrowhead style, width, length and end arrowhead style, width, height for the shape.
                     * var shape = sheet.shapes.addConnector("Shape1", GC.Spread.Sheets.Shapes.ConnectorType.straight, 100, 60, 200, 160);
                     * var oldStyle = shape.style();
                     * oldStyle.line.beginArrowheadStyle = GC.Spread.Sheets.Shapes.ArrowheadStyle.triangle;
                     * oldStyle.line.beginArrowheadWidth = GC.Spread.Sheets.Shapes.ArrowheadWidth.narrow;
                     * oldStyle.line.beginArrowheadLength = GC.Spread.Sheets.Shapes.ArrowheadLength.short;
                     * oldStyle.line.endArrowheadStyle = GC.Spread.Sheets.Shapes.ArrowheadStyle.diamond;
                     * oldStyle.line.endArrowheadWidth = GC.Spread.Sheets.Shapes.ArrowheadWidth.wide;
                     * oldStyle.line.endArrowheadLength = GC.Spread.Sheets.Shapes.ArrowheadLength.long;
                     * shape.style(oldStyle);
                     */
                    line: GC.Spread.Sheets.Shapes.IShapeLine;
                    /**
                     * Indicates the text effect options.
                     * @property {string} [color] - The font color, it is a color string or formula(starts with =).
                     * @property {number | string} [transparency] - The font color transparency, it is a number that is between 0 and 1 or formula(starts with =).
                     * @property {string} [font] - The font, it is a font string or formula(starts with =).
                     * @type {Object}
                     * @example
                     * //This sample sets the font color, font color transparency and font for the shape.
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var oldStyle = heart.style();
                     * oldStyle.textEffect.color = "red";
                     * oldStyle.textEffect.transparency = 0.5;
                     * oldStyle.textEffect.font = "20px Arial";
                     * heart.style(oldStyle);
                     * heart.text("Heart");
                     *
                     * //This sample sets the font color, font color transparency and font with formula for the shape.
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * sheet.setValue(0, 1, "red");
                     * sheet.setValue(1, 1, 0.5);
                     * sheet.setValue(2, 1, "20px Arial");
                     * var oldStyle = heart.style();
                     * oldStyle.textEffect.color = "=Sheet1!B1";
                     * oldStyle.textEffect.transparency = "=Sheet1!B2";
                     * oldStyle.textEffect.font = "=Sheet1!B3";
                     * heart.style(oldStyle);
                     * heart.text("Heart");
                     */
                    textEffect: GC.Spread.Sheets.Shapes.IShapeTextEffect;
                    /**
                     * Indicates the text frame options.
                     * @property {GC.Spread.Sheets.VerticalAlign | string} [vAlign] - The text vertical alignment, it is VerticalAlign enum or formula(starts with =).
                     * @property {GC.Spread.Sheets.HorizontalAlign | string} [hAlign] - The text horizontal alignment, it is HorizontalAlign enum or formula(starts with =).
                     * @type {Object}
                     * @example
                     * //This sample sets the text horizontal alignment and vertical alignment for the shape.
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var oldStyle = heart.style();
                     * oldStyle.textFrame.vAlign = GC.Spread.Sheets.VerticalAlign.center;
                     * oldStyle.textFrame.hAlign = GC.Spread.Sheets.HorizontalAlign.center;
                     * heart.style(oldStyle);
                     * heart.text("Heart");
                     *
                     * //This sample sets the text horizontal alignment and vertical alignment with formula for the shape.
                     * var heart = sheet.shapes.add("Shape1", GC.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * sheet.setValue(0, 1, 1);
                     * sheet.setValue(1, 1, 1);
                     * var oldStyle = heart.style();
                     * oldStyle.textFrame.vAlign = "=Sheet1!B1";
                     * oldStyle.textFrame.hAlign = "=Sheet1!B2";
                     * heart.style(oldStyle);
                     * heart.text("Heart");
                     */
                    textFrame: GC.Spread.Sheets.Shapes.IShapeTextFrame;
                }
            }

            module Slicers{

                export class ItemSlicer{
                    /**
                     * Represents an item slicer.
                     * @param {string} name The name of the item slicer.
                     * @param {GC.Spread.Slicers.GeneralSlicerData} slicerData An instance of the GeneralSlicerData or TableSlicerData.
                     * @param {string} columnName The column name that relates to the item slicer.
                     * @class GC.Spread.Sheets.Slicers.ItemSlicer
                     * @example
                     * //This example creates an item slicer.
                     * //create table
                     * var dataSource = [
                     *     { Name: "Bob", City: "NewYork", Birthday: "1968/6/8" },
                     *     { Name: "Betty", City: "NewYork", Birthday: "1972/7/3" },
                     *     { Name: "Alice", City: "Washington", Birthday: "2012/2/15" },
                     * ];
                     * var table = activeSheet.tables.addFromDataSource("table1", 1, 1, dataSource);
                     * var slicerData = new GC.Spread.Sheets.Slicers.TableSlicerData(table)
                     * //Set slicer data to item slicer.
                     * var slicer = new GC.Spread.Sheets.Slicers.ItemSlicer("slicer", slicerData, "Name");
                     * //Add the item slicer to the dom tree.
                     * //The "slicerHost" is the div you want to add the slicer's dom to.
                     * $("#slicerHost").append(slicer.getDOMElement());
                     */
                    constructor(name:  string,  slicerData:  GC.Spread.Slicers.GeneralSlicerData,  columnName:  string);
                    /**
                     * Gets or sets the caption name of the item slicer.
                     * @param {string} value The caption name of the item slicer.
                     * @returns {string | GC.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns the caption name of the item slicer; otherwise, returns the item slicer.
                     */
                    captionName(value?:  string): any;
                    /**
                     * Gets or sets the column count of the item slicer.
                     * @param {number} value The column count of the item slicer.
                     * @returns {number | GC.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns the column count of the item slicer; otherwise, returns the item slicer.
                     */
                    columnCount(value?:  number): any;
                    /**
                     * Gets the dom element of the item slicer.
                     * @returns {HTMLElement} The dom element of the item slicer.
                     */
                    getDOMElement(): HTMLElement;
                    /**
                     * Gets or sets the height of the item slicer.
                     * @param {number} value The height of the item slicer.
                     * @returns {number | GC.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns the height of the item slicer; otherwise, returns the item slicer.
                     */
                    height(value?:  number): any;
                    /**
                     * Gets or sets the item height of the item slicer.
                     * @param {number} value The item height of the item slicer.
                     * @returns {number | GC.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns the item height of the item slicer; otherwise, returns the item slicer.
                     */
                    itemHeight(value?:  number): any;
                    /**
                     * Gets or sets the name of the item slicer.
                     * @param {string} value The name of the item slicer.
                     * @returns {string | GC.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns the name of the item slicer; otherwise, returns the item slicer.
                     */
                    name(value?:  string): any;
                    /**
                     * Gets or sets whether to show the header of the item slicer.
                     * @param {boolean} value The show header setting of the item slicer.
                     * @returns {boolean | GC.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns whether to show the header of the item slicer; otherwise, returns the item slicer.
                     */
                    showHeader(value?:  boolean): any;
                    /**
                     * Gets or sets whether to show the no data items of the item slicer.
                     * @param {boolean} value The show no data items setting of the slicer.
                     * @returns {boolean | GC.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns whether to show the no data items of the item slicer; otherwise, returns the item slicer.
                     */
                    showNoDataItems(value?:  boolean): any;
                    /**
                     * Gets or sets whether to show the no data items last.
                     * @param {boolean} value The show no data items in last setting of the slicer.
                     * @returns {boolean | GC.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns whether to show the no data items last; otherwise, returns the item slicer.
                     */
                    showNoDataItemsInLast(value?:  boolean): any;
                    /**
                     * Gets or sets the sort state of the item slicer.
                     * @param {GC.Spread.Sheets.SortState} value The sort state of the item slicer.
                     * @returns {GC.Spread.Sheets.SortState | GC.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns the sort state of the item slicer; otherwise, returns the item slicer.
                     */
                    sortState(value?:  GC.Spread.Sheets.SortState): any;
                    /**
                     * Gets or sets the style of the item slicer.
                     * @param {any} value The style of the item slicer.
                     * @returns {any | GC.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns The style of the item slicer; otherwise, returns the item slicer.
                     * @example
                     * The style is json data, its json schema is as follows:
                     * {
                     *      "$schema" : "http://json-schema.org/draft-04/schema#",
                     *      "title" : "style",
                     *      "type" : "object",
                     *      "properties" : {
                     *          "wholeSlicerStyle" : {
                     *              "$ref" : "#/definitions/StyleInfo"
                     *          },
                     *          "headerStyle" : {
                     *              "$ref" : "#/definitions/StyleInfo"
                     *          },
                     *          "selectedItemWithDataStyle" : {
                     *              "$ref" : "#/definitions/StyleInfo"
                     *          },
                     *          "selectedItemWithNoDataStyle" : {
                     *              "$ref" : "#/definitions/StyleInfo"
                     *          },
                     *          "unSelectedItemWithDataStyle" : {
                     *              "$ref" : "#/definitions/StyleInfo"
                     *          },
                     *          "unSelectedItemWithNoDataStyle" : {
                     *              "$ref" : "#/definitions/StyleInfo"
                     *          },
                     *          "hoveredSelectedItemWithDataStyle" : {
                     *              "$ref" : "#/definitions/StyleInfo"
                     *          },
                     *          "hoveredSelectedItemWithNoDataStyle" : {
                     *              "$ref" : "#/definitions/StyleInfo"
                     *          },
                     *          "hoveredUnSelectedItemWithDataStyle" : {
                     *              "$ref" : "#/definitions/StyleInfo"
                     *          },
                     *          "hoveredUnSelectedItemWithNoDataStyle" : {
                     *              "$ref" : "#/definitions/StyleInfo"
                     *          }
                     *      },
                     *      "definitions" : {
                     *          "StyleInfo" : {
                     *              "type" : "object",
                     *              "properties" : {
                     *                      "backColor" : {
                     *                              "type" : "string"
                     *                      },
                     *                      "foreColor" : {
                     *                              "type" : "string"
                     *                      },
                     *                      "font" : {
                     *                              "type" : "string"
                     *                      },
                     *                      "borderLeft" : {
                     *                              "$ref" : "#/definitions/SlicerBorder"
                     *                      },
                     *                      "borderTop" : {
                     *                              "$ref" : "#/definitions/SlicerBorder"
                     *                      },
                     *                      "borderRight" : {
                     *                              "$ref" : "#/definitions/SlicerBorder"
                     *                      },
                     *                      "borderBottom" : {
                     *                              "$ref" : "#/definitions/SlicerBorder"
                     *                      },
                     *                  "textDecoration":{
                     *                      "type" : "string"
                     *                  }
                     *              }
                     *          },
                     *          "SlicerBorder":{
                     *              "type":"object",
                     *              "properties":{
                     *                  "borderWidth":{
                     *                          "type":"number"
                     *                  },
                     *                  "borderStyle":{
                     *                          "type":"string"
                     *                  },
                     *                  "borderColor":{
                     *                          "type":"string"
                     *                  }
                     *           }
                     *          }
                     *      }
                     *  }
                     */
                    style(value?:  any): any;
                    /**
                     * Gets or sets whether to visually distinguish the items with no data.
                     * @param {boolean} value The setting for items with no data.
                     * @returns {boolean | GC.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns whether to visually distinguish the items with no data; otherwise, returns the item slicer.
                     */
                    visuallyNoDataItems(value?:  boolean): any;
                    /**
                     * Gets or sets the width of the item slicer.
                     * @param {number} value The width of the item slicer.
                     * @returns {number | GC.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns the width of the item slicer; otherwise, returns the item slicer.
                     */
                    width(value?:  number): any;
                }

                export class Slicer extends GC.Spread.Sheets.FloatingObjects.FloatingObject{
                    /**
                     * Represents a slicer.
                     * @class GC.Spread.Sheets.Slicer
                     * @param {string} name The slicer name.
                     * @param {GC.Spread.Sheets.Tables.Table} table The table that relates to the slicer.
                     * @param {string} columnName The name of the table's column.
                     */
                    constructor(name:  string,  table:  GC.Spread.Sheets.Tables.Table,  columnName:  string);
                    /**
                     * Gets or sets the caption name of the slicer.
                     * @param {string} value The caption name of the slicer.
                     * @returns {string | GC.Spread.Sheets.Slicers.Slicer} If no value is set, returns the caption name of the slicer; otherwise, returns the slicer.
                     * @example
                     * //This example uses the captionName method.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //slicer style
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.light4();
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.captionName("S1");
                     * slicer.style(style1);
                     */
                    captionName(value?:  string): any;
                    /**
                     * Gets or sets the column count for the slicer.
                     * @param {number} value The column count of the slicer.
                     * @returns {number | GC.Spread.Sheets.Slicers.Slicer} If no value is set, returns the column count for the slicer; otherwise, returns the slicer.
                     */
                    columnCount(value?:  number): any;
                    /**
                     * Gets or sets whether to disable resizing and moving the slicer.
                     * @param {boolean} value The setting for whether to disable resizing and moving the slicer.
                     * @returns {boolean | GC.Spread.Sheets.Slicers.Slicer} If no value is set, returns whether to disable resizing and moving the slicer; otherwise, returns the slicer.
                     * @example
                     * //This example prevents moving or resizing the slicer.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //slicer style
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.light4();
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Height");
                     * //change the slicer properties.
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.disableResizingAndMoving(true);
                     * slicer.style(style1);
                     */
                    disableResizingAndMoving(value?:  boolean): any;
                    /**
                     * Gets or sets the item height for the slicer.
                     * @param {number} value The item height of the slicer.
                     * @returns {number | GC.Spread.Sheets.Slicers.Slicer} If no value is set, returns the item height for the slicer; otherwise, returns the slicer.
                     */
                    itemHeight(value?:  number): any;
                    /**
                     * Gets or sets the name of the slicer.
                     * @param {string} value The name of the slicer.
                     * @returns {string | GC.Spread.Sheets.Slicers.Slicer} If no value is set, returns the name of the slicer; otherwise, returns the slicer.
                     */
                    name(value?:  string): any;
                    /**
                     * Gets or sets whether to show the slicer header.
                     * @param {boolean} value The show header setting of the slicer.
                     * @returns {boolean | GC.Spread.Sheets.Slicers.Slicer} If no value is set, returns whether to show the slicer header; otherwise, returns the slicer.
                     * @example
                     * //This example hides the slicer header.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //slicer style
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.light4();
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Height");
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.showHeader(false);
                     * slicer.style(style1);
                     * //add the slicer to the sheet
                     * activeSheet.slicers.add(slicer);
                     */
                    showHeader(value?:  boolean): any;
                    /**
                     * Gets or sets whether to show the no data items of the slicer.
                     * @param {boolean} value The show no data items setting of the slicer.
                     * @returns {boolean | GC.Spread.Sheets.Slicers.Slicer} If no value is set, returns whether to show the no data items of the slicer; otherwise, returns the slicer.
                     */
                    showNoDataItems(value?:  boolean): any;
                    /**
                     * Gets or sets whether to show the no data items last.
                     * @param {boolean} value The show no data items last setting of the slicer.
                     * @returns {boolean | GC.Spread.Sheets.Slicers.Slicer} If no value is set, returns whether to show the no data items last; otherwise, returns the slicer.
                     */
                    showNoDataItemsInLast(value?:  boolean): any;
                    /**
                     * Gets or sets the sort state of the slicer.
                     * @param {GC.Spread.Sheets.SortState} value The sort state of the slicer.
                     * @returns {GC.Spread.Sheets.SortState | GC.Spread.Sheets.Slicers.Slicer} If no value is set, returns the sort state of the slicer; otherwise, returns the slicer.
                     * @example
                     * //This example sets the sort order of the items in the slicer.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * // slicer style
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.light4();
                     * //add a slicer to the sheet and return the slicer instance
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Height");
                     * //set slicer properties
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.sortState(GC.Spread.Sheets.SortState.descending);
                     * slicer.style(style1);
                     */
                    sortState(value?:  GC.Spread.Sheets.SortState): any;
                    /**
                     * Gets or sets the style of the slicer.
                     * @param {GC.Spread.Sheets.Slicers.SlicerStyle} value The style of the slicer.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyle | GC.Spread.Sheets.Slicers.Slicer} If no value is set, returns The style of the slicer; otherwise, returns the slicer.
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * // slicer style
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.light4();
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     * //change the slicer properties.
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    style(value?:  GC.Spread.Sheets.Slicers.SlicerStyle): any;
                    /**
                     * Gets or sets whether to visually distinguish the items with no data.
                     * @param {boolean} value The setting for items with no data.
                     * @returns {boolean | GC.Spread.Sheets.Slicers.Slicer} If no value is set, returns whether to visually distinguish the items with no data; otherwise, returns the slicer.
                     */
                    visuallyNoDataItems(value?:  boolean): any;
                }

                export class SlicerBorder{
                    /**
                     * Represents the slicer border.
                     * @param {number} borderWidth The border width.
                     * @param {string} borderStyle The border style.
                     * @param {string} borderColor The border color.
                     * @class
                     * @example
                     * //This example sets a border style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //style info
                     * var hstyle = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    constructor(borderWidth:  number,  borderStyle:  string,  borderColor:  string);
                    /**
                     * Gets or sets the border color.
                     * @param {string} value The border color.
                     * @returns {string | GC.Spread.Sheets.Slicers.SlicerBorder}  If no value is set, returns the border color; otherwise, returns the slicer border.
                     */
                    borderColor(value?:  string): any;
                    /**
                     * Gets or sets the border style.
                     * @param {string} value The border style.
                     * @returns {string | GC.Spread.Sheets.Slicers.SlicerBorder}  If no value is set, returns the border style; otherwise, returns the slicer border.
                     */
                    borderStyle(value?:  string): any;
                    /**
                     * Gets or sets the border width.
                     * @param {number} value The border width.
                     * @returns {number | GC.Spread.Sheets.Slicers.SlicerBorder}  If no value is set, returns the border width; otherwise, returns the slicer border.
                     */
                    borderWidth(value?:  number): any;
                }

                export class SlicerCollection{
                    /**
                     * Represents a slicer manager that managers all slicers in a sheet.
                     * @class
                     * @param {GC.Spread.Sheets.Worksheet} sheet The worksheet.
                     */
                    constructor(sheet:  GC.Spread.Sheets.Worksheet);
                    /**
                     * Adds a slicer to the sheet.
                     * @param {string} name The name of the slicer.
                     * @param {string} tableName The name of the table that relates to the slicer.
                     * @param {string} columnName The name of the table column that relates to the slicer.
                     * @param {GC.Spread.Sheets.Slicers.SlicerStyle} style The style of the slicer.
                     * @return {GC.Spread.Sheets.Slicers.Slicer} The slicer that has been added to the sheet.
                     * @example
                     * //This example uses the add method.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     */
                    add(name:  string,  tableName:  string,  columnName:  string,  style:  GC.Spread.Sheets.Slicers.SlicerStyle): GC.Spread.Sheets.Slicers.Slicer;
                    /**
                     * Gets all of the slicers in the sheet with the indicated table name and column name.
                     * @param tableName {string} The name of the table.
                     * @param columnName {string} The name of the column.
                     * @returns {Array} The slicer collection.
                     */
                    all(tableName:  string,  columnName:  string): GC.Spread.Sheets.Slicers.Slicer[];
                    /**
                     * Removes all of the slicers from the sheet.
                     */
                    clear(): any;
                    /**
                     * Gets a slicer in the sheet by the name.
                     * @param {string} name The name of the slicer.
                     * @returns {GC.Spread.Sheets.Slicers.Slicer} The slicer that has the indicated name.
                     */
                    get(name:  string): GC.Spread.Sheets.Slicers.Slicer;
                    /**
                     * Removes a slicer from the sheet using the indicated slicer name.
                     * @param {string} name The name of the slicer.
                     */
                    remove(name:  string): void;
                }

                export class SlicerStyle{
                    /**
                     * Represents the slicer style settings.
                     * @class
                     */
                    constructor();
                    /**
                     * Gets or sets the style of the slicer header.
                     * @param {GC.Spread.Sheets.Slicers.SlicerStyleInfo} value The style of the slicer header.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyleInfo | GC.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the style of the slicer header; otherwise, returns the slicer style.
                     * @example
                     * //This example sets the header backcolor.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //slicer info
                     * var hstyle = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.headerStyle(hstyle);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    headerStyle(value?:  GC.Spread.Sheets.Slicers.SlicerStyleInfo): any;
                    /**
                     * Gets or sets the style of the hovered selected item with data.
                     * @param {GC.Spread.Sheets.Slicers.SlicerStyleInfo} value The style of the hovered selected item with data.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyleInfo | GC.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the style of the hovered selected item with data; otherwise, returns the slicer style.
                     * @example
                     * //This example sets the hoveredSelectedItemWithDataStyle method.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * // slicer info
                     * var hstyle = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    hoveredSelectedItemWithDataStyle(value?:  GC.Spread.Sheets.Slicers.SlicerStyleInfo): any;
                    /**
                     * Gets or sets the style of the hovered selected item with no data.
                     * @param {GC.Spread.Sheets.Slicers.SlicerStyleInfo} value The style of the hovered selected item with no data.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyleInfo | GC.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the style of the hovered selected item with no data; otherwise, returns the slicer style.
                     * @example
                     * //This example uses the hoveredSelectedItemWithNoDataStyle method.
                     * var datasource = [
                     *     { Name: "Apple", Category: "Fruit" },
                     *     { Name: "Orange", Category: "Fruit" },
                     *     { Name: "Broccoli", Category: "Vegetable" },
                     *     { Name: "Kiwi", Category: "Fruit" },
                     *     { Name: "Rice", Category: "Cereal" },
                     *     { Name: "Strawberry", Category: "Fruit" },
                     *     { Name: "Yogurt", Category: "Dairy" },
                     *     { Name: "Plum", Category: "Fruit" },
                     *     { Name: "Celery", Category: "Vegetable" },
                     *     { Name: "Grape", Category: "Fruit" },
                     *     { Name: "Oats", Category: "Cereal" },
                     *     { Name: "Quinoa", Category: "Cereal" },
                     *     { Name: "Maize", Category: "Cereal" },
                     *     { Name: "Okra", Category: "Vegetable" },
                     *     { Name: "Corn", Category: "Vegetable" },
                     *     { Name: "Wheat", Category: "Cereal" },
                     *     { Name: "Barley", Category: "Cereal" },
                     *     { Name: "Cream", Category: "Dairy" },
                     *     { Name: "Millet", Category: "Cereal" },
                     *     { Name: "Rye", Category: "Cereal" },
                     *     { Name: "Artichoke", Category: "Vegetable" },
                     *     { Name: "Buckwheat", Category: "Cereal" },
                     *     { Name: "Gooseberry", Category: "Fruit" },
                     *     { Name: "Amaranth", Category: "Cereal" },
                     *     { Name: "Carrot", Category: "Vegetable" },
                     *     { Name: "Cheese", Category: "Dairy" },
                     *     { Name: "Fig", Category: "Fruit" },
                     *     { Name: "Milk", Category: "Dairy" },
                     *     { Name: "Butter", Category: "Dairy" },
                     *                ];
                     * //add table
                     * var table = activeSheet.tables.addFromDataSource("table1", 1, 1, datasource);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Category");
                     *  //change the slicer properties.
                     * slicer.width(200);
                     * slicer.height(200);
                     * slicer.position(new GC.Spread.Sheets.Point(300, 50));
                     * var slicer2 = activeSheet.slicers.add("slicer2", table.name(), "Name");
                     * var hstyle = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var hstyle1 = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GC.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * hstyle1.backColor("yellow");
                     * var hstyle2 = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2.backColor("green");
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.hoveredUnSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * style1.selectedItemWithDataStyle(hstyle2);
                     * slicer.style(style1);
                     * // slicer style
                     * var hstyle2nd = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2nd.backColor("red");
                     * hstyle2nd.borderBottom(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "double", "orange"));
                     * var hstyle12nd = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle12nd.borderTop(new GC.Spread.Sheets.Slicers.SlicerBorder(2, "double", "blue"));
                     * hstyle12nd.backColor("yellow");
                     * var hstyle22nd = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle22nd.backColor("magenta");
                     * var style1two = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1two.hoveredSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.hoveredUnSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.unSelectedItemWithNoDataStyle(hstyle12nd);
                     * style1two.selectedItemWithNoDataStyle(hstyle22nd);
                     * slicer2.style(style1two);
                     * activeSheet.getColumn(1).width(100);
                     * activeSheet.getColumn(2).width(100);
                     * activeSheet.getColumn(3).width(100);
                     */
                    hoveredSelectedItemWithNoDataStyle(value?:  GC.Spread.Sheets.Slicers.SlicerStyleInfo): any;
                    /**
                     * Gets or sets the style of the hovered unselected item with data.
                     * @param {GC.Spread.Sheets.Slicers.SlicerStyleInfo} value The style of the hovered unselected item with data.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyleInfo | GC.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the style of the hovered unselected item with data; otherwise, returns the slicer style.
                     * @example
                     * //This example uses the hoveredUnSelectedItemWithDataStyle method.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * // slicer style
                     * var hstyle = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredUnSelectedItemWithDataStyle(hstyle);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    hoveredUnSelectedItemWithDataStyle(value?:  GC.Spread.Sheets.Slicers.SlicerStyleInfo): any;
                    /**
                     * Gets or sets the style of the hovered unselected item with no data.
                     * @param {GC.Spread.Sheets.Slicers.SlicerStyleInfo} value The style of the hovered unselected item with no data.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyleInfo | GC.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the style of the hovered unselected item with no data; otherwise, returns the slicer style.
                     * @example
                     * //This example uses the hoveredUnSelectedItemWithNoDataStyle method.
                     * var datasource = [
                     *     { Name: "Apple", Category: "Fruit" },
                     *     { Name: "Orange", Category: "Fruit" },
                     *     { Name: "Broccoli", Category: "Vegetable" },
                     *     { Name: "Kiwi", Category: "Fruit" },
                     *     { Name: "Rice", Category: "Cereal" },
                     *     { Name: "Strawberry", Category: "Fruit" },
                     *     { Name: "Yogurt", Category: "Dairy" },
                     *     { Name: "Plum", Category: "Fruit" },
                     *     { Name: "Celery", Category: "Vegetable" },
                     *     { Name: "Grape", Category: "Fruit" },
                     *     { Name: "Oats", Category: "Cereal" },
                     *     { Name: "Quinoa", Category: "Cereal" },
                     *     { Name: "Maize", Category: "Cereal" },
                     *     { Name: "Okra", Category: "Vegetable" },
                     *     { Name: "Corn", Category: "Vegetable" },
                     *     { Name: "Wheat", Category: "Cereal" },
                     *     { Name: "Barley", Category: "Cereal" },
                     *     { Name: "Cream", Category: "Dairy" },
                     *     { Name: "Millet", Category: "Cereal" },
                     *     { Name: "Rye", Category: "Cereal" },
                     *     { Name: "Artichoke", Category: "Vegetable" },
                     *     { Name: "Buckwheat", Category: "Cereal" },
                     *     { Name: "Gooseberry", Category: "Fruit" },
                     *     { Name: "Amaranth", Category: "Cereal" },
                     *     { Name: "Carrot", Category: "Vegetable" },
                     *     { Name: "Cheese", Category: "Dairy" },
                     *     { Name: "Fig", Category: "Fruit" },
                     *     { Name: "Milk", Category: "Dairy" },
                     *     { Name: "Butter", Category: "Dairy" },
                     *               ];
                     * var table = activeSheet.tables.addFromDataSource("table1", 1, 1, datasource);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Category");
                     *  //change the slicer properties.
                     * slicer.width(200);
                     * slicer.height(200);
                     * slicer.position(new GC.Spread.Sheets.Point(300, 50));
                     * var slicer2 = activeSheet.slicers.add("slicer2", table.name(), "Name");
                     * var hstyle = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var hstyle1 = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GC.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * hstyle1.backColor("yellow");
                     * var hstyle2 = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2.backColor("green");
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.hoveredUnSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * style1.selectedItemWithDataStyle(hstyle2);
                     * slicer.style(style1);
                     * var hstyle2nd = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2nd.backColor("red");
                     * hstyle2nd.borderBottom(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "double", "orange"));
                     * var hstyle12nd = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle12nd.borderTop(new GC.Spread.Sheets.Slicers.SlicerBorder(2, "double", "blue"));
                     * hstyle12nd.backColor("yellow");
                     * var hstyle22nd = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle22nd.backColor("magenta");
                     * var style1two = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1two.hoveredSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.hoveredUnSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.unSelectedItemWithNoDataStyle(hstyle12nd);
                     * style1two.selectedItemWithNoDataStyle(hstyle22nd);
                     * slicer2.style(style1two);
                     * activeSheet.getColumn(1).width(100);
                     * activeSheet.getColumn(2).width(100);
                     * activeSheet.getColumn(3).width(100);
                     */
                    hoveredUnSelectedItemWithNoDataStyle(value?:  GC.Spread.Sheets.Slicers.SlicerStyleInfo): any;
                    /**
                     * Gets or sets the name of the style.
                     * @param {string} value The slicer style name.
                     * @returns {string | GC.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the name of the style; otherwise, returns the slicer style.
                     */
                    name(value?:  string): any;
                    /**
                     * Gets or sets the style of the selected item with data.
                     * @param {GC.Spread.Sheets.Slicers.SlicerStyleInfo} value The style of the selected item with data.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyleInfo | GC.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the style of the selected item with data; otherwise, returns the slicer style.
                     * @example
                     * //This example uses the hoveredUnSelectedItemWithNoDataStyle method.
                     * var datasource = [
                     *     { Name: "Apple", Category: "Fruit" },
                     *     { Name: "Orange", Category: "Fruit" },
                     *     { Name: "Broccoli", Category: "Vegetable" },
                     *     { Name: "Kiwi", Category: "Fruit" },
                     *     { Name: "Rice", Category: "Cereal" },
                     *     { Name: "Strawberry", Category: "Fruit" },
                     *     { Name: "Yogurt", Category: "Dairy" },
                     *     { Name: "Plum", Category: "Fruit" },
                     *     { Name: "Celery", Category: "Vegetable" },
                     *     { Name: "Grape", Category: "Fruit" },
                     *     { Name: "Oats", Category: "Cereal" },
                     *     { Name: "Quinoa", Category: "Cereal" },
                     *     { Name: "Maize", Category: "Cereal" },
                     *     { Name: "Okra", Category: "Vegetable" },
                     *     { Name: "Corn", Category: "Vegetable" },
                     *     { Name: "Wheat", Category: "Cereal" },
                     *     { Name: "Barley", Category: "Cereal" },
                     *     { Name: "Cream", Category: "Dairy" },
                     *     { Name: "Millet", Category: "Cereal" },
                     *     { Name: "Rye", Category: "Cereal" },
                     *     { Name: "Artichoke", Category: "Vegetable" },
                     *     { Name: "Buckwheat", Category: "Cereal" },
                     *     { Name: "Gooseberry", Category: "Fruit" },
                     *     { Name: "Amaranth", Category: "Cereal" },
                     *     { Name: "Carrot", Category: "Vegetable" },
                     *     { Name: "Cheese", Category: "Dairy" },
                     *     { Name: "Fig", Category: "Fruit" },
                     *     { Name: "Milk", Category: "Dairy" },
                     *     { Name: "Butter", Category: "Dairy" },
                     *               ];
                     * var table = activeSheet.tables.addFromDataSource("table1", 1, 1, datasource);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Category");
                     *  //change the slicer properties.
                     * slicer.width(200);
                     * slicer.height(200);
                     * slicer.position(new GC.Spread.Sheets.Point(300, 50));
                     * var slicer2 = activeSheet.slicers.add("slicer2", table.name(), "Name");
                     * var hstyle = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var hstyle1 = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GC.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * hstyle1.backColor("yellow");
                     * var hstyle2 = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2.backColor("green");
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.hoveredUnSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * style1.selectedItemWithDataStyle(hstyle2);
                     * slicer.style(style1);
                     * var hstyle2nd = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2nd.backColor("red");
                     * hstyle2nd.borderBottom(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "double", "orange"));
                     * var hstyle12nd = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle12nd.borderTop(new GC.Spread.Sheets.Slicers.SlicerBorder(2, "double", "blue"));
                     * hstyle12nd.backColor("yellow");
                     * var hstyle22nd = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle22nd.backColor("magenta");
                     * var style1two = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1two.hoveredSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.hoveredUnSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.unSelectedItemWithNoDataStyle(hstyle12nd);
                     * style1two.selectedItemWithNoDataStyle(hstyle22nd);
                     * slicer2.style(style1two);
                     * activeSheet.getColumn(1).width(100);
                     * activeSheet.getColumn(2).width(100);
                     * activeSheet.getColumn(3).width(100);
                     */
                    selectedItemWithDataStyle(value?:  GC.Spread.Sheets.Slicers.SlicerStyleInfo): any;
                    /**
                     * Gets or sets the style of the selected item with no data.
                     * @param {GC.Spread.Sheets.Slicers.SlicerStyleInfo} value The style of the selected item with no data.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyleInfo | GC.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the style of the selected item with no data; otherwise, returns the slicer style.
                     * @example
                     * //This example uses the hoveredUnSelectedItemWithNoDataStyle method.
                     * var datasource = [
                     *     { Name: "Apple", Category: "Fruit" },
                     *     { Name: "Orange", Category: "Fruit" },
                     *     { Name: "Broccoli", Category: "Vegetable" },
                     *     { Name: "Kiwi", Category: "Fruit" },
                     *     { Name: "Rice", Category: "Cereal" },
                     *     { Name: "Strawberry", Category: "Fruit" },
                     *     { Name: "Yogurt", Category: "Dairy" },
                     *     { Name: "Plum", Category: "Fruit" },
                     *     { Name: "Celery", Category: "Vegetable" },
                     *     { Name: "Grape", Category: "Fruit" },
                     *     { Name: "Oats", Category: "Cereal" },
                     *     { Name: "Quinoa", Category: "Cereal" },
                     *     { Name: "Maize", Category: "Cereal" },
                     *     { Name: "Okra", Category: "Vegetable" },
                     *     { Name: "Corn", Category: "Vegetable" },
                     *     { Name: "Wheat", Category: "Cereal" },
                     *     { Name: "Barley", Category: "Cereal" },
                     *     { Name: "Cream", Category: "Dairy" },
                     *     { Name: "Millet", Category: "Cereal" },
                     *     { Name: "Rye", Category: "Cereal" },
                     *     { Name: "Artichoke", Category: "Vegetable" },
                     *     { Name: "Buckwheat", Category: "Cereal" },
                     *     { Name: "Gooseberry", Category: "Fruit" },
                     *     { Name: "Amaranth", Category: "Cereal" },
                     *     { Name: "Carrot", Category: "Vegetable" },
                     *     { Name: "Cheese", Category: "Dairy" },
                     *     { Name: "Fig", Category: "Fruit" },
                     *     { Name: "Milk", Category: "Dairy" },
                     *     { Name: "Butter", Category: "Dairy" },
                     *               ];
                     * var table = activeSheet.tables.addFromDataSource("table1", 1, 1, datasource);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Category");
                     *  //change the slicer properties.
                     * slicer.width(200);
                     * slicer.height(200);
                     * slicer.position(new GC.Spread.Sheets.Point(300, 50));
                     * var slicer2 = activeSheet.slicers.add("slicer2", table.name(), "Name");
                     * var hstyle = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var hstyle1 = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GC.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * hstyle1.backColor("yellow");
                     * var hstyle2 = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2.backColor("green");
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.hoveredUnSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * style1.selectedItemWithDataStyle(hstyle2);
                     * slicer.style(style1);
                     * var hstyle2nd = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2nd.backColor("red");
                     * hstyle2nd.borderBottom(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "double", "orange"));
                     * var hstyle12nd = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle12nd.borderTop(new GC.Spread.Sheets.Slicers.SlicerBorder(2, "double", "blue"));
                     * hstyle12nd.backColor("yellow");
                     * var hstyle22nd = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle22nd.backColor("magenta");
                     * var style1two = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1two.hoveredSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.hoveredUnSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.unSelectedItemWithNoDataStyle(hstyle12nd);
                     * style1two.selectedItemWithNoDataStyle(hstyle22nd);
                     * slicer2.style(style1two);
                     * activeSheet.getColumn(1).width(100);
                     * activeSheet.getColumn(2).width(100);
                     * activeSheet.getColumn(3).width(100);
                     */
                    selectedItemWithNoDataStyle(value?:  GC.Spread.Sheets.Slicers.SlicerStyleInfo): any;
                    /**
                     * Gets or sets the style of the unselected item with data.
                     * @param {GC.Spread.Sheets.Slicers.SlicerStyleInfo} value The style of the unselected item with data.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyleInfo | GC.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the style of the unselected item with data; otherwise, returns the slicer style.
                     * @example
                     * //This example uses the hoveredUnSelectedItemWithNoDataStyle method.
                     * var datasource = [
                     *     { Name: "Apple", Category: "Fruit" },
                     *     { Name: "Orange", Category: "Fruit" },
                     *     { Name: "Broccoli", Category: "Vegetable" },
                     *     { Name: "Kiwi", Category: "Fruit" },
                     *     { Name: "Rice", Category: "Cereal" },
                     *     { Name: "Strawberry", Category: "Fruit" },
                     *     { Name: "Yogurt", Category: "Dairy" },
                     *     { Name: "Plum", Category: "Fruit" },
                     *     { Name: "Celery", Category: "Vegetable" },
                     *     { Name: "Grape", Category: "Fruit" },
                     *     { Name: "Oats", Category: "Cereal" },
                     *     { Name: "Quinoa", Category: "Cereal" },
                     *     { Name: "Maize", Category: "Cereal" },
                     *     { Name: "Okra", Category: "Vegetable" },
                     *     { Name: "Corn", Category: "Vegetable" },
                     *     { Name: "Wheat", Category: "Cereal" },
                     *     { Name: "Barley", Category: "Cereal" },
                     *     { Name: "Cream", Category: "Dairy" },
                     *     { Name: "Millet", Category: "Cereal" },
                     *     { Name: "Rye", Category: "Cereal" },
                     *     { Name: "Artichoke", Category: "Vegetable" },
                     *     { Name: "Buckwheat", Category: "Cereal" },
                     *     { Name: "Gooseberry", Category: "Fruit" },
                     *     { Name: "Amaranth", Category: "Cereal" },
                     *     { Name: "Carrot", Category: "Vegetable" },
                     *     { Name: "Cheese", Category: "Dairy" },
                     *     { Name: "Fig", Category: "Fruit" },
                     *     { Name: "Milk", Category: "Dairy" },
                     *     { Name: "Butter", Category: "Dairy" },
                     *               ];
                     * var table = activeSheet.tables.addFromDataSource("table1", 1, 1, datasource);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Category");
                     *  //change the slicer properties.
                     * slicer.width(200);
                     * slicer.height(200);
                     * slicer.position(new GC.Spread.Sheets.Point(300, 50));
                     * var slicer2 = activeSheet.slicers.add("slicer2", table.name(), "Name");
                     * var hstyle = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var hstyle1 = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GC.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * hstyle1.backColor("yellow");
                     * var hstyle2 = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2.backColor("green");
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.hoveredUnSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * style1.selectedItemWithDataStyle(hstyle2);
                     * slicer.style(style1);
                     * var hstyle2nd = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2nd.backColor("red");
                     * hstyle2nd.borderBottom(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "double", "orange"));
                     * var hstyle12nd = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle12nd.borderTop(new GC.Spread.Sheets.Slicers.SlicerBorder(2, "double", "blue"));
                     * hstyle12nd.backColor("yellow");
                     * var hstyle22nd = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle22nd.backColor("magenta");
                     * var style1two = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1two.hoveredSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.hoveredUnSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.unSelectedItemWithNoDataStyle(hstyle12nd);
                     * style1two.selectedItemWithNoDataStyle(hstyle22nd);
                     * slicer2.style(style1two);
                     * activeSheet.getColumn(1).width(100);
                     * activeSheet.getColumn(2).width(100);
                     * activeSheet.getColumn(3).width(100);
                     */
                    unSelectedItemWithDataStyle(value?:  GC.Spread.Sheets.Slicers.SlicerStyleInfo): any;
                    /**
                     * Gets or sets the style of the unselected item with no data.
                     * @param {GC.Spread.Sheets.Slicers.SlicerStyleInfo} value The style of the unselected item with no data.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyleInfo | GC.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the style of the unselected item with no data; otherwise, returns the slicer style.
                     * @example
                     * //This example uses the hoveredUnSelectedItemWithNoDataStyle method.
                     * var datasource = [
                     *     { Name: "Apple", Category: "Fruit" },
                     *     { Name: "Orange", Category: "Fruit" },
                     *     { Name: "Broccoli", Category: "Vegetable" },
                     *     { Name: "Kiwi", Category: "Fruit" },
                     *     { Name: "Rice", Category: "Cereal" },
                     *     { Name: "Strawberry", Category: "Fruit" },
                     *     { Name: "Yogurt", Category: "Dairy" },
                     *     { Name: "Plum", Category: "Fruit" },
                     *     { Name: "Celery", Category: "Vegetable" },
                     *     { Name: "Grape", Category: "Fruit" },
                     *     { Name: "Oats", Category: "Cereal" },
                     *     { Name: "Quinoa", Category: "Cereal" },
                     *     { Name: "Maize", Category: "Cereal" },
                     *     { Name: "Okra", Category: "Vegetable" },
                     *     { Name: "Corn", Category: "Vegetable" },
                     *     { Name: "Wheat", Category: "Cereal" },
                     *     { Name: "Barley", Category: "Cereal" },
                     *     { Name: "Cream", Category: "Dairy" },
                     *     { Name: "Millet", Category: "Cereal" },
                     *     { Name: "Rye", Category: "Cereal" },
                     *     { Name: "Artichoke", Category: "Vegetable" },
                     *     { Name: "Buckwheat", Category: "Cereal" },
                     *     { Name: "Gooseberry", Category: "Fruit" },
                     *     { Name: "Amaranth", Category: "Cereal" },
                     *     { Name: "Carrot", Category: "Vegetable" },
                     *     { Name: "Cheese", Category: "Dairy" },
                     *     { Name: "Fig", Category: "Fruit" },
                     *     { Name: "Milk", Category: "Dairy" },
                     *     { Name: "Butter", Category: "Dairy" },
                     *               ];
                     * var table = activeSheet.tables.addFromDataSource("table1", 1, 1, datasource);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Category");
                     *  //change the slicer properties.
                     * slicer.width(200);
                     * slicer.height(200);
                     * slicer.position(new GC.Spread.Sheets.Point(300, 50));
                     * var slicer2 = activeSheet.slicers.add("slicer2", table.name(), "Name");
                     * var hstyle = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var hstyle1 = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GC.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * hstyle1.backColor("yellow");
                     * var hstyle2 = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2.backColor("green");
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.hoveredUnSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * style1.selectedItemWithDataStyle(hstyle2);
                     * slicer.style(style1);
                     * var hstyle2nd = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2nd.backColor("red");
                     * hstyle2nd.borderBottom(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "double", "orange"));
                     * var hstyle12nd = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle12nd.borderTop(new GC.Spread.Sheets.Slicers.SlicerBorder(2, "double", "blue"));
                     * hstyle12nd.backColor("yellow");
                     * var hstyle22nd = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle22nd.backColor("magenta");
                     * var style1two = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1two.hoveredSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.hoveredUnSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.unSelectedItemWithNoDataStyle(hstyle12nd);
                     * style1two.selectedItemWithNoDataStyle(hstyle22nd);
                     * slicer2.style(style1two);
                     * activeSheet.getColumn(1).width(100);
                     * activeSheet.getColumn(2).width(100);
                     * activeSheet.getColumn(3).width(100);
                     */
                    unSelectedItemWithNoDataStyle(value?:  GC.Spread.Sheets.Slicers.SlicerStyleInfo): any;
                    /**
                     * Gets or sets the style of the whole slicer.
                     * @param {GC.Spread.Sheets.Slicers.SlicerStyleInfo} value The style of the whole slicer.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyleInfo | GC.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the style of the whole slicer; otherwise, returns the slicer style.
                     * @example
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Height");
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * //set customized style
                     * var style = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * var styleInfo1 = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * styleInfo1.backColor("orange");
                     * styleInfo1.borderBottom(new GC.Spread.Sheets.Slicers.SlicerBorder(2,"solid","green"));
                     * style.wholeSlicerStyle(styleInfo1);
                     * var styleInfo2 = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * styleInfo2.backColor("red");
                     * styleInfo2.borderBottom(new GC.Spread.Sheets.Slicers.SlicerBorder(4,"solid","gray"));
                     * style.hoveredSelectedItemWithDataStyle(styleInfo2);
                     * slicer.style(style);
                     */
                    wholeSlicerStyle(value?:  GC.Spread.Sheets.Slicers.SlicerStyleInfo): any;
                }

                export class SlicerStyleInfo{
                    /**
                     * Represents slicer style information.
                     * @class
                     * @param {string} backColor The background color of the style information.
                     * @param {string} foreColor The foreground color of the style information.
                     * @param {string} font The font of the style information.
                     * @param {GC.Spread.Sheets.Slicers.SlicerBorder} borderLeft The left border of the style information.
                     * @param {GC.Spread.Sheets.Slicers.SlicerBorder} borderTop The top border of the slicer information.
                     * @param {GC.Spread.Sheets.Slicers.SlicerBorder} borderRight The right border of the style information.
                     * @param {GC.Spread.Sheets.Slicers.SlicerBorder} borderBottom The bottom border of the style information.
                     * @param {GC.Spread.Sheets.TextDecorationType} textDecoration The text decoration of the style information.
                     */
                    constructor(backColor?:  string,  foreColor?:  string,  font?:  string,  borderLeft?:  GC.Spread.Sheets.Slicers.SlicerBorder,  borderTop?:  GC.Spread.Sheets.Slicers.SlicerBorder,  borderRight?:  GC.Spread.Sheets.Slicers.SlicerBorder,  borderBottom?:  GC.Spread.Sheets.Slicers.SlicerBorder,  textDecoration?:  GC.Spread.Sheets.TextDecorationType);
                    /**
                     * Gets or sets the background color of the style information.
                     * @param {string} value The background color of the style information.
                     * @returns {string | GC.Spread.Sheets.Slicers.SlicerStyleInfo}  If no value is set, returns the background color of the style information; otherwise, returns the slicer style information.
                     * @example
                     * //This example sets the header backcolor.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //style
                     * var hstyle = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.headerStyle(hstyle);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    backColor(value?:  string): any;
                    /**
                     * Gets or sets the bottom border of the style information.
                     * @param {GC.Spread.Sheets.Slicers.SlicerBorder} value The bottom border of the style information.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerBorder | GC.Spread.Sheets.Slicers.SlicerStyleInfo}  If no value is set, returns the bottom border of the style information; otherwise, returns the slicer style information.
                     * @example
                     * //This example sets a border style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //style
                     * var hstyle = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     * //change the slicer properties.
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    borderBottom(value?:  GC.Spread.Sheets.Slicers.SlicerBorder): any;
                    /**
                     * Gets or sets the left border of the style information.
                     * @param {GC.Spread.Sheets.Slicers.SlicerBorder} value The left border of the style information.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerBorder | GC.Spread.Sheets.Slicers.SlicerStyleInfo}  If no value is set, returns the left border of the style information; otherwise, returns the slicer style information.
                     * @example
                     * //This example sets the left border.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //style
                     * var hstyle = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderLeft(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * hstyle.borderRight(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var hstyle1 = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GC.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    borderLeft(value?:  GC.Spread.Sheets.Slicers.SlicerBorder): any;
                    /**
                     * Gets or sets the right border of the style information.
                     * @param {GC.Spread.Sheets.Slicers.SlicerBorder} value The right border of the style information.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerBorder | GC.Spread.Sheets.Slicers.SlicerStyleInfo}  If no value is set, returns the right border of the style information; otherwise, returns the slicer style information.
                     * @example
                     * //This example sets the border.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //style
                     * var hstyle = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderLeft(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * hstyle.borderRight(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var hstyle1 = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GC.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    borderRight(value?:  GC.Spread.Sheets.Slicers.SlicerBorder): any;
                    /**
                     * Gets or sets the top border of the style information.
                     * @param {GC.Spread.Sheets.Slicers.SlicerBorder} value The top border of the style information.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerBorder | GC.Spread.Sheets.Slicers.SlicerStyleInfo}  If no value is set, returns the top border of the style information; otherwise, returns the slicer style information.
                     * @example
                     * //This example sets the border.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //style
                     * var hstyle = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderLeft(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * hstyle.borderRight(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var hstyle1 = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GC.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    borderTop(value?:  GC.Spread.Sheets.Slicers.SlicerBorder): any;
                    /**
                     * Gets or sets the font of the style information.
                     * @param {string} value The font of the style information.
                     * @returns {string | GC.Spread.Sheets.Slicers.SlicerStyleInfo}  If no value is set, returns the font of the style information; otherwise, returns the slicer style information.
                     * @example
                     * //This example sets the font.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //style
                     * var hstyle = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * hstyle.font("8pt Arial");
                     * hstyle.textDecoration(GC.Spread.Sheets.TextDecorationType.underline);
                     * var hstyle1 = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GC.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    font(value?:  string): any;
                    /**
                     * Gets or sets the foreground color of the style information.
                     * @param {string} value The foreground color of the style information.
                     * @returns {string | GC.Spread.Sheets.Slicers.SlicerStyleInfo}  If no value is set, returns the foreground color of the style information; otherwise, returns the slicer style information.
                     * @example
                     * //This example sets a header style for the slicer.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //style
                     * var hstyle = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.foreColor("white");
                     * hstyle.backColor("black");
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.headerStyle(hstyle);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    foreColor(value?:  string): any;
                    /**
                     * Sets every border of the style information.
                     * @param {GC.Spread.Sheets.Slicers.SlicerBorder} value The border setting.
                     */
                    setBorders(value:  GC.Spread.Sheets.Slicers.SlicerBorder): void;
                    /**
                     * Gets or sets the text decoration of the style information.
                     * @param {GC.Spread.Sheets.TextDecorationType} value The text decoration of the style information.
                     * @returns {GC.Spread.Sheets.TextDecorationType | GC.Spread.Sheets.Slicers.SlicerStyleInfo}  If no value is set, returns the text decoration of the style information; otherwise, returns the slicer style information.
                     * @example
                     * //This example underlines the text.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //style
                     * var hstyle = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GC.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * hstyle.font("8pt Arial");
                     * hstyle.textDecoration(GC.Spread.Sheets.TextDecorationType.underline);
                     * var hstyle1 = new GC.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GC.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    textDecoration(value?:  GC.Spread.Sheets.TextDecorationType): any;
                }

                export class SlicerStyles{
                    /**
                     * Represents a built-in slicer style collection.
                     * @class
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.light4();
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    constructor();
                    /**
                     * Gets the dark1 style.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.dark1();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static dark1(): GC.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the dark2 style.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.dark2();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static dark2(): GC.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the dark3 style.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.dark3();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static dark3(): GC.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the dark4 style.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.dark4();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static dark4(): GC.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the dark5 style.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.dark5();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static dark5(): GC.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the dark6 style.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.dark6();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static dark6(): GC.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the light1 style.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.light1();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static light1(): GC.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the light2 style.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.light2();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static light2(): GC.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the light3 style.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.light3();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static light3(): GC.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the light4 style.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.light4();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static light4(): GC.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the light5 style.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.light5();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static light5(): GC.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the light6 style.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.light6();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static light6(): GC.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the other1 style.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.other1();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static other1(): GC.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the other2 style.
                     * @returns {GC.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GC.Spread.Sheets.Slicers.SlicerStyles.other2();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GC.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static other2(): GC.Spread.Sheets.Slicers.SlicerStyle;
                }

                export class TableSlicerData extends GC.Spread.Slicers.GeneralSlicerData{
                    /**
                     * Represents table slicer data.
                     * @extends GC.Spread.Slicers.GeneralSlicerData
                     * @class GC.Spread.Sheets.TableSlicerData
                     * @param {GC.Spread.Sheets.Tables.Table} table The table.
                     * @example
                     * //This example creates a slicer for the table.
                     * //create table
                     * var dataSource = [
                     *     { Name: "Bob", City: "NewYork", Birthday: "1968/6/8" },
                     *     { Name: "Betty", City: "NewYork", Birthday: "1972/7/3" },
                     *     { Name: "Alice", City: "Washington", Birthday: "2012/2/15" },
                     * ];
                     * var table = activeSheet.tables.addFromDataSource("table1", 1, 1, dataSource);
                     * var slicerData = new GC.Spread.Sheets.Slicers.TableSlicerData(table)
                     * //Set slicer data to item slicer.
                     * var slicer = new GC.Spread.Sheets.Slicers.ItemSlicer("slicer", slicerData, "Name");
                     * //Add the item slicer to the dom tree.
                     * //The "slicerHost" is the div you want to add the slicer's dom to.
                     * $("#slicerHost").append(slicer.getDOMElement());
                     */
                    constructor(table:  GC.Spread.Sheets.Tables.Table);
                    /**
                     * Filters the data that corresponds to the specified column name and exclusive data indexes.
                     * @param {string} columnName The column name.
                     * @param {object} conditional The filter conditional.
                     * conditional.exclusiveRowIndexes: number array type, visible exclusive row indexes
                     * conditional.ranges: {min:number, max:number} array type, visible ranges.
                     * @param {boolean} isPreview Indicates whether filter is in preview mode.
                     */
                    doFilter(columnName:  string,  conditional:  GC.Spread.Slicers.ISlicerConditional,  isPreview?:  boolean): void;
                    /**
                     * Unfilters the data that corresponds to the specified column name.
                     * @param {string} columnName The column name.
                     */
                    doUnfilter(columnName:  string): void;
                    /**
                     * Gets the slicer data of the table.
                     * @returns {GC.Spread.Sheets.Slicers.TableSlicerData} The slicer data of the table.
                     */
                    getSlicerData(): GC.Spread.Sheets.Slicers.TableSlicerData;
                    /**
                     * Gets the table of the table slicer data.
                     * @returns {GC.Spread.Sheets.Tables.Table} The table of the table slicer data.
                     */
                    getTable(): GC.Spread.Sheets.Tables.Table;
                    /**
                     * Refreshes the table slicer data.
                     */
                    refresh(): void;
                }
            }

            module Sparklines{

                export interface ISparklineSetting{
                    axisColor: string;
                    firstMarkerColor: string;
                    highMarkerColor: string;
                    lastMarkerColor: string;
                    lowMarkerColor: string;
                    markersColor: string;
                    negativeColor: string;
                    seriesColor: string;
                    displayEmptyCellsAs: EmptyValueStyle;
                    rightToLeft: boolean;
                    displayHidden: boolean;
                    displayXAxis: boolean;
                    showFirst: boolean;
                    showHigh: boolean;
                    showLast: boolean;
                    showLow: boolean;
                    showNegative: boolean;
                    showMarkers: boolean;
                    manualMax: number;
                    manualMin: number;
                    maxAxisType: SparklineAxisMinMax;
                    minAxisType: SparklineAxisMinMax;
                    groupMaxValue: number;
                    groupMinValue: number;
                    lineWeight: number;
                }

                /**
                 * Represents the orientation of the range.
                 * @enum {number}
                 * @example
                 * //This example uses the DataOrientation enumeration.
                 * activeSheet.setValue(0, 0, "Data Range is A2-A9");
                 * activeSheet.setValue(1, 0, 1);
                 * activeSheet.setValue(2, 0, -2);
                 * activeSheet.setValue(3, 0, -1);
                 * activeSheet.setValue(4, 0, 6);
                 * activeSheet.setValue(5, 0, 4);
                 * activeSheet.setValue(6, 0, -4);
                 * activeSheet.setValue(7, 0, 3);
                 * activeSheet.setValue(8, 0, 8);
                 * var data = new GC.Spread.Sheets.Range(1, 0, 8, 1);
                 * var setting = new GC.Spread.Sheets.Sparklines.SparklineSetting();
                 * var s1=  activeSheet.setSparkline(11, 0, data, GC.Spread.Sheets.Sparklines.DataOrientation.Vertical, GC.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 * var s2 =activeSheet.setSparkline(11, 3, data, GC.Spread.Sheets.Sparklines.DataOrientation.Vertical, GC.Spread.Sheets.Sparklines.SparklineType.column, setting);
                 * var s3=  activeSheet.setSparkline(11, 6, data, GC.Spread.Sheets.Sparklines.DataOrientation.Vertical, GC.Spread.Sheets.Sparklines.SparklineType.winloss, setting);
                 * var group = activeSheet.groupSparkline([s1,s2,s3]);
                 * //activeSheet.ungroupSparkline(group);
                 */
                export enum DataOrientation{
                    /** Specifies the vertical orientation.
                     * @type {number}
                     */
                    vertical= 0,
                    /** Specifies the horizontal orientation.
                     * @type {number}
                     */
                    horizontal= 1
                }

                /**
                 * Specifies how to show an empty value from a data series in the chart.
                 * @enum {number}
                 * @example
                 * //This example uses the EmptyValueStyle enumeration.
                 * var data = new GC.Spread.Sheets.Range(1, 0, 8, 1);
                 * var setting = new GC.Spread.Sheets.Sparklines.SparklineSetting
                 * setting.options.showMarkers = true;
                 * setting.options.lineWeight = 3;
                 * setting.options.displayXAxis = true;
                 * setting.options.showFirst = true;
                 * setting.options.showLast = true;
                 * setting.options.showLow = true;
                 * setting.options.showHigh = true;
                 * setting.options.showNegative = true;
                 * setting.options.seriesColor = "Text 2 1";
                 * setting.options.firstMarkerColor = "Text 2 3";
                 * setting.options.negativeColor = "Accent 2 1";
                 * setting.options.markersColor = "Accent 3 1";
                 * setting.options.lowMarkerColor = "Accent 4 1";
                 * setting.options.highMarkerColor = "Accent 6 1";
                 * setting.options.lastMarkerColor = "Accent 6 6";
                 * setting.options.axisColor = "Text 1 1";
                 * setting.options.displayEmptyCellsAs =  GC.Spread.Sheets.Sparklines.EmptyValueStyle.Zero;
                 * activeSheet.addSpan(13, 0, 4, 3, null);
                 * activeSheet.setSparkline(13, 0, data, GC.Spread.Sheets.Sparklines.DataOrientation.vertical, GC.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 * activeSheet.setValue(1, 0, 1);
                 * activeSheet.setValue(2, 0, -2);
                 * activeSheet.setValue(3, 0, -1);
                 * activeSheet.setValue(4, 0, 6);
                 * activeSheet.setValue(5, 0, 4);
                 * activeSheet.setValue(6, 0, -4);
                 * activeSheet.setValue(7, 0, 3);
                 * activeSheet.setValue(8, 0, 8);
                 */
                export enum EmptyValueStyle{
                    /** Leaves gaps for empty values in a data series, which results in a segmented line.
                     * @type {number}
                     */
                    gaps= 0,
                    /** Handles empty values in a data series as zero values, so that the line drops to zero for zero-value data points.
                     * @type {number}
                     */
                    zero= 1,
                    /** Fills gaps with a connecting element instead of leaving gaps for empty values in a data series.
                     * @type {number}
                     */
                    connect= 2
                }

                /**
                 * An enumeration that specifies information about how the vertical axis minimum or maximum is computed for this sparkline group.
                 * @enum {number}
                 * @example
                 * //This example uses the SparklineAxisMinMax enumeration.
                 * activeSheet.setValue(0, 0, "Data Range is A2-A9");
                 * activeSheet.setValue(1, 0, 1);
                 * activeSheet.setValue(2, 0, -2);
                 * activeSheet.setValue(3, 0, -1);
                 * activeSheet.setValue(4, 0, 6);
                 * activeSheet.setValue(5, 0, 4);
                 * activeSheet.setValue(6, 0, -4);
                 * activeSheet.setValue(7, 0, 3);
                 * activeSheet.setValue(8, 0, 8);
                 * var data = new GC.Spread.Sheets.Range(1, 0, 8, 1);
                 * var setting = new GC.Spread.Sheets.Sparklines.SparklineSetting();
                 * setting.options.minAxisType = GC.Spread.Sheets.Sparklines.SparklineAxisMinMax.custom;
                 * setting.options.manualMin = -2;
                 * setting.options.maxAxisType = GC.Spread.Sheets.Sparklines.SparklineAxisMinMax.custom;
                 * setting.options.manualMax = 10;
                 * var s1=  activeSheet.setSparkline(11, 0, data, GC.Spread.Sheets.Sparklines.DataOrientation.Vertical, GC.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 * var s2 =activeSheet.setSparkline(11, 3, data, GC.Spread.Sheets.Sparklines.DataOrientation.Vertical, GC.Spread.Sheets.Sparklines.SparklineType.column, setting);
                 * var s3=  activeSheet.setSparkline(11, 6, data, GC.Spread.Sheets.Sparklines.DataOrientation.Vertical, GC.Spread.Sheets.Sparklines.SparklineType.winloss, setting);
                 * var group = activeSheet.groupSparkline([s1,s2,s3]);
                 */
                export enum SparklineAxisMinMax{
                    /** Specifies that the vertical axis minimum or maximum for each sparkline in this sparkline group is calculated automatically such that the data point with the minimum or maximum value can be displayed in the plot area.
                     * @type {number}
                     */
                    individual= 0,
                    /** Specifies that the vertical axis minimum or maximum is shared across all sparklines in this sparkline group and is calculated automatically such that the data point with the minimum or maximum value can be displayed in the plot area.
                     * @type {number}
                     */
                    group= 1,
                    /** Specifies that the vertical axis minimum or maximum for each sparkline in this sparkline group is specified by the manualMin attribute or the manualMax attribute of the sparkline group.
                     * @type {number}
                     */
                    custom= 2
                }

                /**
                 * Represents the sparkline type.
                 * @enum {number}
                 * @example
                 * //This example uses the SparklineType enumeration.
                 * activeSheet.setValue(0, 0, "Data Range is A2-A9");
                 * activeSheet.setValue(1, 0, 1);
                 * activeSheet.setValue(2, 0, -2);
                 * activeSheet.setValue(3, 0, -1);
                 * activeSheet.setValue(4, 0, 6);
                 * activeSheet.setValue(5, 0, 4);
                 * activeSheet.setValue(6, 0, -4);
                 * activeSheet.setValue(7, 0, 3);
                 * activeSheet.setValue(8, 0, 8);
                 * var data = new GC.Spread.Sheets.Range(1, 0, 8, 1);
                 * var setting = new GC.Spread.Sheets.Sparklines.SparklineSetting();
                 * var s1=  activeSheet.setSparkline(11, 0, data, GC.Spread.Sheets.Sparklines.DataOrientation.Vertical, GC.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 * var s2 =activeSheet.setSparkline(11, 3, data, GC.Spread.Sheets.Sparklines.DataOrientation.Vertical, GC.Spread.Sheets.Sparklines.SparklineType.column, setting);
                 * var s3=  activeSheet.setSparkline(11, 6, data, GC.Spread.Sheets.Sparklines.DataOrientation.Vertical, GC.Spread.Sheets.Sparklines.SparklineType.winloss, setting);
                 * var group = activeSheet.groupSparkline([s1,s2,s3]);
                 * //activeSheet.ungroupSparkline(group);
                 */
                export enum SparklineType{
                    /** Specifies the line sparkline.
                     * @type {number}
                     */
                    line= 0,
                    /** Specifies the column sparkline.
                     * @type {number}
                     */
                    column= 1,
                    /** Specifies the win-loss sparkline.
                     * @type {number}
                     */
                    winloss= 2
                }


                export class AreaSparkline extends SparklineEx{
                    /**
                     * Represents the class for the area sparkline.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class BoxPlotSparkline extends SparklineEx{
                    /**
                     * Represents the class for the box plot sparkline.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class BulletSparkline extends SparklineEx{
                    /**
                     * Represents the class for the bullet sparkline.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class CascadeSparkline extends SparklineEx{
                    /**
                     * Represents the class for the cascade sparkline.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class ColumnSparkline extends SparklineEx{
                    /**
                     * Represents the class for the column sparkline.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class HBarSparkline extends SparklineEx{
                    /**
                     * Represents the class for the Hbar sparkline.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class LineSparkline extends SparklineEx{
                    /**
                     * Represents the class for the line sparkline.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class MonthSparkline extends SparklineEx{
                    /**
                     * Represents the class for the month sparkline.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class ParetoSparkline extends SparklineEx{
                    /**
                     * Represents the class for the pareto sparkline.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class PieSparkline extends SparklineEx{
                    /**
                     * Represents the class for the pie sparkline.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class ScatterSparkline extends SparklineEx{
                    /**
                     * Represents the class for the scatter sparkline.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class Sparkline{
                    /**
                     * Represents a Sparkline class.
                     * @param {number} row The row index.
                     * @param {number} column The column index.
                     * @param {GC.Spread.Sheets.Range} dataReference The data range to which the sparkline refers.
                     * @param {GC.Spread.Sheets.Sparklines.DataOrientation} dataOrientation The orientation of the data range.
                     * @param {GC.Spread.Sheets.Sparklines.SparklineType} type The type of sparkline.
                     * @param {GC.Spread.Sheets.Sparklines.SparklineSetting} setting The setting of the sparkline.
                     * @class
                     */
                    constructor(row?:  number,  column?:  number,  dataReference?:  GC.Spread.Sheets.Range,  dataOrientation?:  GC.Spread.Sheets.Sparklines.DataOrientation,  type?:  GC.Spread.Sheets.Sparklines.SparklineType,  setting?:  GC.Spread.Sheets.Sparklines.SparklineSetting);
                    /** Gets the column index.
                     * @type {number}
                     */
                    column: number;
                    /** Gets the row index.
                     * @type {number}
                     */
                    row: number;
                    /**
                     * Clones a sparkline.
                     * @returns {GC.Spread.Sheets.Sparklines.Sparkline} The cloned sparkline.
                     */
                    clone(): GC.Spread.Sheets.Sparklines.Sparkline;
                    /**
                     * Gets or sets the data object.
                     * @param {GC.Spread.Sheets.Range} value The sparkline data.
                     * @returns {GC.Spread.Sheets.Range | GC.Spread.Sheets.Sparklines.Sparkline} If no value is set, returns the data object; otherwise, returns the sparkline.
                     * @example
                     * //This example uses the data method.
                     * activeSheet.suspendPaint();
                     * activeSheet.setValue(1, 0, 10);
                     * activeSheet.setValue(2, 0, 0);
                     * activeSheet.setValue(3, 0, -3);
                     * activeSheet.setValue(4, 0, -5);
                     * activeSheet.setValue(0, 0, 1);
                     * activeSheet.setValue(0, 1, 2);
                     * activeSheet.setValue(0, 2, 4);
                     * activeSheet.setValue(0, 3, 8);
                     * activeSheet.setValue(0, 4, 6);
                     * activeSheet.setValue(0, 5, new Date(2014, 1, 1));
                     * activeSheet.setValue(1, 5, new Date(2014, 9, 1));
                     * activeSheet.setValue(2, 5, new Date(2014, 7, 1));
                     * activeSheet.setValue(3, 5, new Date(2014, 5, 1));
                     * activeSheet.setValue(4, 5, new Date(2014, 3, 1));
                     * var sparkline = activeSheet.setSparkline(5, 0, new GC.Spread.Sheets.Range(0, 0, 5, 5), GC.Spread.Sheets.Sparklines.DataOrientation.horizontal, GC.Spread.Sheets.Sparklines.SparklineType.line, new GC.Spread.Sheets.Sparklines.SparklineSetting(), new GC.Spread.Sheets.Range(0, 5, 5, 1), GC.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.data(new GC.Spread.Sheets.Range(0, 0, 5, 5));
                     * sparkline.sparklineType(GC.Spread.Sheets.Sparklines.SparklineType.line);
                     * sparkline.setting(new GC.Spread.Sheets.Sparklines.SparklineSetting());
                     * sparkline.dateAxisData(new GC.Spread.Sheets.Range(0, 5, 5, 1));
                     * sparkline.dataOrientation(GC.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.dateAxisOrientation(GC.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.row = 5;
                     * sparkline.column = 0;
                     * sparkline.displayDateAxis(true);
                     * activeSheet.resumePaint();
                     */
                    data(value?:  GC.Spread.Sheets.Range): any;
                    /**
                     * Gets or sets the data orientation.
                     * @param {GC.Spread.Sheets.Sparklines.DataOrientation} value The sparkline data orientation.
                     * @returns {GC.Spread.Sheets.Sparklines.DataOrientation | GC.Spread.Sheets.Sparklines.Sparkline} If no value is set, returns the sparkline data orientation; otherwise, returns the sparkline.
                     * @example
                     * //This example uses the vertical data and the date range to create the sparkline.
                     * var setting = new GC.Spread.Sheets.Sparklines.SparklineSetting();
                     * setting.options.showMarkers = true;
                     * setting.options.displayXAxis = true;
                     * activeSheet.suspendPaint();
                     * activeSheet.setValue(1, 0, 10);
                     * activeSheet.setValue(2, 0, 0);
                     * activeSheet.setValue(3, 0, -3);
                     * activeSheet.setValue(4, 0, -5);
                     * activeSheet.setValue(0, 0, 1);
                     * activeSheet.setValue(0, 1, 2);
                     * activeSheet.setValue(0, 2, 4);
                     * activeSheet.setValue(0, 3, 8);
                     * activeSheet.setValue(0, 4, 6);
                     * activeSheet.setValue(0, 5, new Date(2014, 1, 1));
                     * activeSheet.setValue(1, 5, new Date(2014, 9, 1));
                     * activeSheet.setValue(2, 5, new Date(2014, 7, 1));
                     * activeSheet.setValue(3, 5, new Date(2014, 5, 1));
                     * activeSheet.setValue(4, 5, new Date(2014, 3, 1));
                     * var sparkline = activeSheet.setSparkline(5, 0, new GC.Spread.Sheets.Range(0, 0, 5, 5), GC.Spread.Sheets.Sparklines.DataOrientation.horizontal, GC.Spread.Sheets.Sparklines.SparklineType.line, setting, new GC.Spread.Sheets.Range(0, 5, 5, 1), GC.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.dataOrientation(GC.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.displayDateAxis(true);
                     * activeSheet.resumePaint();
                     * activeSheet.addSpan(5, 0, 4, 3, null);
                     */
                    dataOrientation(value?:  GC.Spread.Sheets.Sparklines.DataOrientation): any;
                    /**
                     * Gets or sets the date axis data object.
                     * @param {GC.Spread.Sheets.Range} value The sparkline date axis data.
                     * @returns {GC.Spread.Sheets.Range | GC.Spread.Sheets.Sparklines.Sparkline} If no value is set, returns the sparkline date axis data; otherwise, returns the sparkline.
                     * @example
                     * //This example uses the dateAxisData method.
                     * activeSheet.suspendPaint();
                     * activeSheet.setValue(1, 0, 10);
                     * activeSheet.setValue(2, 0, 0);
                     * activeSheet.setValue(3, 0, -3);
                     * activeSheet.setValue(4, 0, -5);
                     * activeSheet.setValue(0, 0, 1);
                     * activeSheet.setValue(0, 1, 2);
                     * activeSheet.setValue(0, 2, 4);
                     * activeSheet.setValue(0, 3, 8);
                     * activeSheet.setValue(0, 4, 6);
                     * activeSheet.setValue(0, 5, new Date(2014, 1, 1));
                     * activeSheet.setValue(1, 5, new Date(2014, 9, 1));
                     * activeSheet.setValue(2, 5, new Date(2014, 7, 1));
                     * activeSheet.setValue(3, 5, new Date(2014, 5, 1));
                     * activeSheet.setValue(4, 5, new Date(2014, 3, 1));
                     * var sparkline = activeSheet.setSparkline(5, 0, new GC.Spread.Sheets.Range(0, 0, 5, 5), GC.Spread.Sheets.Sparklines.DataOrientation.horizontal, GC.Spread.Sheets.Sparklines.SparklineType.line, new GC.Spread.Sheets.Sparklines.SparklineSetting(), new GC.Spread.Sheets.Range(0, 5, 5, 1), GC.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.data(new GC.Spread.Sheets.Range(0, 0, 5, 5));
                     * sparkline.sparklineType(GC.Spread.Sheets.Sparklines.SparklineType.line);
                     * sparkline.setting(new GC.Spread.Sheets.Sparklines.SparklineSetting());
                     * sparkline.dateAxisData(new GC.Spread.Sheets.Range(0, 5, 5, 1));
                     * sparkline.dataOrientation(GC.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.dateAxisOrientation(GC.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.row = 5;
                     * sparkline.column = 0;
                     * sparkline.displayDateAxis(true);
                     * activeSheet.resumePaint();
                     */
                    dateAxisData(value?:  GC.Spread.Sheets.Range): any;
                    /**
                     * Gets or sets the date axis orientation.
                     * @param {GC.Spread.Sheets.Sparklines.DataOrientation} value The sparkline date axis orientation.
                     * @returns {GC.Spread.Sheets.Sparklines.DataOrientation | GC.Spread.Sheets.Sparklines.Sparkline} If no value is set, returns the sparkline date axis orientation; otherwise, returns the sparkline.
                     * @example
                     * //This example uses vertical data with horizontal dates to create a sparkline.
                     * var setting = new GC.Spread.Sheets.Sparklines.SparklineSetting();
                     * setting.options.showMarkers = true;
                     * setting.options.displayXAxis = true;
                     * activeSheet.suspendPaint();
                     * activeSheet.setValue(1, 0, 10);
                     * activeSheet.setValue(2, 0, 0);
                     * activeSheet.setValue(3, 0, -3);
                     * activeSheet.setValue(4, 0, -5);
                     * activeSheet.setValue(0, 0, 1);
                     * activeSheet.setValue(0, 1, 2);
                     * activeSheet.setValue(0, 2, 4);
                     * activeSheet.setValue(0, 3, 8);
                     * activeSheet.setValue(0, 4, 6);
                     * activeSheet.setValue(0, 5, new Date(2014, 1, 1));
                     * activeSheet.setValue(1, 5, new Date(2014, 9, 1));
                     * activeSheet.setValue(2, 5, new Date(2014, 7, 1));
                     * activeSheet.setValue(3, 5, new Date(2014, 5, 1));
                     * activeSheet.setValue(4, 5, new Date(2014, 3, 1));
                     * activeSheet.setValue(11, 0, new Date(2014, 1, 1));
                     * activeSheet.setValue(11, 1, new Date(2014, 9, 1));
                     * activeSheet.setValue(11, 2, new Date(2014, 7, 1));
                     * activeSheet.setValue(11, 3, new Date(2014, 5, 1));
                     * activeSheet.setValue(11, 4, new Date(2014, 3, 1));
                     * var sparkline = activeSheet.setSparkline(5, 0, new GC.Spread.Sheets.Range(0, 0, 5, 5), GC.Spread.Sheets.Sparklines.DataOrientation.vertical, GC.Spread.Sheets.Sparklines.SparklineType.line, setting, new GC.Spread.Sheets.Range(11, 0, 1, 5), GC.Spread.Sheets.Sparklines.DataOrientation.horizontal);
                     * sparkline.dataOrientation(GC.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.dateAxisOrientation(GC.Spread.Sheets.Sparklines.DataOrientation.horizontal);
                     * sparkline.displayDateAxis(true);
                     * activeSheet.resumePaint();
                     * activeSheet.addSpan(5, 0, 4, 3, null);
                     */
                    dateAxisOrientation(value?:  GC.Spread.Sheets.Sparklines.DataOrientation): any;
                    /**
                     * Gets or sets a value that indicates whether to display the date axis.
                     * @param {boolean} value Whether to display the date axis.
                     * @returns {boolean | GC.Spread.Sheets.Sparklines.Sparkline} If no value is set, returns whether to display the date axis; otherwise, returns the sparkline.
                     * @example
                     * //This example uses the vertical data and the date range to create the sparkline.
                     * var setting = new GC.Spread.Sheets.Sparklines.SparklineSetting();
                     * setting.options.showMarkers = true;
                     * setting.options.displayXAxis = true;
                     * activeSheet.suspendPaint();
                     * activeSheet.setValue(1, 0, 10);
                     * activeSheet.setValue(2, 0, 0);
                     * activeSheet.setValue(3, 0, -3);
                     * activeSheet.setValue(4, 0, -5);
                     * activeSheet.setValue(0, 0, 1);
                     * activeSheet.setValue(0, 1, 2);
                     * activeSheet.setValue(0, 2, 4);
                     * activeSheet.setValue(0, 3, 8);
                     * activeSheet.setValue(0, 4, 6);
                     * activeSheet.setValue(0, 5, new Date(2014, 1, 1));
                     * activeSheet.setValue(1, 5, new Date(2014, 9, 1));
                     * activeSheet.setValue(2, 5, new Date(2014, 7, 1));
                     * activeSheet.setValue(3, 5, new Date(2014, 5, 1));
                     * activeSheet.setValue(4, 5, new Date(2014, 3, 1));
                     * var sparkline = activeSheet.setSparkline(5, 0, new GC.Spread.Sheets.Range(0, 0, 5, 5), GC.Spread.Sheets.Sparklines.DataOrientation.horizontal, GC.Spread.Sheets.Sparklines.SparklineType.line, setting, new GC.Spread.Sheets.Range(0, 5, 5, 1), GC.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.dataOrientation(GC.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.displayDateAxis(true);
                     * activeSheet.resumePaint();
                     * activeSheet.addSpan(5, 0, 4, 3, null);
                     */
                    displayDateAxis(value?:  boolean): any;
                    /**
                     * Gets or sets the sparkline group.
                     * @param {GC.Spread.Sheets.Sparklines.SparklineGroup} value The sparkline group.
                     * @returns {GC.Spread.Sheets.Sparklines.SparklineGroup | GC.Spread.Sheets.Sparklines.Sparkline} If no value is set, returns the sparkline group; otherwise, returns the sparkline.
                     */
                    group(value?:  GC.Spread.Sheets.Sparklines.SparklineGroup): any;
                    /**
                     * Paints the sparkline in the specified area.
                     * @param {CanvasRenderingContext2D} ctx The canvas's two-dimensional context.
                     * @param {number} x <i>x</i>-coordinate relative to the canvas.
                     * @param {number} y <i>y</i>-coordinate relative to the canvas.
                     * @param {number} w The width of the cell that contains the sparkline.
                     * @param {number} h The height of the cell that contains the sparkline.
                     */
                    paintSparkline(ctx:  CanvasRenderingContext2D,  x:  number,  y:  number,  w:  number,  h:  number): void;
                    /**
                     * Gets or sets the sparkline setting of the cell.
                     * @param {GC.Spread.Sheets.Sparklines.SparklineSetting} value The sparkline setting.
                     * @returns {GC.Spread.Sheets.Sparklines.SparklineSetting  | GC.Spread.Sheets.Sparklines.Sparkline} If no value is set, returns the sparkline setting; otherwise, returns the sparkline.
                     */
                    setting(value?:  GC.Spread.Sheets.Sparklines.SparklineSetting): any;
                    /**
                     * Gets or sets the type of the sparkline.
                     * @param {GC.Spread.Sheets.Sparklines.SparklineType} value The sparkline type.
                     * @returns {GC.Spread.Sheets.Sparklines.SparklineType | GC.Spread.Sheets.Sparklines.Sparkline} If no value is set, returns the sparkline type; otherwise, returns the sparkline.
                     */
                    sparklineType(value?:  GC.Spread.Sheets.Sparklines.SparklineType): any;
                }

                export class SparklineEx{
                    /**
                     * Represents the base class for the other SparklineEx classes.
                     * @class
                     */
                    constructor();
                    /**
                     * Represents the type name string used for supporting serialization.
                     * @type {string}
                     */
                    typeName: string;
                    /**
                     * Creates a custom function used to provide data and settings for SparklineEx.
                     * @returns {GC.Spread.CalcEngine.Functions.Function} The created custom function.
                     */
                    createFunction(): GC.Spread.CalcEngine.Functions.Function;
                    /**
                     * Loads the object state from the specified JSON string.
                     * @param {Object} settings The sparklineEx data from deserialization.
                     */
                    fromJSON(settings:  Object): void;
                    /**
                     * Gets the name of SparklineEx.
                     * @returns {string} The SparklineEx's name.
                     */
                    name(): string;
                    /**
                     * Paints the SparklineEx on the canvas.
                     * @param {CanvasRenderingContext2D} context The canvas's two-dimensional context.
                     * @param {object} value The value evaluated by the custom function.
                     * @param {number} x <i>x</i>-coordinate relative to the canvas.
                     * @param {number} y <i>y</i>-coordinate relative to the canvas.
                     * @param {number} width The cell's width.
                     * @param {number} height The cell's height.
                     */
                    paint(context:  CanvasRenderingContext2D,  value:  any,  x:  number,  y:  number,  width:  number,  height:  number): void;
                    /**
                     * Saves the object state to a JSON string.
                     * @returns {Object} The sparklineEx data.
                     */
                    toJSON(): Object;
                }

                export class SparklineGroup{
                    /**
                     * Represents a sparkline group.
                     * @param {GC.Spread.Sheets.Sparklines.SparklineType} type The type of sparkline.
                     * @param {GC.Spread.Sheets.Sparklines.SparklineSetting} setting The setting of the sparkline group.
                     * @class
                     */
                    constructor(type:  GC.Spread.Sheets.Sparklines.SparklineType,  setting:  GC.Spread.Sheets.Sparklines.SparklineSetting);
                    /** Indicates the sparkline settings.
                     * @type {GC.Spread.Sheets.Sparklines.SparklineSetting}
                     */
                    setting: GC.Spread.Sheets.Sparklines.SparklineSetting;
                    /** Indicates the sparkline type.
                     * @type {GC.Spread.Sheets.Sparklines.SparklineType}
                     */
                    sparklineType: GC.Spread.Sheets.Sparklines.SparklineType;
                    /**
                     * Adds a sparkline to the group.
                     * @param {GC.Spread.Sheets.Sparklines.Sparkline} item The sparkline item.
                     */
                    add(item:  GC.Spread.Sheets.Sparklines.Sparkline): void;
                    /**
                     * Clones the current sparkline group.
                     * @returns {GC.Spread.Sheets.Sparklines.SparklineGroup} The cloned sparkline group.
                     */
                    clone(): GC.Spread.Sheets.Sparklines.SparklineGroup;
                    /**
                     * Determines whether the group contains a specific value.
                     * @param {GC.Spread.Sheets.Sparklines.Sparkline} item The object to locate in the group.
                     * @returns {boolean} <c>true</c> if the item is found in the group; otherwise, <c>false</c>.
                     */
                    contains(item:  GC.Spread.Sheets.Sparklines.Sparkline): boolean;
                    /**
                     * Represents the count of the sparkline group innerlist.
                     * @returns {number} The sparkline count in the group.
                     */
                    count(): number;
                    /**
                     * Represents the date axis data.
                     * @param {GC.Spread.Sheets.Range} value The date axis data.
                     * @returns {GC.Spread.Sheets.Range | undefined} If no value is set, returns the date axis data; otherwise, returns undefined.
                     */
                    dateAxisData(value?:  GC.Spread.Sheets.Range): any;
                    /**
                     * Represents the date axis orientation.
                     * @param {GC.Spread.Sheets.Sparklines.DataOrientation} value The date axis orientation.
                     * @returns {GC.Spread.Sheets.Sparklines.DataOrientation | undefined} If no value is set, returns the date axis orientation; otherwise, returns undefined.
                     */
                    dateAxisOrientation(value:  GC.Spread.Sheets.Sparklines.DataOrientation): any;
                    /**
                     * Removes the first occurrence of a specific object from the group.
                     * @param {GC.Spread.Sheets.Sparklines.Sparkline} item The sparkline item.
                     * @returns {Array} The GC.Spread.Sheets.Sparklines.Sparkline array.
                     */
                    remove(item:  GC.Spread.Sheets.Sparklines.Sparkline): GC.Spread.Sheets.Sparklines.Sparkline[];
                }

                export class SparklineSetting{
                    /**
                     * Creates the sparkline settings.
                     * @param {object} setting The settings.
                     * @class
                     */
                    constructor(setting?:  ISparklineSetting);
                    /**
                     * Indicates the options for the sparkline.<br />
                     * options.axisColor {string} the color of the axis<br />
                     * options.firstMarkerColor {string} the color of the first data point for each sparkline in this sparkline group<br />
                     * options.highMarkerColor {string} the color of the highest data point for each sparkline in this sparkline group<br />
                     * options.lastMarkerColor {string} the color of the last data point for each sparkline in this sparkline group<br />
                     * options.lowMarkerColor {string} the color of the lowest data point for each sparkline in this sparkline group<br />
                     * options.markersColor {string} a value that specifies the color of the data markers for each sparkline in this sparkline group<br />
                     * options.negativeColor {string} a value that specifies the color of the negative data points for each sparkline in this sparkline group<br />
                     * options.seriesColor {string} a value that specifies the color for each sparkline in this sparkline group<br />
                     * options.displayEmptyCellsAs {GC.Spread.Sheets.Sparklines.EmptyValueStyle} Indicates how to display the empty cells<br />
                     * options.rightToLeft {boolean} Indicates whether each sparkline in the sparkline group is displayed in a right-to-left manner<br />
                     * options.displayHidden {boolean} Indicates whether data in hidden cells is plotted for the sparklines in this sparkline group<br />
                     * options.displayXAxis {boolean} Indicates whether the horizontal axis is displayed for each sparkline in this sparkline group<br />
                     * options.showFirst {boolean} a value that indicates whether the first data point is formatted differently for each sparkline in this sparkline group<br />
                     * options.showHigh {boolean} a value that specifies whether the data points with the highest value are formatted differently for each sparkline in this sparkline group<br />
                     * options.showLast {boolean} a value that indicates whether the last data point is formatted differently for each sparkline in this sparkline group<br />
                     * options.showLow {boolean} a value that specifies whether the data points with the lowest value are formatted differently for each sparkline in this sparkline group<br />
                     * options.showNegative {boolean} a value that specifies whether the negative data points are formatted differently for each sparkline in this sparkline group<br />
                     * options.showMarkers {boolean} a value that specifies whether data markers are displayed for each sparkline in this sparkline group<br />
                     * options.manualMax {number} Indicates the maximum for the vertical axis that is shared across all sparklines in this sparkline group. The axis is zero if maxAxisType does not equal custom<br />
                     * options.manualMin {number} Indicates the minimum for the vertical axis that is shared across all sparklines in this sparkline group. The axis is zero if minAxisType does not equal custom<br />
                     * options.maxAxisType {GC.Spread.Sheets.Sparklines.SparklineAxisMinMax} Indicates how the vertical axis maximum is calculated for the sparklines in this sparkline group<br />
                     * options.minAxisType {GC.Spread.Sheets.Sparklines.SparklineAxisMinMax} Indicates how the vertical axis minimum is calculated for the sparklines in this sparkline group<br />
                     * options.groupMaxValue {number} Gets the maximum value of the sparkline group<br />
                     * options.groupMinValue {number} Gets the minimum value of the sparkline group<br />
                     * options.lineWeight {number} Indicates the line weight for each sparkline in the sparkline group, where the line weight is measured in points. The weight must be greater than or equal to zero, and must be less than or equal to 3 (LineSeries only supports line weight values in the range of 0.0-3.0)
                     * @example
                     * var data = new GC.Spread.Sheets.Range(1, 0, 8, 1);
                     * var setting = new GC.Spread.Sheets.Sparklines.SparklineSetting();
                     * setting.options.showMarkers = true;
                     * setting.options.lineWeight = 3;
                     * setting.options.displayXAxis = true;
                     * setting.options.showFirst = true;
                     * setting.options.showLast = true;
                     * setting.options.showLow = true;
                     * setting.options.showHigh = true;
                     * setting.options.showNegative = true;
                     * setting.options.seriesColor = "Text 2 1";
                     * setting.options.firstMarkerColor = "Text 2 3";
                     * setting.options.negativeColor = "Accent 2 1";
                     * setting.options.markersColor = "Accent 3 1";
                     * setting.options.lowMarkerColor = "Accent 4 1";
                     * setting.options.highMarkerColor = "Accent 6 1";
                     * setting.options.lastMarkerColor = "Accent 6 6";
                     * setting.options.axisColor ="Text 1 1";
                     * sheet.addSpan(13, 0, 4, 3, null);
                     * sheet.setSparkline(13, 0, data, GC.Spread.Sheets.Sparklines.DataOrientation.Vertical, GC.Spread.Sheets.Sparklines.SparklineType.line, setting);
                     * sheet.setValue(1, 0, 1);
                     * sheet.setValue(2, 0, -2);
                     * sheet.setValue(3, 0, -1);
                     * sheet.setValue(4, 0, 6);
                     * sheet.setValue(5, 0, 4);
                     * sheet.setValue(6, 0, -4);
                     * sheet.setValue(7, 0, 3);
                     */
                    options: Object;
                    /**
                     * Clones sparkline settings.
                     * @returns {GC.Spread.Sheets.Sparklines.SparklineSetting} The cloned sparkline setting.
                     */
                    clone(): GC.Spread.Sheets.Sparklines.SparklineSetting;
                }

                export class SpreadSparkline extends SparklineEx{
                    /**
                     * Represents the class for the Spread sparkline.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class StackedSparkline extends SparklineEx{
                    /**
                     * Represents the class for the stacked sparkline.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class VariSparkline extends SparklineEx{
                    /**
                     * Represents the class for the variance sparkline.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class VBarSparkline extends SparklineEx{
                    /**
                     * Represents the class for the Vbar sparkline.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class WinlossSparkline extends SparklineEx{
                    /**
                     * Represents the class for the winloss sparkline.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class YearSparkline extends SparklineEx{
                    /**
                     * Represents the class for the year sparkline.
                     * @extends GC.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }
            }

            module StatusBar{

                export class StatusBar{
                    /**
                     * Represents status bar.
                     * @class
                     * @param {Object} host The DOM Element.
                     * @param {Object} [options]
                     * @param {Array<GC.Spread.Sheets.StatusBar.StatusItem>} [options.items] The array of StatusItem.
                     * @example
                     * var statusBar = new GC.Spread.Sheets.StatusBar.StatusBar(document.getElementById('statusBar'),
                     *   {items: [new GC.Spread.Sheets.StatusBar.StatusItem('labelItem', {menuContent: 'label'})]});
                     */
                    constructor(host:  HTMLElement,  options?:  Object);
                    /**
                     * Add the item instance to the StatusBar.
                     * @param {GC.Spread.Sheets.StatusBar.StatusItem} item The instance of the child of StatusItem. The child extends from StatusItem.
                     * @param {number} position The position is items index in all items array. Start from 0. Items display position is also related to align. If position is invalid or undefine, place it by default.
                     * @returns {boolean} Add item result. Return true if add success, else failed.
                     * @example
                     * var StatusItem = GC.Spread.Sheets.StatusBar.StatusItem;
                     * var spanItem = new StatusItem('spanItemName', {menuContent: 'span', value: 'spanValue'});
                     * var spread = new GC.Spread.Sheets.Workbook(document.getElementById("ss"));
                     * var statusBar = new GC.Spread.Sheets.StatusBar.StatusBar(document.getElementById('statusBar'));
                     * statusBar.bind(spread);
                     * statusBar.add(spanItem);
                     */
                    add(item:  GC.Spread.Sheets.StatusBar.StatusItem,  position:  number): boolean;
                    /**
                     * Get all item list.
                     * @returns {GC.Spread.Sheets.StatusBar.StatusItem[]} The item list on statusbar.
                     * @example
                     * var spread = new GC.Spread.Sheets.Workbook(document.getElementById("ss"));
                     * var statusBar = new GC.Spread.Sheets.StatusBar.StatusBar(document.getElementById('statusBar'));
                     * statusBar.bind(spread);
                     * var itemList = statusBar.all();
                     * statusBar.remove(itemList[0]);
                     */
                    all(): GC.Spread.Sheets.StatusBar.StatusItem[];
                    /**
                     * Bind the context of the StatusBar.
                     * @param {Object} context The context of the StatusBar. The context can trigger the status change of StatusBar. Here the context is the instance of GC.Spread.Sheets.Workbook.
                     * @example
                     * var spread = new GC.Spread.Sheets.Workbook(document.getElementById("ss"));
                     * var statusBar = new GC.Spread.Sheets.StatusBar.StatusBar(document.getElementById('statusBar'));
                     * statusBar.bind(spread);
                     */
                    bind(context:  GC.Spread.Sheets.Workbook): void;
                    /**
                     * Dispose the StatusBar and unbind all events.
                     * @example
                     * var spread = new GC.Spread.Sheets.Workbook(document.getElementById("ss"));
                     * var statusBar = new GC.Spread.Sheets.StatusBar.StatusBar(document.getElementById('statusBar'));
                     * statusBar.bind(spread);
                     * // do something
                     * statusBar.dispose();
                     */
                    dispose(): void;
                    /**
                     * Get the item by item name.
                     * @param {string} itemName
                     * @returns {GC.Spread.Sheets.StatusBar.StatusItem} The StatusItem whose itemName is specified.
                     * @example
                     * var StatusItem = GC.Spread.Sheets.StatusBar.StatusItem;
                     * var spanItemName = 'spanItemName';
                     * var spanItem = new StatusItem(spanItemName, {menuContent: 'span', value: 'spanValue'});
                     * var spread = new GC.Spread.Sheets.Workbook(document.getElementById("ss"));
                     * var statusBar = new GC.Spread.Sheets.StatusBar.StatusBar(document.getElementById('statusBar'));
                     * statusBar.bind(spread);
                     * statusBar.add(spanItem);
                     * var spanItemInstance = statusBar.get(spanItemName);
                     */
                    get(itemName:  string): GC.Spread.Sheets.StatusBar.StatusItem;
                    /**
                     * Remove the item from the StatusBar.
                     * @param {string} itemName The name of the StatusItem.
                     * @returns {boolean} If true means remove success, else failed.
                     * @example
                     * var StatusItem = GC.Spread.Sheets.StatusBar.StatusItem;
                     * var spanItemName = 'spanItemName';
                     * var spanItem = new StatusItem(spanItemName, {menuContent: 'span', value: 'spanValue'});
                     * var spread = new GC.Spread.Sheets.Workbook(document.getElementById("ss"));
                     * var statusBar = new GC.Spread.Sheets.StatusBar.StatusBar(document.getElementById('statusBar'));
                     * statusBar.bind(spread);
                     * statusBar.add(spanItem);
                     * // do something
                     * statusBar.remove(spanItemName);
                     */
                    remove(itemName:  string): boolean;
                    /**
                     * Unbind the context of the StatusBar.
                     * @example
                     * var spread = new GC.Spread.Sheets.Workbook(document.getElementById("ss"));
                     * var statusBar = new GC.Spread.Sheets.StatusBar.StatusBar(document.getElementById('statusBar'));
                     * statusBar.bind(spread);
                     * // do something
                     * statusBar.unbind();
                     */
                    unbind(): void;
                    /**
                     * Update the StatusBar.
                     * @example
                     * var spread = new GC.Spread.Sheets.Workbook(document.getElementById("ss"));
                     * var statusBar = new GC.Spread.Sheets.StatusBar.StatusBar(document.getElementById('statusBar'));
                     * statusBar.update();
                     */
                    update(): void;
                }

                export class StatusItem{
                    /**
                     * The base class of status item provides basic value display and related context menu item function.
                     * @class
                     * @param {string} name - The name is the Unique identifier and needed in context menu and statusbar.
                     * @param {Object} options - The object of status item options.
                     * @param {string} [options.menuContent] - The menuContent displayed left on context menu which represent current item.
                     * @param {string} [options.align] - Control the item alignment on statusbar. The value is 'left' or 'right'.
                     * @param {string} [options.tipText] - The tip text displayed when mouse over the item. Show the description for the item.
                     * @param {boolean} [options.visible] - 1.The visibility of current item on statusbar. 2.The checked status of current item on context menu.
                     * @param {boolean} [options.showStatusInContexMenu] - Whether show the status on right of context menu.
                     * @param {any} [options.value] - The value displayed on status bar and on right of context menu to represent the status of current item.
                     * @example
                     * var StatusItem = GC.Spread.Sheets.StatusBar.StatusItem;
                     * var labelItem = new StatusItem('labelItem', {menuContent: 'label', value: 'text'});
                     */
                    constructor(name:  string,  options?:  Object);
                    /**
                     * Bind the Context. Can override to add context related event listener.
                     * @override
                     * @param {Object} context The excute context for the statusbar item.
                     * @example
                     * LabelItem.prototype.onBind = function (context) {
                     *   // do something about context.
                     * }
                     */
                    onBind(context:  GC.Spread.Sheets.Workbook): void;
                    /**
                     * Create the item element on statusbar. Can override for customize item.
                     * @override
                     * @param {HTMLElement} container
                     * @example
                     * var StatusItem = GC.Spread.Sheets.StatusBar.StatusItem;
                     * function LabelItem (name, options) {
                     *   StatusItem.call(this, name, options);
                     * }
                     * LabelItem.prototype = new StatusItem();
                     * LabelItem.prototype.onCreateItemView = function (container) {
                     *   var item = document.createElement('div');
                     *   item.innerText = this.value;
                     *   container.appendChild(item);
                     *   // add event listener for container
                     * }
                     * statusBar.add(new LabelItem('labelItem', {menuContent: 'label', value: 'options test'}));
                     */
                    onCreateItemView(container:  HTMLElement): void;
                    /**
                     * Dispose the statusbar to unbind context, remove all listener and dispose all element.
                     * @override
                     * @example
                     * var StatusItem = GC.Spread.Sheets.StatusBar.StatusItem;
                     * function LabelItem (name, options) {
                     *   StatusItem.call(this, name, options);
                     * }
                     * LabelItem.prototype = new StatusItem();
                     * LabelItem.prototype.onDispose = function () {
                     *   // dispose current item.
                     *   // then call super dispose.
                     *   StatusItem.prototype.onDispose.call(this);
                     * }
                     */
                    onDispose(): void;
                    /**
                     * Unbind the Context. Can override to remove context related event listener.
                     * @override
                     * @example
                     * LabelItem.prototype.onUnbind = function () {
                     *   // remove event listener related to context.
                     * }
                     */
                    onUnbind(): void;
                    /**
                     * The callback for status bar update. Called when status bar bind or update function, or status bar check changed in context menu.
                     * The update related operations can realize in it. Users also should call onUpdate when current item need update.
                     * The default operations in super is update current item by visible.
                     * @override
                     * @example
                     * var StatusItem = GC.Spread.Sheets.StatusBar.StatusItem;
                     * function LabelItem (name, options) {
                     *   StatusItem.call(this, name, options);
                     * }
                     * LabelItem.prototype = new StatusItem();
                     * LabelItem.prototype.onUpdate = function () {
                     *   StatusItem.prototype.onUpdate.call(this);
                     *   // update item.
                     */
                    onUpdate(): void;
                }
            }

            module Tables{
                /**
                 * Specifies what data is kept when removing the table.
                 * @enum {number}
                 * @example
                 * activeSheet.tables.add("Table1", 0, 0, 3, 3, GC.Spread.Sheets.Tables.TableThemes.dark1);
                 * activeSheet.getCell(0,0).text("Name");
                 * activeSheet.getCell(0,1).text("Value");
                 * activeSheet.getCell(0,2).text("T/F");
                 * activeSheet.getCell(1,0).text("AW");
                 * activeSheet.getCell(1,1).text("5");
                 * activeSheet.getCell(1,2).text("T");
                 * //button click
                 * $("#button1").click(function () {
                 *      var table  = activeSheet.tables.find(0,0);
                 *      activeSheet.tables.remove(table, GC.Spread.Sheets.Tables.TableRemoveOptions.keepData);
                 * });
                 */
                export enum TableRemoveOptions{
                    /**
                     *  Removes data and styles.
                     */
                    none= 0,
                    /**
                     *  Keeps values.
                     */
                    keepData= 1,
                    /**
                     *  Keeps styles.
                     */
                    keepStyle= 2
                }


                export class Table{
                    /**
                     * Represents a table that can be added in a sheet.
                     * @class
                     * @param {string} name The table name.
                     * @param {number} row The table row index.
                     * @param {number} col The table column index.
                     * @param {number} rowCount The table row count.
                     * @param {number} colCount The table column count.
                     * @param {GC.Spread.Sheets.Tables.TableTheme} style The table style.
                     * @param {Object} options The initialization options of the table.
                     * @param {boolean} [options.showHeader] - Whether to display a header.
                     * @param {boolean} [options.showFooter] - Whether to display a footer.
                     */
                    constructor(name?:  string,  row?:  number,  col?:  number,  rowCount?:  number,  colCount?:  number,  style?:  GC.Spread.Sheets.Tables.TableTheme);
                    /**
                     * Gets or sets whether to generate columns automatically while binding to a data source.
                     * @param {boolean} value Whether to generate columns automatically while binding to a data source.
                     * @returns {boolean | GC.Spread.Sheets.Tables.Table} If no value is set, returns whether to generate columns automatically while binding to a data source; otherwise, returns the table.
                     */
                    autoGenerateColumns(value?:  boolean): any;
                    /**
                     * Gets or sets a value that indicates whether to display an alternating column style.
                     * @param {boolean} value Whether to display an alternating column style.
                     * @returns {boolean | GC.Spread.Sheets.Tables.Table} If no value is set, returns whether to display an alternating column style; otherwise, returns the table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GC.Spread.Sheets.Tables.TableThemes.medium2);
                     * sTable.bandColumns(true);
                     * sTable.bandRows(true);
                     */
                    bandColumns(value?:  boolean): any;
                    /**
                     * Gets or sets a value that indicates whether to display an alternating row style.
                     * @param {boolean} value Whether to display an alternating row style.
                     * @returns {boolean | GC.Spread.Sheets.Tables.Table} If no value is set, returns whether to display an alternating row style; otherwise, returns the table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GC.Spread.Sheets.Tables.TableThemes.medium2);
                     * sTable.bandColumns(true);
                     * sTable.bandRows(true);
                     */
                    bandRows(value?:  boolean): any;
                    /**
                     * Binds the columns using the specified data fields.
                     * @param {Array} columns The array of table column information with data fields and names. Each item is GC.Spread.Sheets.Tables.TableColumn.
                     */
                    bindColumns(columns:  any[]): void;
                    /**
                     * Gets or sets the binding path for cell-level binding in the table.
                     * @param {string} value The binding path for cell-level binding in the table.
                     * @returns {string | GC.Spread.Sheets.Tables.Table} If no value is set, returns the binding path for cell-level binding in the table; otherwise, returns the table.
                     */
                    bindingPath(value?:  string): any;
                    /**
                     * Gets the cell range for the table data area.
                     * @returns {GC.Spread.Sheets.Range} The table data range.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GC.Spread.Sheets.Tables.TableTheme.medium2);
                     * var drange = sTable.dataRange();
                     * alert(drange.row);
                     */
                    dataRange(): GC.Spread.Sheets.Range;
                    /**
                     * Gets or sets whether the table column's filter button is displayed.
                     * @param {number} tableColumnIndex The table column index of the filter button.
                     * @param {boolean} value Whether the table column's filter button is displayed.
                     * @returns {boolean} The table column's filter button display state.
                     * @returns {boolean | GC.Spread.Sheets.Tables.Table}
                     *  If no parameter is set, returns <c>false</c> if all filter buttons are invisible, otherwise, <c>true</c>.
                     *  If only a number is set, returns whether the specified table column' filter button is displayed.
                     *  If only a boolean that indicates whether to display filter buttons is set, applies to all filter buttons and returns the table.
                     *  If two parameters are provided, applies to the specified table columns' filter button and returns the table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GC.Spread.Sheets.Tables.TableTheme.medium2);
                     * sTable.bandColumns(true);
                     * sTable.bandRows(true);
                     * sTable.filterButtonVisible(2, false);
                     * alert(sTable.filterButtonVisible(2));
                     */
                    filterButtonVisible(tableColumnIndex?:  number,  value?:  boolean): any;
                    /**
                     * Gets the footer index in the sheet.
                     * @returns {number} The footer index.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GC.Spread.Sheets.Tables.TableTheme.medium2);
                     * sTable.showFooter(true);
                     * sTable.setColumnName(4, "SUM");
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     * var value = sTable.footerIndex();
                     * alert(value);
                     */
                    footerIndex(): number;
                    /**
                     * Gets the table footer formula with the specified index.
                     * @param {number} tableColumnIndex The column index of the table footer. The index is zero-based.
                     * @returns {string} The table footer formula.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GC.Spread.Sheets.Tables.TableTheme.medium2);
                     * sTable.showFooter(true);
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     * var value = sTable.getColumnFormula(4);
                     * alert(value);
                     */
                    getColumnFormula(tableColumnIndex:  number): string;
                    /**
                     * Gets the table header text with the specified table index.
                     * @param {number} tableColumnIndex The column index of the table header. The index is zero-based.
                     * @returns {string} The header text of the specified column by index.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GC.Spread.Sheets.Tables.TableTheme.medium2);
                     * sTable.showFooter(true);
                     * sTable.setColumnName(4, "SUM");
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     * var value = sTable.getColumnName(4);
                     * alert(value);
                     */
                    getColumnName(tableColumnIndex:  number): any;
                    /**
                     * Gets the table footer value with the specified index.
                     * @param {number} tableColumnIndex The column index of the table footer. The index is zero-based.
                     * @returns {string} The table footer value.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GC.Spread.Sheets.Tables.TableTheme.medium2);
                     * sTable.showFooter(true);
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     * var value = sTable.getColumnValue(0);
                     * alert(value);
                     */
                    getColumnValue(tableColumnIndex:  number): string;
                    /**
                     * Gets the header index in the sheet.
                     * @returns {number} The header index.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GC.Spread.Sheets.Tables.TableTheme.medium2);
                     * var hindex = sTable.headerIndex();
                     * alert(hindex);
                     */
                    headerIndex(): number;
                    /**
                     * Gets or sets a value that indicates whether to highlight the first column.
                     * @param {boolean} value Whether to highlight the first column.
                     * @returns {boolean | GC.Spread.Sheets.Tables.Table} If no value is set, returns whether to highlight the first column; otherwise, returns the table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GC.Spread.Sheets.Tables.TableThemes.medium2);
                     * sTable.highlightFirstColumn(true);
                     * sTable.highlightLastColumn(true);
                     */
                    highlightFirstColumn(value?:  boolean): any;
                    /**
                     * Gets or sets a value that indicates whether to highlight the last column.
                     * @param {boolean} value Whether to highlight the last column.
                     * @returns {boolean | GC.Spread.Sheets.Tables.Table} If no value is set, returns whether to highlight the last column; otherwise, returns the table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GC.Spread.Sheets.Tables.TableThemes.medium2);
                     * sTable.highlightFirstColumn(true);
                     * sTable.highlightLastColumn(true);
                     */
                    highlightLastColumn(value?:  boolean): any;
                    /**
                     * Gets or sets the table name.
                     * @param {string} value The table name.
                     * @returns {string | GC.Spread.Sheets.Tables.Table} If no value is set, returns the table name; otherwise, returns the table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GC.Spread.Sheets.Tables.TableTheme.medium2);
                     * var tname = sTable.name();
                     * alert(tname);
                     */
                    name(value?:  string): any;
                    /**
                     * Gets the range for the entire table.
                     * @returns {GC.Spread.Sheets.Range} The whole table range.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GC.Spread.Sheets.Tables.TableTheme.medium2);
                     * var drange = sTable.range();
                     * alert(drange.row);
                     */
                    range(): GC.Spread.Sheets.Range;
                    /**
                     * Gets the row filter for the table.
                     * @returns {GC.Spread.Sheets.Filter.HideRowFilter} The row filter.
                     */
                    rowFilter(): GC.Spread.Sheets.Filter.HideRowFilter;
                    /**
                     * Sets a formula to the table's data range with the specified index.
                     * @param {number} tableColumnIndex The column index of the table. The index is zero-based.
                     * @param {string} formula The data range formula.
                     * @returns {GC.Spread.Sheets.Tables.Table} The table.
                     * @example
                     * //This example uses a structured reference formula in the table.
                     * activeSheet.tables.add("Table1", 0, 0, 4, 3, GC.Spread.Sheets.Tables.TableTheme.dark1);
                     * activeSheet.getCell(0,0).text("Value1");
                     * activeSheet.getCell(0,1).text("Value2");
                     * activeSheet.getCell(0,2).text("Total");
                     * activeSheet.getCell(1,0).text("1");
                     * activeSheet.getCell(2,0).text("2");
                     * activeSheet.getCell(3,0).text("3");
                     * activeSheet.getCell(1,1).text("5");
                     * activeSheet.getCell(2,1).text("5");
                     * activeSheet.getCell(3,1).text("5");
                     * activeSheet.tables.findByName("Table1").setColumnDataFormula(2, "=[Value1]*[Value2]");
                     */
                    setColumnDataFormula(tableColumnIndex:  number,  formula:  string): GC.Spread.Sheets.Tables.Table;
                    /**
                     * Sets the table footer formula with the specified index.
                     * @param {number} tableColumnIndex The column index of the table footer. The index is zero-based.
                     * @param {string} formula The table footer formula.
                     * @returns {GC.Spread.Sheets.Tables.Table} The table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GC.Spread.Sheets.Tables.TableThemes.medium2);
                     * sTable.showFooter(true);
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     */
                    setColumnFormula(tableColumnIndex:  number,  formula:  string): GC.Spread.Sheets.Tables.Table;
                    /**
                     * Sets the table header text with the specified table index.
                     * @param {string} tableColumnIndex The column index of the table header. The index is zero-based.
                     * @param {string} name The header text.
                     * @returns {GC.Spread.Sheets.Tables.Table} The table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GC.Spread.Sheets.Tables.TableThemes.medium2);
                     * sTable.showFooter(true);
                     * sTable.setColumnName(4, "SUM");
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     */
                    setColumnName(tableColumnIndex:  number,  name:  string): GC.Spread.Sheets.Tables.Table;
                    /**
                     * Sets the table footer value with the specified index.
                     * @param {number} tableColumnIndex The column index of the table footer. The index is zero-based.
                     * @param {Object} value The table footer value.
                     * @returns {GC.Spread.Sheets.Tables.Table} The table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GC.Spread.Sheets.Tables.TableThemes.medium2);
                     * sTable.showFooter(true);
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     */
                    setColumnValue(tableColumnIndex:  number,  value:  Object): GC.Spread.Sheets.Tables.Table;
                    /**
                     * Gets or sets a value that indicates whether to display a footer.
                     * @param {boolean} value Whether to display a footer.
                     * @returns {boolean | GC.Spread.Sheets.Tables.Table} If no value is set, returns whether to display a footer; otherwise, returns the table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GC.Spread.Sheets.Tables.TableThemes.medium2);
                     * sTable.showFooter(true);
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     */
                    showFooter(value?:  boolean): any;
                    /**
                     * Gets or sets a value that indicates whether to display a header.
                     * @param {boolean} value Whether to display a header.
                     * @returns {boolean | GC.Spread.Sheets.Tables.Table} If no value is set, returns whether to display a header; otherwise, returns the table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GC.Spread.Sheets.Tables.TableThemes.medium2);
                     * sTable.showHeader(true);
                     */
                    showHeader(value?:  boolean): any;
                    /**
                     * Gets or sets a style for the table.
                     * @param {GC.Spread.Sheets.Tables.TableTheme} value The style for the table.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme | GC.Spread.Sheets.Tables.Table} If no value is set, returns the table style; otherwise, returns the table.
                     */
                    style(value?:  GC.Spread.Sheets.Tables.TableTheme): any;
                }

                export class TableColumn{
                    /**
                     * Represents the table column information.
                     * @class
                     * @param {string} id The table column ID.
                     */
                    constructor(id:  string);
                    /**
                     * Gets or sets the table column data field for accessing the table's data source.
                     * @param {string} value The table column data field.
                     * @returns {string | GC.Spread.Sheets.Tables.TableColumn} If no value is set, returns the table column data field; otherwise, returns the table column.
                     */
                    dataField(value?:  string): any;
                    /**
                     * Gets or sets the table column ID.
                     * @param {number} value The table column ID.
                     * @returns {number | GC.Spread.Sheets.Tables.TableColumn} If no value is set, returns the table column ID; otherwise, returns the table column.
                     */
                    id(value?:  number): any;
                    /**
                     * Gets or sets the table column name for display.
                     * @param {string} value The table column name.
                     * @returns {string | GC.Spread.Sheets.Tables.TableColumn} If no value is set, returns the table column name; otherwise, returns the table column.
                     */
                    name(value?:  string): any;
                }

                export class TableManager{
                    /**
                     * Represents a table manager that can manage all tables in a sheet.
                     * @class
                     * @param {GC.Spread.Sheets.Worksheet} sheet The worksheet.
                     */
                    constructor(sheet:  GC.Spread.Sheets.Worksheet);
                    /**
                     * Adds a range table with a specified size to the sheet.
                     * @param {string} name The table name.
                     * @param {number} row The row index.
                     * @param {number} column The column index.
                     * @param {number} rowCount The row count of the table.
                     * @param {number} columnCount The column count of the table.
                     * @param {GC.Spread.Sheets.Tables.TableTheme} style The style of the table.
                     * @param {Object} options The initialization options of the table.
                     * @param {boolean} [options.showHeader] - Whether to display a header.
                     * @param {boolean} [options.showFooter] - Whether to display a footer.
                     * @returns {GC.Spread.Sheets.Tables.Table} The new table instance.
                     * @example
                     * //This example adds a table.
                     * activeSheet.tables.add("Table1", 0, 0, 3, 3, GC.Spread.Sheets.Tables.TableThemes.dark1);
                     * activeSheet.getCell(0,0).text("Name");
                     * activeSheet.getCell(0,1).text("Value");
                     * activeSheet.getCell(0,2).text("T/F");
                     * activeSheet.getCell(1,0).text("AW");
                     * activeSheet.getCell(1,1).text("5");
                     * activeSheet.getCell(1,2).text("T");
                     */
                    add(name?:  string,  row?:  number,  column?:  number,  rowCount?:  number,  columnCount?:  number,  style?:  GC.Spread.Sheets.Tables.TableTheme): GC.Spread.Sheets.Tables.Table;
                    /**
                     * Adds a range table with a specified data source to the sheet.
                     * @param {string} name The table name.
                     * @param {number} row The row index.
                     * @param {number} column The column index.
                     * @param {object} dataSource The data source for the table.
                     * @param {GC.Spread.Sheets.Tables.TableTheme} style The style of the table.
                     * @param {Object} options The initialization options of the table.
                     * @param {boolean} [options.showHeader] - Whether to display a header.
                     * @param {boolean} [options.showFooter] - boolean Whether to display a footer.
                     * @returns {GC.Spread.Sheets.Tables.Table} The new table instance.
                     * @example
                     * var source = [
                     *                 { LastName: "Freehafer", FirstName: "Nancy", Title: "Sales Representative", Phone: "(123)555-0100"},
                     *                 { LastName: "Cencini", FirstName: "Andrew", Title: "Vice President, Sales", Phone: "(123)555-0101"},
                     *                 { LastName: "Kotas", FirstName: "Jan", Title: "Sales Representative", Phone: "(123)555-0102"},
                     *                 { LastName: "Sergienko", FirstName: "Mariya", Title: "Sales Representative", Phone: "(123)555-0103"},
                     *             ];
                     *  activeSheet.tables.addFromDataSource("Table1", 5, 2, source, GC.Spread.Sheets.Tables.TableThemes.dark1);
                     */
                    addFromDataSource(name:  string,  row:  number,  column:  number,  dataSource:  Object,  style:  GC.Spread.Sheets.Tables.TableTheme): GC.Spread.Sheets.Tables.Table;
                    /**
                     * Gets all tables of the sheet.
                     * @returns {Array} The GC.Spread.Sheets.Tables.Table array of table instances. The array is never null.
                     */
                    all(): GC.Spread.Sheets.Tables.Table[];
                    /**
                     * Gets the table of the specified cell.
                     * @param {number} row The row index.
                     * @param {number} column The column index.
                     * @returns {GC.Spread.Sheets.Tables.Table} The table instance if the cell belongs to a table; otherwise, <c>null</c>.
                     * @example
                     * //This example uses the find method.
                     * activeSheet.tables.add("Table1", 0, 0, 3, 3, GC.Spread.Sheets.Tables.TableThemes.dark1);
                     * activeSheet.getCell(0,0).text("Name");
                     * activeSheet.getCell(0,1).text("Value");
                     * activeSheet.getCell(0,2).text("T/F");
                     * activeSheet.getCell(1,0).text("AW");
                     * activeSheet.getCell(1,1).text("5");
                     * activeSheet.getCell(1,2).text("T");
                     * //button click
                     * $("#button1").click(function () {
                     *      var table  = activeSheet.tables.find(0,0);
                     *      activeSheet.tables.move(table, 3, 3);
                     * });
                     */
                    find(row:  number,  column:  number): GC.Spread.Sheets.Tables.Table;
                    /**
                     * Gets the table with a specified name.
                     * @param {string} name The table name.
                     * @returns {GC.Spread.Sheets.Tables.Table} The table instance if the cell belongs to a table; otherwise, <c>null</c>.
                     * @example
                     * //This example finds the table by name.
                     * var activeSheet = spread.getActiveSheet();
                     * activeSheet.tables.add("Table1", 0, 0, 3, 3, GC.Spread.Sheets.Tables.TableThemes.dark1);
                     * activeSheet.getCell(0,0).text("Name");
                     * activeSheet.getCell(0,1).text("Value");
                     * activeSheet.getCell(0,2).text("T/F");
                     * activeSheet.getCell(1,0).text("AW");
                     * activeSheet.getCell(1,1).text("5");
                     * activeSheet.getCell(1,2).text("T");
                     * // button click
                     * $("#button1").click(function () {
                     *      var table  = activeSheet.tables.findByName("Table1");
                     *      alert(table);
                     *      activeSheet.tables.move(table, 3, 3);
                     * });
                     */
                    findByName(name:  string): GC.Spread.Sheets.Tables.Table;
                    /**
                     * Changes the table location.
                     * @param {GC.Spread.Sheets.Tables.Table|string} table The table instance or the table name.
                     * @param {number} row The new row index.
                     * @param {number} column The new column index.
                     * @example
                     * var activeSheet = spread.getActiveSheet();
                     * activeSheet.tables.add("Table1", 0, 0, 3, 3, GC.Spread.Sheets.Tables.TableThemes.dark1);
                     * activeSheet.getCell(0,0).text("Name");
                     * activeSheet.getCell(0,1).text("Value");
                     * activeSheet.getCell(0,2).text("T/F");
                     * activeSheet.getCell(1,0).text("AW");
                     * activeSheet.getCell(1,1).text("5");
                     * activeSheet.getCell(1,2).text("T");
                     * // button click
                     * $("#button1").click(function () {
                     *      var table  = activeSheet.tables.findByName("Table1");
                     *      alert(table);
                     *      activeSheet.tables.move(table, 3, 3);
                     * });
                     */
                    move(table:  GC.Spread.Sheets.Tables.Table,  row:  number,  column:  number): void;
                    /**
                     * Removes a specified table.
                     * @param {GC.Spread.Sheets.Tables.Table|string} table The table instance or the table name.
                     * @param {GC.Spread.Sheets.Tables.TableRemoveOptions} options Specifies what data is kept when removing the table.
                     * @example
                     * var table  = activeSheet.tables.find(0,0);
                     * activeSheet.tables.remove(table, GC.Spread.Sheets.Tables.TableRemoveOptions.keepData);
                     */
                    remove(table:  GC.Spread.Sheets.Tables.Table,  options:  GC.Spread.Sheets.Tables.TableRemoveOptions): void;
                    /**
                     * Changes the table size.
                     * @param {GC.Spread.Sheets.Tables.Table|string} table The table or the table name.
                     * @param {GC.Spread.Sheets.Range} range The new table range. The headers must remain in the same row, and the resulting table range must overlap the original table range.
                     * @example
                     * //This example resizes the table.
                     * activeSheet.tables.add("Table1", 0, 0, 3, 3, GC.Spread.Sheets.Tables.TableThemes.dark1);
                     * activeSheet.getCell(0,0).text("Name");
                     * activeSheet.getCell(0,1).text("Value");
                     * activeSheet.getCell(0,2).text("T/F");
                     * activeSheet.getCell(1,0).text("AW");
                     * activeSheet.getCell(1,1).text("5");
                     * activeSheet.getCell(1,2).text("T");
                     * //button click
                     * $("#button1").click(function () {
                     *      var table  = activeSheet.tables.find(0,0);
                     *      activeSheet.tables.resize(table, new GC.Spread.Sheets.Range(0,0,4,4));
                     * });
                     */
                    resize(table:  GC.Spread.Sheets.Tables.Table,  range:  GC.Spread.Sheets.Range): void;
                }

                export class TableStyle{
                    /**
                     * Represents table style information.
                     * @class
                     * @param {string} backColor The background color of the table.
                     * @param {string} foreColor The foreground color of the table.
                     * @param {string} font The font.
                     * @param {GC.Spread.Sheets.LineBorder} borderLeft The left border line of the table.
                     * @param {GC.Spread.Sheets.LineBorder} borderTop The top border line of the table.
                     * @param {GC.Spread.Sheets.LineBorder} borderRight The right border line of the table.
                     * @param {GC.Spread.Sheets.LineBorder} borderBottom The bottom border line of the table.
                     * @param {GC.Spread.Sheets.LineBorder} borderHorizontal The horizontal border line of the table.
                     * @param {GC.Spread.Sheets.LineBorder} borderVertical The vertical border line of the table.
                     * @param {GC.Spread.Sheets.TextDecorationType} textDecoration The text decoration of the table.
                     * @example
                     * //This example creates a table.
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tableStyleInfo = new GC.Spread.Sheets.Tables.TableStyle(
                     *     "black",
                     *     "white",
                     *     "bold 11pt arial",
                     *     new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin),
                     *     new GC.Spread.Sheets.LineBorder("red", GC.Spread.Sheets.LineStyle.thick),
                     *     new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.thin),
                     *     new GC.Spread.Sheets.LineBorder("blue", GC.Spread.Sheets.LineStyle.thick));
                     * tableStyle.headerRowStyle(tableStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    constructor(backColor?:  string,  foreColor?:  string,  font?:  string,  borderLeft?:  GC.Spread.Sheets.LineBorder,  borderTop?:  GC.Spread.Sheets.LineBorder,  borderRight?:  GC.Spread.Sheets.LineBorder,  borderBottom?:  GC.Spread.Sheets.LineBorder,  borderHorizontal?:  GC.Spread.Sheets.LineBorder,  borderVertical?:  GC.Spread.Sheets.LineBorder,  textDecoration?:  GC.Spread.Sheets.TextDecorationType);
                    /**
                     * Indicates the background color.
                     * @type {string}
                     * @example
                     * //This example creates a table.
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.headerRowStyle(tStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    backColor: string;
                    /**
                     * Indicates the bottom border line of the table.
                     * @type {GC.Spread.Sheets.LineBorder}
                     * @example
                     * //This example creates a table.
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.headerRowStyle(tStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    borderBottom: GC.Spread.Sheets.LineBorder;
                    /**
                     * Indicates the horizontal border line of the table.
                     * @type {GC.Spread.Sheets.LineBorder}
                     * @example
                     * //This example sets the borderHorizontal property.
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderHorizontal = new GC.Spread.Sheets.LineBorder("red", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderVertical = new GC.Spread.Sheets.LineBorder("blue", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.firstRowStripStyle(tStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    borderHorizontal: GC.Spread.Sheets.LineBorder;
                    /**
                     * Indicates the left border line of the table.
                     * @type {GC.Spread.Sheets.LineBorder}
                     * @example
                     * //This example creates a table.
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.headerRowStyle(tStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    borderLeft: GC.Spread.Sheets.LineBorder;
                    /**
                     * Indicates the right border line of the table.
                     * @type {GC.Spread.Sheets.LineBorder}
                     * @example
                     * //This example creates a table.
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.headerRowStyle(tStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    borderRight: GC.Spread.Sheets.LineBorder;
                    /**
                     * Indicates the top border line of the table.
                     * @type {GC.Spread.Sheets.LineBorder}
                     * @example
                     * //This example creates a table.
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.headerRowStyle(tStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    borderTop: GC.Spread.Sheets.LineBorder;
                    /**
                     * Indicates the vertical border line of the table.
                     * @type {GC.Spread.Sheets.LineBorder}
                     * @example
                     * //This example sets the borderHorizontal property.
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderHorizontal = new GC.Spread.Sheets.LineBorder("red", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderVertical = new GC.Spread.Sheets.LineBorder("blue", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.firstRowStripStyle(tStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    borderVertical: GC.Spread.Sheets.LineBorder;
                    /**
                     * Indicates the font.
                     * @type {string}
                     * @example
                     * //This example creates a table.
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.headerRowStyle(tStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    font: string;
                    /**
                     * Indicates the foreground color.
                     * @type {string}
                     * @example
                     * //This example sets the borderHorizontal property.
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderHorizontal = new GC.Spread.Sheets.LineBorder("red", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderVertical = new GC.Spread.Sheets.LineBorder("blue", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.firstRowStripStyle(tStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    foreColor: string;
                    /**
                     * Indicates the text decoration of the table.
                     * @type {GC.Spread.Sheets.TextDecorationType}
                     */
                    textDecoration: GC.Spread.Sheets.TextDecorationType;
                }

                export class TableTheme{
                    /**
                     * Represents the table style settings.
                     * @class
                     * @example
                     * //This example creates a table.
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tableStyleInfo = new GC.Spread.Sheets.Tables.TableStyle(
                     *     "black",
                     *     "white",
                     *     "bold 11pt arial",
                     *     new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin),
                     *     new GC.Spread.Sheets.LineBorder("red", GC.Spread.Sheets.LineStyle.thick),
                     *     new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.thin),
                     *     new GC.Spread.Sheets.LineBorder("blue", GC.Spread.Sheets.LineStyle.thick));
                     * tableStyle.headerRowStyle(tableStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    constructor();
                    /**
                     * Gets or sets the size of the first alternating column.
                     * @param {number} value The size of the first alternating column.
                     * @returns {number | GC.Spread.Sheets.Tables.TableTheme} If no value is set, returns the size of the first alternating column; otherwise, returns the table theme.
                     * @example
                     * //This example creates a table.
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * //style
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.firstColumnStripSize(2);
                     * tableStyle.firstColumnStripStyle(tStyleInfo);
                     * var sTable = activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     * sTable.bandColumns(true);
                     */
                    firstColumnStripSize(value?:  number): any;
                    /**
                     * Gets or sets the style of the first alternating column.
                     * @param {GC.Spread.Sheets.Tables.TableStyle} value The style of the first alternating column.
                     * @returns {GC.Spread.Sheets.Tables.TableStyle | GC.Spread.Sheets.Tables.TableTheme} If no value is set, returns the style of the first alternating column; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.firstColumnStripSize(2);
                     * tableStyle.firstColumnStripStyle(tStyleInfo);
                     * var sTable = activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     * sTable.bandColumns(true);
                     */
                    firstColumnStripStyle(value?:  GC.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the style of the first footer cell.
                     * @param {GC.Spread.Sheets.Tables.TableStyle} value The style of the first footer cell.
                     * @returns {GC.Spread.Sheets.Tables.TableStyle | GC.Spread.Sheets.Tables.TableTheme} If no value is set, returns the style of the first footer cell; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.lastFooterCellStyle(tStyleInfo);
                     * tableStyle.firstFooterCellStyle(tStyleInfo);
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, tableStyle);
                     * sTable.showFooter(true);
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     * sTable.highlightFirstColumn(true);
                     * sTable.highlightLastColumn(true);
                     */
                    firstFooterCellStyle(value?:  GC.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the style of the first header cell.
                     * @param {GC.Spread.Sheets.Tables.TableStyle} value The style of the first header cell.
                     * @returns {GC.Spread.Sheets.Tables.TableStyle | GC.Spread.Sheets.Tables.TableTheme} If no value is set, returns the style of the first header cell; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GC.Spread.Sheets.TableStyle();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.TableStyleInfo("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.TableStyleInfo();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.firstHeaderCellStyle(tStyleInfo);
                     * tableStyle.lastHeaderCellStyle(tStyleInfo);
                     * var sTable = activeSheet.addTable("table1", 1, 1, 10, 5, tableStyle);
                     * sTable.highlightFirstColumn(true);
                     * sTable.highlightLastColumn(true);
                     */
                    firstHeaderCellStyle(value?:  GC.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the size of the first alternating row.
                     * @param {number} value The size of the first alternating row.
                     * @returns {number | GC.Spread.Sheets.Tables.TableTheme} If no value is set, returns the size of the first alternating row; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.firstRowStripSize(2);
                     * tableStyle.firstRowStripStyle(tStyleInfo);
                     * activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     */
                    firstRowStripSize(value?:  number): any;
                    /**
                     * Gets or sets the first alternating row style.
                     * @param {GC.Spread.Sheets.Tables.TableStyle} value The first alternating row style.
                     * @returns {GC.Spread.Sheets.Tables.TableStyle | GC.Spread.Sheets.Tables.TableTheme} If no value is set, returns the first alternating row style; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.firstRowStripSize(2);
                     * tableStyle.firstRowStripStyle(tStyleInfo);
                     * activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     */
                    firstRowStripStyle(value?:  GC.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the default style of the footer area.
                     * @param {GC.Spread.Sheets.Tables.TableStyle} value The default style of the footer area.
                     * @returns {GC.Spread.Sheets.Tables.TableStyle | GC.Spread.Sheets.Tables.TableTheme} If no value is set, returns the default style of the footer area; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.footerRowStyle(tStyleInfo);
                     * var sTable = activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     * sTable.showFooter(true);
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     */
                    footerRowStyle(value?:  GC.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the default style of the header area.
                     * @param {GC.Spread.Sheets.Tables.TableStyle} value The default style of the header area.
                     * @returns {GC.Spread.Sheets.Tables.TableStyle | GC.Spread.Sheets.Tables.TableTheme} If no value is set, returns the default style of the header area; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tableStyleInfo = new GC.Spread.Sheets.Tables.TableStyle(
                     *     "black",
                     *     "white",
                     *     "bold 11pt arial",
                     *     new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin),
                     *     new GC.Spread.Sheets.LineBorder("red", GC.Spread.Sheets.LineStyle.thick),
                     *     new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.thin),
                     *     new GC.Spread.Sheets.LineBorder("blue", GC.Spread.Sheets.LineStyle.thick));
                     * tableStyle.headerRowStyle(tableStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    headerRowStyle(value?:  GC.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the style of the first column.
                     * @param {GC.Spread.Sheets.Tables.TableStyle} value The style of the first column.
                     * @returns {GC.Spread.Sheets.Tables.TableStyle | GC.Spread.Sheets.Tables.TableTheme} If no value is set, returns the style of the first column; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.highlightFirstColumnStyle(tStyleInfo);
                     * var sTable = activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     * sTable.highlightFirstColumn(true);
                     * sTable.highlightLastColumn(true);
                     */
                    highlightFirstColumnStyle(value?:  GC.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the style of the last column.
                     * @param {GC.Spread.Sheets.Tables.TableStyle} value The style of the last column.
                     * @returns {GC.Spread.Sheets.Tables.TableStyle | GC.Spread.Sheets.Tables.TableTheme} If no value is set, returns the style of the last column; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * //style
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.highlightLastColumnStyle(tStyleInfo);
                     * var sTable = activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     * sTable.highlightLastColumn(true);
                     */
                    highlightLastColumnStyle(value?:  GC.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the style of the last footer cell.
                     * @param {GC.Spread.Sheets.Tables.TableStyle} value The style of the last footer cell.
                     * @returns {GC.Spread.Sheets.Tables.TableStyle | GC.Spread.Sheets.Tables.TableTheme} If no value is set, returns the style of the last footer cell; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.lastFooterCellStyle(tStyleInfo);
                     * tableStyle.firstFooterCellStyle(tStyleInfo);
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, tableStyle);
                     * sTable.showFooter(true);
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     * sTable.highlightFirstColumn(true);
                     * sTable.highlightLastColumn(true);
                     */
                    lastFooterCellStyle(value?:  GC.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the style of the last header cell.
                     * @param {GC.Spread.Sheets.Tables.TableStyle} value The style of the last header cell.
                     * @returns {GC.Spread.Sheets.Tables.TableStyle | GC.Spread.Sheets.Tables.TableTheme} If no value is set, returns the style of the last header cell; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GC.Spread.Sheets.TableStyle();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.TableStyleInfo("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.TableStyleInfo();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.firstHeaderCellStyle(tStyleInfo);
                     * tableStyle.lastHeaderCellStyle(tStyleInfo);
                     * var sTable = activeSheet.addTable("table1", 1, 1, 10, 5, tableStyle);
                     * sTable.highlightFirstColumn(true);
                     * sTable.highlightLastColumn(true);
                     */
                    lastHeaderCellStyle(value?:  GC.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the name of the style.
                     * @param {string} value The name of the style.
                     * @returns {string | GC.Spread.Sheets.Tables.TableTheme} If no value is set, returns the name of the style; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GC.Spread.Sheets.TableStyle();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.TableStyleInfo("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.TableStyleInfo();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.name("tstyle");
                     * tableStyle.firstColumnStripSize(2);
                     * tableStyle.firstColumnStripStyle(tStyleInfo);
                     * var sTable = activeSheet.addTable("Custom", 1, 1, 10, 5, tableStyle);
                     * sTable.bandColumns(true);
                     */
                    name(value?:  string): any;
                    /**
                     * Gets or sets the size of the second alternating column.
                     * @param {number} value The size of the second alternating column.
                     * @returns {number | GC.Spread.Sheets.Tables.TableTheme} If no value is set, returns the size of the second alternating column; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.secondColumnStripSize(2);
                     * tableStyle.secondColumnStripStyle(tStyleInfo);
                     * var sTable = activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     * sTable.bandColumns(true);
                     */
                    secondColumnStripSize(value?:  number): any;
                    /**
                     * Gets or sets the style of the second alternating column.
                     * @param {GC.Spread.Sheets.Tables.TableStyle} value The style of the second alternating column.
                     * @returns {GC.Spread.Sheets.Tables.TableStyle | GC.Spread.Sheets.Tables.TableTheme} If no value is set, returns the style of the second alternating column; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.secondColumnStripSize(2);
                     * tableStyle.secondColumnStripStyle(tStyleInfo);
                     * var sTable = activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     * sTable.bandColumns(true);
                     */
                    secondColumnStripStyle(value?:  GC.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the size of the second alternating row.
                     * @param {number} value The size of the second alternating row.
                     * @returns {number | GC.Spread.Sheets.Tables.TableTheme} If no value is set, returns the size of the second alternating row; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.secondRowStripSize(2);
                     * tableStyle.secondRowStripStyle(tStyleInfo);
                     * activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     */
                    secondRowStripSize(value?:  number): any;
                    /**
                     * Gets or sets the second alternating row style.
                     * @param {GC.Spread.Sheets.Tables.TableStyle} value The second alternating row style.
                     * @returns {GC.Spread.Sheets.Tables.TableStyle | GC.Spread.Sheets.Tables.TableTheme} If no value is set, returns the second alternating row style; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GC.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.secondRowStripSize(2);
                     * tableStyle.secondRowStripStyle(tStyleInfo);
                     * activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     */
                    secondRowStripStyle(value?:  GC.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the default style of the data area.
                     * @param {GC.Spread.Sheets.Tables.TableStyle} value The default style of the data area.
                     * @returns {GC.Spread.Sheets.Tables.TableStyle | GC.Spread.Sheets.Tables.TableTheme} If no value is set, returns the default style of the data area; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GC.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GC.Spread.Sheets.LineBorder("black", GC.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GC.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tableStyleInfo = new GC.Spread.Sheets.Tables.TableStyle(
                     *     "black",
                     *     "white",
                     *     "bold 11pt arial",
                     *     new GC.Spread.Sheets.LineBorder("green", GC.Spread.Sheets.LineStyle.thin),
                     *     new GC.Spread.Sheets.LineBorder("red", GC.Spread.Sheets.LineStyle.thick),
                     *     new GC.Spread.Sheets.LineBorder("yellow", GC.Spread.Sheets.LineStyle.thin),
                     *     new GC.Spread.Sheets.LineBorder("blue", GC.Spread.Sheets.LineStyle.thick));
                     * tableStyle.headerRowStyle(tableStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    wholeTableStyle(value?:  GC.Spread.Sheets.Tables.TableStyle): any;
                }

                export class TableThemes{
                    /**
                     * Represents a built-in table theme collection.
                     * @class
                     */
                    constructor();
                    /**
                     * Gets the dark1 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark1: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the dark10 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark10: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the dark11 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark11: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the dark2 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark2: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the dark3 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark3: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the dark4 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark4: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the dark5 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark5: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the dark6 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark6: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the dark7 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark7: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the dark8 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark8: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the dark9 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark9: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light1 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static light1: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light10 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static light10: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light11 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static light11: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light12 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static light12: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light13 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static light13: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light14 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static light14: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light15 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static light15: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light16 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static light16: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light17 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static light17: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light18 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static light18: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light19 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static light19: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light2 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static light2: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light20 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static light20: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light21 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static light21: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light3 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static light3: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light4 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static light4: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light5 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static light5: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light6 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static light6: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light7 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static light7: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light8 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static light8: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light9 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static light9: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium1 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium1: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium10 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium10: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium11 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium11: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium12 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium12: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium13 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium13: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium14 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium14: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium15 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium15: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium16 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium16: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium17 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium17: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium18 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium18: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium19 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium19: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium2 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium2: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium20 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium20: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium21 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium21: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium22 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium22: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium23 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium23: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium24 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium24: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium25 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium25: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium26 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium26: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium27 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium27: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium28 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium28: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium3 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium3: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium4 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium4: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium5 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium5: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium6 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium6: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium7 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium7: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium8 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium8: GC.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium9 style.
                     * @returns {GC.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium9: GC.Spread.Sheets.Tables.TableTheme;
                }
            }

            module Touch{

                export class TouchToolStrip{
                    /**
                     * Represents a toolbar.
                     * @class
                     * @param {GC.Spread.Sheets.Workbook} workbook The Spread object.
                     * @param {HTMLElement} host The host DOM element.
                     */
                    constructor(workbook:  GC.Spread.Sheets.Workbook,  host:  HTMLElement);
                    /**
                     * Adds an item to the touch toolbar.
                     * @param {any} item The item to be added.
                     * @remarks The item to be added can be a toolbar item or a line separator.
                     * @example
                     * //This example adds a custom item.
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripItem("C", "Delete", "tsoutline.png", function(){ }))
                     * spread.touchToolStrip.getItem("C").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.imageAreaHeight(30);
                     * spread.touchToolStrip.itemHeight(80);
                     * spread.touchToolStrip.itemWidth(50);
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripSeparator());
                     */
                    add(item:  any): void;
                    /**
                     * Clears all items in the toolbar.
                     * @example
                     * //This example uses the clear method.
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripItem("C", "Delete", "tsoutline.png", function(){ }))
                     * spread.touchToolStrip.getItem("C").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.imageAreaHeight(30);
                     * spread.touchToolStrip.itemHeight(80);
                     * spread.touchToolStrip.itemWidth(50);
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripSeparator());
                     * spread.touchToolStrip.clear();
                     */
                    clear(): void;
                    /**
                     * Closes the toolbar.
                     */
                    close(): void;
                    /**
                     * Gets the item with the specified name.
                     * @param {string} name The item name.
                     * @returns If the item exists in the toolbar, the item is returned; otherwise, returns undefined.
                     * @example
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripItem("Cut", "Delete", "cut.png", function(){ }))
                     * spread.touchToolStrip.getItem("Cut").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripSeparator());
                     */
                    getItem(name:  string): any;
                    /**
                     * Gets all the items that belong to the toolbar.
                     * @returns An array that contains all the items in the toolbar.
                     */
                    getItems(): any;
                    /**
                     * Gets or sets the image area height.
                     * @param {number} height The image area height.
                     * @returns {number | GC.Spread.Sheets.Touch.TouchToolStrip} If no value is set, returns the image area height; otherwise, returns the toolbar.
                     * @example
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripItem("C", "Delete", "tsoutline.png", function(){ }))
                     * spread.touchToolStrip.getItem("C").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.imageAreaHeight(30);
                     * spread.touchToolStrip.itemHeight(80);
                     * spread.touchToolStrip.itemWidth(50);
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripSeparator());
                     */
                    imageAreaHeight(height?:  number): any;
                    /**
                     * Gets or sets the toolbar item height.
                     * @param {number} height The toolbar item height.
                     * @returns {number | GC.Spread.Sheets.Touch.TouchToolStrip} If no value is set, returns the toolbar item height; otherwise, returns the toolbar.
                     * @example
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripItem("C", "Delete", "tsoutline.png", function(){ }))
                     * spread.touchToolStrip.getItem("C").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.imageAreaHeight(30);
                     * spread.touchToolStrip.itemHeight(80);
                     * spread.touchToolStrip.itemWidth(50);
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripSeparator());
                     */
                    itemHeight(height?:  number): any;
                    /**
                     * Gets or sets the toolbar item width.
                     * @param {number} width The toolbar item width.
                     * @returns {number | GC.Spread.Sheets.Touch.TouchToolStrip} If no value is set, returns the toolbar item width; otherwise, returns the toolbar.
                     * @example
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripItem("C", "Delete", "tsoutline.png", function(){ }))
                     * spread.touchToolStrip.getItem("C").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.imageAreaHeight(30);
                     * spread.touchToolStrip.itemHeight(80);
                     * spread.touchToolStrip.itemWidth(50);
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripSeparator());
                     */
                    itemWidth(width?:  number): any;
                    /**
                     * Opens a toolbar in a specific position relative to the touch point.
                     * @param {number} x The <i>x</i>-coordinate.
                     * @param {number} y The <i>y</i>-coordinate.
                     */
                    open(x:  number,  y:  number): void;
                    /**
                     * Removes the toolbar item with the specified name.
                     * @param {string} name The name of the item to be removed.
                     * @returns {GC.Spread.Sheets.Touch.TouchToolStripItem} The removed item.
                     * @example
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripItem("Cut", "Delete", "cut.png", function(){ }))
                     * spread.touchToolStrip.getItem("Cut").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripSeparator());
                     * spread.touchToolStrip.remove("Cut");
                     * activeSheet.resumePaint();
                     * activeSheet.repaint();
                     */
                    remove(name:  string): GC.Spread.Sheets.Touch.TouchToolStripItem;
                    /**
                     * Gets or sets the toolbar separator height.
                     * @param {number} height The toolbar separator height.
                     * @returns {number | GC.Spread.Sheets.Touch.TouchToolStrip} If no value is set, returns the toolbar separator height; otherwise, returns the toolbar.
                     * @example
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripItem("Cut", "Delete", "cut.png", function(){ }))
                     * spread.touchToolStrip.getItem("Cut").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.separatorHeight(33);
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripSeparator());
                     */
                    separatorHeight(height?:  number): any;
                }

                export class TouchToolStripItem{
                    /**
                     * Represents an item in the toolbar.
                     * @class
                     * @param {string} name The name of the item.
                     * @param {string} text The item text.
                     * @param {string} image The item image source.
                     * @param {any} command Defines the executive function that occurs when the user taps the item.
                     * @param {any} canExecute Defines when to show the item by a function. If returns <c>true</c>, display the item; otherwise, hide the item.
                     * @example
                     * //This example adds a delete image with red text.
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripItem("Cut", "Delete", "cut.png", function(){ }))
                     * spread.touchToolStrip.getItem("Cut").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripSeparator());
                     */
                    constructor(name:  string,  text:  string,  image:  string,  command?:  any,  canExecute?:  any);
                    /**
                     * Gets or sets the font of the item text.
                     * @param {string} value The font of the toolbar item text.
                     * @returns {string | GC.Spread.Sheets.Touch.TouchToolStripItem} If no value is set, returns the font of the item text; otherwise, returns the toolbar item.
                     * @example
                     * //This example adds a delete image with red text.
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripItem("Cut", "Delete", "cut.png", function(){ }))
                     * spread.touchToolStrip.getItem("Cut").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripSeparator());
                     */
                    font(value?:  string): any;
                    /**
                     * Gets or sets the color of the item text.
                     * @param {string} value The color of the toolbar item text.
                     * @returns {string | GC.Spread.Sheets.Touch.TouchToolStripItem} If no value is set, returns the color of the item text; otherwise, returns the toolbar item.
                     * @example
                     * //This example adds a delete image with red text.
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripItem("Cut", "Delete", "cut.png", function(){ }))
                     * spread.touchToolStrip.getItem("Cut").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripSeparator());
                     */
                    foreColor(value?:  string): any;
                    /**
                     * Gets or sets the source of the item image.
                     * @param {string} value The path and filename for the item image source.
                     * @returns {string | GC.Spread.Sheets.Touch.TouchToolStripItem} If no value is set, returns the source of the item image; otherwise, returns the toolbar item.
                     * @example
                     * //This example adds a delete image with red text.
                     * var tts = new GC.Spread.Sheets.Touch.TouchToolStripItem();
                     * tts.image("cut.png");
                     * tts.name("C");
                     * tts.text("Delete");
                     * spread.touchToolStrip.add(tts, function(){ });
                     * spread.touchToolStrip.getItem("C").font("15px Arial").foreColor("red");
                     */
                    image(value?:  string): any;
                    /**
                     * Gets or sets the name of the item.
                     * @param {string} value The name of the toolbar item.
                     * @returns {string | GC.Spread.Sheets.Touch.TouchToolStripItem} If no value is set, returns the name of the item; otherwise, returns the toolbar item.
                     * @example
                     * //This example adds a delete image with red text.
                     * var tts = new GC.Spread.Sheets.Touch.TouchToolStripItem();
                     * tts.image("cut.png");
                     * tts.name("C");
                     * tts.text("Delete");
                     * spread.touchToolStrip.add(tts, function(){ });
                     * spread.touchToolStrip.getItem("C").font("15px Arial").foreColor("red");
                     */
                    name(value?:  string): any;
                    /**
                     * Gets or sets the text of the item.
                     * @param {string} value The text of the toolbar item.
                     * @returns {string | GC.Spread.Sheets.Touch.TouchToolStripItem} If no value is set, returns the text of the item; otherwise, returns the toolbar item.
                     * @example
                     * //This example adds a delete image with red text.
                     * var tts = new GC.Spread.Sheets.Touch.TouchToolStripItem();
                     * tts.image("cut.png");
                     * tts.name("C");
                     * tts.text("Delete");
                     * spread.touchToolStrip.add(tts, function(){ });
                     * spread.touchToolStrip.getItem("C").font("15px Arial").foreColor("red");
                     */
                    text(value?:  string): any;
                }

                export class TouchToolStripSeparator{
                    /**
                     * Represents a separator in the toolbar.
                     * @class
                     * @param {boolean} canExecute - Defines when to display the separator with a function. If returns <c>true</c>, display the separator; otherwise, hide the separator.
                     * @example
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripItem("Cut", "Delete", "cut.png", function(){ }))
                     * spread.touchToolStrip.getItem("Cut").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.add(new GC.Spread.Sheets.Touch.TouchToolStripSeparator());
                     */
                    constructor(canExecute?:  boolean);
                    /**
                     * Gets the name of the separator.
                     * @returns {string} Returns the current separator name.
                     */
                    name(): string;
                }
            }

        }

        module Slicers{

            export interface ISlicerConditional{
                exclusiveRowIndexes?: number[];
                ranges?: ISlicerRangeConditional[];
            }


            export interface ISlicerData{
                getColumnIndex(columnName: string): number;
                getData(columnName: string, range?: ISlicerRangeConditional): any[];
                getExclusiveData(columnName: string): any[];
                getRowIndexes(columnName: string, exclusiveRowIndex: number): number[];
                getExclusiveRowIndex(columnName: string, rowIndex: number): number;
                getFilteredIndexes(columnName: string, isPreview?: boolean): number[];
                getFilteredOutIndexes(columnName: string, filteredOutDataType: GC.Spread.Slicers.FilteredOutDataType, isPreview?: boolean): number[];
                getFilteredRanges(columnName: string): ISlicerRangeConditional[];
                getFilteredOutRanges(columnName: string): ISlicerRangeConditional[];
                attachListener(listener: ISlicerListener): void;
                detachListener(listener: ISlicerListener): void;
                doFilter(columnName: string, slicerConditional: ISlicerConditional, isPreview?: boolean): void;
                doUnfilter(columnName: string): void;
                clearPreview():void;
            }


            export interface ISlicerDataItem{
                columnName: string;
                rowIndex: number;
                data: any;
            }


            export interface ISlicerFiltedData{
                isPreview: boolean;
                rowIndexes: number[];
            }


            export interface ISlicerListener{
                onFiltered(data: ISlicerFiltedData): void;
                onDataChanged(data: ISlicerDataItem[]): void;
                onRowsChanged(rowIndex: number, rowCount: number, isAdd: boolean): void;
                onColumnNameChanged(oldName: string, newName: string): void;
                onColumnRemoved(columnName: string): void;
            }


            export interface ISlicerRangeConditional{
                min: number;
                max: number;
            }

            /**
             * Represents the kind of filtered out exclusive data index that should be included in the result.
             * @enum {number}
             */
            export enum FilteredOutDataType{
                /**
                 * Indicates all of the filtered out data.
                 */
                all= 0,
                /**
                 * Indicates the data was filtered out based on the current column.
                 */
                byCurrentColumn= 1,
                /**
                 * Indicates the data was filtered out based on other columns.
                 */
                byOtherColumns= 2
            }

            /**
             * Represents the aggregate type.
             * @enum {number}
             */
            export enum SlicerAggregateType{
                /**
                 *  Calculates the average of the specified numeric values.
                 */
                average= 1,
                /**
                 *  Calculates the number of data that contain numbers.
                 */
                count= 2,
                /**
                 *  Calculates the number of data that contain non-null values.
                 */
                counta= 3,
                /**
                 *  Calculates the maximum value, the greatest value, of all the values.
                 */
                max= 4,
                /**
                 *  Calculates the minimum value, the least value, of all the values.
                 */
                min= 5,
                /**
                 *  Multiplies all the arguments and returns the product.
                 */
                product= 6,
                /**
                 *  Calculates the standard deviation based on a sample.
                 */
                stdev= 7,
                /**
                 *  Calculates the standard deviation of a population based on the entire population using the numbers in a column of a list or database that match the specified conditions.
                 */
                stdevp= 8,
                /**
                 *  Calculates the sum of the specified numeric values.
                 */
                sum= 9,
                /**
                 *  Calculates the variance based on a sample of a population, which uses only numeric values.
                 */
                vars= 10,
                /**
                 *  Calculates the variance based on a sample of a population, which includes numeric, logical, or text values.
                 */
                varp= 11
            }


            export class GeneralSlicerData{
                /**
                 * Represents general slicer data.
                 * @class GC.Spread.Slicers.GeneralSlicerData
                 * @param {Array.<Array.<any>>} data The slicer data; it is a matrix array.
                 * @param {Array} columnNames The column names of the slicer data.
                 */
                constructor(data:  any[][],  columnNames:  string[]);
                /**
                 * Indicates the column names for the general slicer data.
                 * @type {Array}
                 */
                columnNames: string[];
                /**
                 * Indicates the data source for general slicer data.
                 * @type {{Array.<Array.<any>>}}
                 */
                data: any[][];
                /**
                 * Aggregates the data by the specified column name.
                 * @param {string} columnName The column name.
                 * @param {GC.Spread.Slicers.SlicerAggregateType} aggregateType The aggregate type.
                 * @param {object} range The specific range.
                 * range.min: number type, the minimum value.
                 * range.max: number type, the maximum value.
                 * @returns {number} The aggregated data.
                 */
                aggregateData(columnName:  string,  aggregateType:  GC.Spread.Slicers.SlicerAggregateType,  range?:  GC.Spread.Slicers.ISlicerRangeConditional): number;
                /**
                 * Attaches the listener.
                 * @param {GC.Spread.Slicers.ISlicerListener} listener The listener.
                 */
                attachListener(listener:  GC.Spread.Slicers.ISlicerListener): void;
                /**
                 * Clears the preview filter state.
                 */
                clearPreview(): any;
                /**
                 * Detaches the listener.
                 * @param {GC.Spread.Slicers.ISlicerListener} listener The listener.
                 */
                detachListener(listener:  GC.Spread.Slicers.ISlicerListener): void;
                /**
                 * Filters the data that corresponds to the specified column name and exclusive data indexes.
                 * @param {string} columnName The column name.
                 * @param {object} conditional The conditional filter.
                 * conditional.exclusiveRowIndexes: number array type, visible exclusive row indexes
                 * conditional.ranges: {min:number, max:number} array type, visible ranges.
                 * @param {boolean} isPreview Indicates whether preview is set.
                 */
                doFilter(columnName:  string,  conditional:  GC.Spread.Slicers.ISlicerConditional,  isPreview?:  boolean): void;
                /**
                 * Unfilters the data that corresponds to the specified column name.
                 * @param {string} columnName The column name.
                 */
                doUnfilter(columnName:  string): void;
                /**
                 * Gets the column index by the specified column name.
                 * @param {string} columnName The column name.
                 * @returns {number} The column index.
                 */
                getColumnIndex(columnName:  string): number;
                /**
                 * Gets the data by the specified column name.
                 * @param {string} columnName The column name.
                 * @param {object} range The specific range.
                 * range.min: number type, the minimum value.
                 * range.max: number type, the maximum value.
                 * @returns {Array} The data that corresponds to the specified column name.
                 */
                getData(columnName:  string,  range?:  GC.Spread.Slicers.ISlicerRangeConditional): any[];
                /**
                 * Gets the exclusive data by the specified column name.
                 * @param {string} columnName The column name.
                 * @returns {Array} The exclusive data that corresponds to the specified column name.
                 */
                getExclusiveData(columnName:  string): any[];
                /**
                 * Gets the exclusive data index by the specified column name and data index.
                 * @param {string} columnName The column name.
                 * @param {number} rowIndex The index of the data.
                 * @returns {number} The exclusive data index that corresponds to the specified column name and data index.
                 */
                getExclusiveRowIndex(columnName:  string,  rowIndex:  number): number;
                /**
                 * Gets the filtered exclusive data indexes by the specified column name.
                 * @param {string} columnName The column name.
                 * @returns {Array} The filtered exclusive data indexes that correspond to the specified column name.
                 */
                getFilteredIndexes(columnName:  string): number[];
                /**
                 * Gets the filtered out exclusive data indexes by the specified column name.
                 * @param {string} columnName The column name.
                 * @param {GC.Spread.Slicers.FilteredOutDataType} filteredOutDataType Indicates the kind of filtered out exclusive data index that should be included in the result.
                 * @returns {Array} The filtered out exclusive data indexes that correspond to the specified column name.
                 */
                getFilteredOutIndexes(columnName:  string,  filteredOutDataType:  FilteredOutDataType): number[];
                /**
                 * Gets the filtered out ranges by other columns.
                 * @param {string} columnName The column name.
                 * @returns {Array} The filtered out ranges by other columns that correspond to the specified column name.
                 */
                getFilteredOutRanges(columnName:  string): GC.Spread.Slicers.ISlicerRangeConditional[];
                /**
                 * Gets the filtered out row indexes.
                 * @returns {Array} The filtered out row indexes.
                 */
                getFilteredOutRowIndexes(): number[];
                /**
                 * Gets the filtered ranges by the specified column name.
                 * @param {string} columnName The column name.
                 * @returns {Array} The filtered ranges that correspond to the specified column name.
                 */
                getFilteredRanges(columnName:  string): GC.Spread.Slicers.ISlicerRangeConditional[];
                /**
                 * Gets the filtered row indexes.
                 * @returns {Array} The filtered row indexes.
                 */
                getFilteredRowIndexes(): number[];
                /**
                 * Gets the data indexes by the specified column name and exclusive data index.
                 * @param {string} columnName The column name.
                 * @param {number} exclusiveRowIndex The index of the exclusive data.
                 * @returns {Array} The data indexes that correspond to the specified column name and exclusive data index.
                 */
                getRowIndexes(columnName:  string,  exclusiveRowIndex:  number): number[];
                /**
                 * Gets whether the slicer is in the preview state.
                 */
                inPreview(): any;
                /**
                 * Changes a column name for the general slicer data.
                 * @param {string} oldName The old name of the column.
                 * @param {string} newName The new name of the column.
                 */
                onColumnNameChanged(oldName:  string,  newName:  string): void;
                /**
                 * Removes columns of the general slicer data.
                 * @param {number} colIndex The index of the starting column.
                 * @param {number} colCount The number of columns to remove.
                 */
                onColumnsRemoved(colIndex:  number,  colCount:  number): void;
                /**
                 * Changes data items in the data source of the general slicer data.
                 * @param {GC.Spread.Slicers.ISlicerDataItem} changedData The changed data item in the data source.
                 */
                onDataChanged(changedDataItems:  GC.Spread.Slicers.ISlicerDataItem): void;
                /**
                 * Occurs after the slicer data has been filtered.
                 * @param {Array} filteredIndexes The filtered exclusive data indexes.
                 * @param {boolean} isPreview Indicates whether the slicer is in preview mode.
                 */
                onFiltered(): any;
                /**
                 * Adds rows in the data source of the general slicer data.
                 * @param {number} rowIndex The index of the starting row.
                 * @param {number} rowCount The number of rows to add.
                 */
                onRowsAdded(rowIndex:  number,  rowCount:  number): void;
                /**
                 * Removes rows in the data source of the general slicer data.
                 * @param {number} rowIndex The index of the starting row.
                 * @param {number} rowCount The number of rows to remove.
                 */
                onRowsRemoved(rowIndex:  number,  rowCount:  number): void;
                /**
                 * Resumes the onFiltered event.
                 */
                resumeFilteredEvents(): any;
                /**
                 * Suspends the onFiltered event.
                 */
                suspendFilteredEvents(): any;
            }
        }

    }

}

 export = GC;