/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { DOCUMENT } from '@angular/common';
import { HttpBackend, HttpClient } from '@angular/common/http';
import { Inject, Optional, RendererFactory2, SecurityContext } from '@angular/core';
import { DomSanitizer } from '@angular/platform-browser';
import { of as observableOf } from 'rxjs';
import { catchError, finalize, map, share, tap } from 'rxjs/operators';
import { cloneSVG, getIconDefinitionFromAbbr, getNameAndNamespace, getSecondaryColor, hasNamespace, isIconDefinition, replaceFillColor, withSuffix, withSuffixAndColor } from '../utils';
import { HttpModuleNotImport, IconNotFoundError, NameSpaceIsNotSpecifyError, SVGTagNotFoundError, UrlNotSafeError } from './icon.error';
export class IconService {
    /**
     * @param {?} _rendererFactory
     * @param {?} _handler
     * @param {?} _document
     * @param {?} sanitizer
     */
    constructor(_rendererFactory, _handler, _document, sanitizer) {
        this._rendererFactory = _rendererFactory;
        this._handler = _handler;
        this._document = _document;
        this.sanitizer = sanitizer;
        this.defaultTheme = 'outline';
        /**
         * All icon definitions would be registered here.
         */
        this._svgDefinitions = new Map();
        /**
         * Cache all rendered icons. Icons are identified by name, theme,
         * and for twotone icons, primary color and secondary color.
         */
        this._svgRenderedDefinitions = new Map();
        this._inProgressFetches = new Map();
        /**
         * Url prefix for fetching inline SVG by dynamic importing.
         */
        this._assetsUrlRoot = '';
        this._twoToneColorPalette = {
            primaryColor: '#333333',
            secondaryColor: '#E6E6E6'
        };
        this._renderer = this._rendererFactory.createRenderer(null, null);
        if (this._handler) {
            this._http = new HttpClient(this._handler);
        }
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    set twoToneColor({ primaryColor, secondaryColor }) {
        this._twoToneColorPalette.primaryColor = primaryColor;
        this._twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
    }
    /**
     * @return {?}
     */
    get twoToneColor() {
        return (/** @type {?} */ (Object.assign({}, this._twoToneColorPalette))); // Make a copy to avoid unexpected changes.
    }
    /**
     * Change the prefix of the inline svg resources, so they could be deployed elsewhere, like CDN.
     * @param {?} prefix
     * @return {?}
     */
    changeAssetsSource(prefix) {
        this._assetsUrlRoot = prefix.endsWith('/') ? prefix : prefix + '/';
    }
    /**
     * Add icons provided by ant design.
     * @param {...?} icons
     * @return {?}
     */
    addIcon(...icons) {
        icons.forEach((/**
         * @param {?} icon
         * @return {?}
         */
        icon => {
            this._svgDefinitions.set(withSuffix(icon.name, icon.theme), icon);
        }));
    }
    /**
     * Register an icon. Namespace is required.
     * @param {?} type
     * @param {?} literal
     * @return {?}
     */
    addIconLiteral(type, literal) {
        const [name, namespace] = getNameAndNamespace(type);
        if (!namespace) {
            throw NameSpaceIsNotSpecifyError();
        }
        this.addIcon({ name: type, icon: literal });
    }
    /**
     * Remove all cache.
     * @return {?}
     */
    clear() {
        this._svgDefinitions.clear();
        this._svgRenderedDefinitions.clear();
    }
    /**
     * Get a rendered `SVGElement`.
     * @param {?} icon
     * @param {?=} twoToneColor
     * @return {?}
     */
    getRenderedContent(icon, twoToneColor) {
        // If `icon` is a `IconDefinition`, go to the next step. If not, try to fetch it from cache.
        /** @type {?} */
        const definition = isIconDefinition(icon) ? (/** @type {?} */ (icon)) : this._svgDefinitions.get((/** @type {?} */ (icon)));
        // If `icon` is a `IconDefinition` of successfully fetch, wrap it in an `Observable`. Otherwise try to fetch it from remote.
        /** @type {?} */
        const $iconDefinition = definition ? observableOf(definition) : this._getFromRemote((/** @type {?} */ (icon)));
        // If finally get an `IconDefinition`, render and return it. Otherwise throw an error.
        return $iconDefinition.pipe(map((/**
         * @param {?} i
         * @return {?}
         */
        i => {
            if (!i) {
                throw IconNotFoundError((/** @type {?} */ (icon)));
            }
            return this._loadSVGFromCacheOrCreateNew(i, twoToneColor);
        })));
    }
    /**
     * @return {?}
     */
    getCachedIcons() {
        return this._svgDefinitions;
    }
    /**
     * Get raw svg and assemble a `IconDefinition` object.
     * @protected
     * @param {?} type
     * @return {?}
     */
    _getFromRemote(type) {
        if (!this._http) {
            return observableOf(HttpModuleNotImport());
        }
        // If multi directive ask for the same icon at the same time, http request should only be fired once.
        /** @type {?} */
        let inProgress = this._inProgressFetches.get(type);
        // If there's no other directive asking for the same icon, fire a request.
        if (!inProgress) {
            const [name, namespace] = getNameAndNamespace(type);
            // If the string has a namespace within, create a simple `IconDefinition`.
            /** @type {?} */
            const icon = namespace
                ? { name: type, icon: '' }
                : getIconDefinitionFromAbbr(name);
            /** @type {?} */
            const url = namespace
                ? `${this._assetsUrlRoot}assets/${namespace}/${name}.svg`
                : `${this._assetsUrlRoot}assets/${icon.theme}/${icon.name}.svg`;
            /** @type {?} */
            const safeUrl = this.sanitizer.sanitize(SecurityContext.URL, url);
            if (!safeUrl) {
                throw UrlNotSafeError(url);
            }
            // Wrap a `IconDefinition`, cache it, delete the shared work.
            inProgress = this._http.get(safeUrl, { responseType: 'text' }).pipe(map((/**
             * @param {?} literal
             * @return {?}
             */
            literal => (Object.assign({}, icon, { icon: literal })))), tap((/**
             * @param {?} definition
             * @return {?}
             */
            definition => this.addIcon(definition))), finalize((/**
             * @return {?}
             */
            () => this._inProgressFetches.delete(type))), catchError((/**
             * @return {?}
             */
            () => observableOf(null))), share());
            this._inProgressFetches.set(type, inProgress);
        }
        // Otherwise just reuse other directive's request.
        return inProgress;
    }
    /**
     * Render a new `SVGElement` for given `IconDefinition`, or make a copy from cache.
     * @protected
     * @param {?} icon
     * @param {?=} twoToneColor
     * @return {?}
     */
    _loadSVGFromCacheOrCreateNew(icon, twoToneColor) {
        /** @type {?} */
        let svg;
        /** @type {?} */
        const pri = twoToneColor || this._twoToneColorPalette.primaryColor;
        /** @type {?} */
        const sec = getSecondaryColor(pri) || this._twoToneColorPalette.secondaryColor;
        /** @type {?} */
        const key = icon.theme === 'twotone'
            ? withSuffixAndColor(icon.name, icon.theme, pri, sec)
            : icon.theme === undefined ? icon.name : withSuffix(icon.name, icon.theme);
        // Try to make a copy from cache.
        /** @type {?} */
        const cached = this._svgRenderedDefinitions.get(key);
        if (cached) {
            svg = cached.icon;
        }
        else {
            svg = this._setSVGAttribute(this._colorizeSVGIcon(
            // Icons provided by ant design should be refined to remove preset colors.
            this._createSVGElementFromString(hasNamespace(icon.name) ? icon.icon : replaceFillColor(icon.icon)), icon.theme === 'twotone', pri, sec));
            // Cache it.
            this._svgRenderedDefinitions.set(key, (/** @type {?} */ (Object.assign({}, icon, { icon: svg }))));
        }
        return cloneSVG(svg);
    }
    /**
     * @protected
     * @param {?} str
     * @return {?}
     */
    _createSVGElementFromString(str) {
        /** @type {?} */
        const div = this._document.createElement('div');
        div.innerHTML = str;
        /** @type {?} */
        const svg = div.querySelector('svg');
        if (!svg) {
            throw SVGTagNotFoundError;
        }
        return svg;
    }
    /**
     * @protected
     * @param {?} svg
     * @return {?}
     */
    _setSVGAttribute(svg) {
        this._renderer.setAttribute(svg, 'width', '1em');
        this._renderer.setAttribute(svg, 'height', '1em');
        return svg;
    }
    /**
     * @protected
     * @param {?} svg
     * @param {?} twotone
     * @param {?} pri
     * @param {?} sec
     * @return {?}
     */
    _colorizeSVGIcon(svg, twotone, pri, sec) {
        if (twotone) {
            /** @type {?} */
            const children = svg.childNodes;
            /** @type {?} */
            const length = children.length;
            for (let i = 0; i < length; i++) {
                /** @type {?} */
                const child = (/** @type {?} */ (children[i]));
                if (child.getAttribute('fill') === 'secondaryColor') {
                    this._renderer.setAttribute(child, 'fill', sec);
                }
                else {
                    this._renderer.setAttribute(child, 'fill', pri);
                }
            }
        }
        this._renderer.setAttribute(svg, 'fill', 'currentColor');
        return svg;
    }
}
/** @nocollapse */
IconService.ctorParameters = () => [
    { type: RendererFactory2 },
    { type: HttpBackend, decorators: [{ type: Optional }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },
    { type: DomSanitizer }
];
if (false) {
    /** @type {?} */
    IconService.prototype.defaultTheme;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype._renderer;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype._http;
    /**
     * All icon definitions would be registered here.
     * @type {?}
     * @protected
     */
    IconService.prototype._svgDefinitions;
    /**
     * Cache all rendered icons. Icons are identified by name, theme,
     * and for twotone icons, primary color and secondary color.
     * @type {?}
     * @protected
     */
    IconService.prototype._svgRenderedDefinitions;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype._inProgressFetches;
    /**
     * Url prefix for fetching inline SVG by dynamic importing.
     * @type {?}
     * @protected
     */
    IconService.prototype._assetsUrlRoot;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype._twoToneColorPalette;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype._rendererFactory;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype._handler;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype._document;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype.sanitizer;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWNvbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFudC1kZXNpZ24vaWNvbnMtYW5ndWxhci8iLCJzb3VyY2VzIjpbImNvbXBvbmVudC9pY29uLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzQyxPQUFPLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQy9ELE9BQU8sRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFhLGdCQUFnQixFQUFFLGVBQWUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMvRixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDekQsT0FBTyxFQUFFLEVBQUUsSUFBSSxZQUFZLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFDdEQsT0FBTyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUV2RSxPQUFPLEVBQ0wsUUFBUSxFQUNSLHlCQUF5QixFQUN6QixtQkFBbUIsRUFDbkIsaUJBQWlCLEVBQ2pCLFlBQVksRUFDWixnQkFBZ0IsRUFDaEIsZ0JBQWdCLEVBQ2hCLFVBQVUsRUFDVixrQkFBa0IsRUFDbkIsTUFBTSxVQUFVLENBQUM7QUFDbEIsT0FBTyxFQUFFLG1CQUFtQixFQUFFLGlCQUFpQixFQUFFLDBCQUEwQixFQUFFLG1CQUFtQixFQUFFLGVBQWUsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUV4SSxNQUFNLE9BQU8sV0FBVzs7Ozs7OztJQXNDdEIsWUFDWSxnQkFBa0MsRUFDdEIsUUFBcUIsRUFFSCxTQUFjLEVBQzVDLFNBQXVCO1FBSnZCLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7UUFDdEIsYUFBUSxHQUFSLFFBQVEsQ0FBYTtRQUVILGNBQVMsR0FBVCxTQUFTLENBQUs7UUFDNUMsY0FBUyxH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UUFBUTtZQTNEdkIsWUFBWTs7OztJQWtCbkIsbUNBQW9DOzs7OztJQUVwQyxnQ0FBK0I7Ozs7O0lBQy9CLDRCQUE0Qjs7Ozs7O0lBSzVCLHNDQUE4RDs7Ozs7OztJQU05RCw4Q0FBNEU7Ozs7O0lBRTVFLHlDQUFvRjs7Ozs7O0lBS3BGLHFDQUE4Qjs7Ozs7SUFFOUIsMkNBR0U7Ozs7O0lBWUEsdUNBQTRDOzs7OztJQUM1QywrQkFBMkM7Ozs7O0lBRTNDLGdDQUFzRDs7Ozs7SUFDdEQsZ0NBQWlDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgSHR0cEJhY2tlbmQsIEh0dHBDbGllbnQgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBJbmplY3QsIE9wdGlvbmFsLCBSZW5kZXJlcjIsIFJlbmRlcmVyRmFjdG9yeTIsIFNlY3VyaXR5Q29udGV4dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRG9tU2FuaXRpemVyIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5pbXBvcnQgeyBvZiBhcyBvYnNlcnZhYmxlT2YsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGNhdGNoRXJyb3IsIGZpbmFsaXplLCBtYXAsIHNoYXJlLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBDYWNoZWRJY29uRGVmaW5pdGlvbiwgSWNvbkRlZmluaXRpb24sIFRoZW1lVHlwZSwgVHdvVG9uZUNvbG9yUGFsZXR0ZSwgVHdvVG9uZUNvbG9yUGFsZXR0ZVNldHRlciB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7XG4gIGNsb25lU1ZHLFxuICBnZXRJY29uRGVmaW5pdGlvbkZyb21BYmJyLFxuICBnZXROYW1lQW5kTmFtZXNwYWNlLFxuICBnZXRTZWNvbmRhcnlDb2xvcixcbiAgaGFzTmFtZXNwYWNlLFxuICBpc0ljb25EZWZpbml0aW9uLFxuICByZXBsYWNlRmlsbENvbG9yLFxuICB3aXRoU3VmZml4LFxuICB3aXRoU3VmZml4QW5kQ29sb3Jcbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgSHR0cE1vZHVsZU5vdEltcG9ydCwgSWNvbk5vdEZvdW5kRXJyb3IsIE5hbWVTcGFjZUlzTm90U3BlY2lmeUVycm9yLCBTVkdUYWdOb3RGb3VuZEVycm9yLCBVcmxOb3RTYWZlRXJyb3IgfSBmcm9tICcuL2ljb24uZXJyb3InO1xuXG5leHBvcnQgY2xhc3MgSWNvblNlcnZpY2Uge1xuICBkZWZhdWx0VGhlbWU6IFRoZW1lVHlwZSA9ICdvdXRsaW5lJztcblxuICBwcm90ZWN0ZWQgX3JlbmRlcmVyOiBSZW5kZXJlcjI7XG4gIHByb3RlY3RlZCBfaHR0cDogSHR0cENsaWVudDtcblxuICAvKipcbiAgICogQWxsIGljb24gZGVmaW5pdGlvbnMgd291bGQgYmUgcmVnaXN0ZXJlZCBoZXJlLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9zdmdEZWZpbml0aW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBJY29uRGVmaW5pdGlvbj4oKTtcblxuICAvKipcbiAgICogQ2FjaGUgYWxsIHJlbmRlcmVkIGljb25zLiBJY29ucyBhcmUgaWRlbnRpZmllZCBieSBuYW1lLCB0aGVtZSxcbiAgICogYW5kIGZvciB0d290b25lIGljb25zLCBwcmltYXJ5IGNvbG9yIGFuZCBzZWNvbmRhcnkgY29sb3IuXG4gICAqL1xuICBwcm90ZWN0ZWQgX3N2Z1JlbmRlcmVkRGVmaW5pdGlvbnMgPSBuZXcgTWFwPHN0cmluZywgQ2FjaGVkSWNvbkRlZmluaXRpb24+KCk7XG5cbiAgcHJvdGVjdGVkIF9pblByb2dyZXNzRmV0Y2hlcyA9IG5ldyBNYXA8c3RyaW5nLCBPYnNlcnZhYmxlPEljb25EZWZpbml0aW9uIHwgbnVsbD4+KCk7XG5cbiAgLyoqXG4gICAqIFVybCBwcmVmaXggZm9yIGZldGNoaW5nIGlubGluZSBTVkcgYnkgZHluYW1pYyBpbXBvcnRpbmcuXG4gICAqL1xuICBwcm90ZWN0ZWQgX2Fzc2V0c1VybFJvb3QgPSAnJztcblxuICBwcm90ZWN0ZWQgX3R3b1RvbmVDb2xvclBhbGV0dGU6IFR3b1RvbmVDb2xvclBhbGV0dGUgPSB7XG4gICAgcHJpbWFyeUNvbG9yICA6ICcjMzMzMzMzJyxcbiAgICBzZWNvbmRhcnlDb2xvcjogJyNFNkU2RTYnXG4gIH07XG5cbiAgc2V0IHR3b1RvbmVDb2xvcih7IHByaW1hcnlDb2xvciwgc2Vjb25kYXJ5Q29sb3IgfTogVHdvVG9uZUNvbG9yUGFsZXR0ZVNldHRlcikge1xuICAgIHRoaXMuX3R3b1RvbmVDb2xvclBhbGV0dGUucHJpbWFyeUNvbG9yID0gcHJpbWFyeUNvbG9yO1xuICAgIHRoaXMuX3R3b1RvbmVDb2xvclBhbGV0dGUuc2Vjb25kYXJ5Q29sb3IgPSBzZWNvbmRhcnlDb2xvciB8fCBnZXRTZWNvbmRhcnlDb2xvcihwcmltYXJ5Q29sb3IpO1xuICB9XG5cbiAgZ2V0IHR3b1RvbmVDb2xvcigpOiBUd29Ub25lQ29sb3JQYWxldHRlU2V0dGVyIHtcbiAgICByZXR1cm4geyAuLi50aGlzLl90d29Ub25lQ29sb3JQYWxldHRlIH0gYXMgVHdvVG9uZUNvbG9yUGFsZXR0ZTsgLy8gTWFrZSBhIGNvcHkgdG8gYXZvaWQgdW5leHBlY3RlZCBjaGFuZ2VzLlxuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIF9yZW5kZXJlckZhY3Rvcnk6IFJlbmRlcmVyRmFjdG9yeTIsXG4gICAgQE9wdGlvbmFsKCkgcHJvdGVjdGVkIF9oYW5kbGVyOiBIdHRwQmFja2VuZCxcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChET0NVTUVOVCkgcHJvdGVjdGVkIF9kb2N1bWVudDogYW55LFxuICAgIHByb3RlY3RlZCBzYW5pdGl6ZXI6IERvbVNhbml0aXplclxuICApIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyRmFjdG9yeS5jcmVhdGVSZW5kZXJlcihudWxsLCBudWxsKTtcbiAgICBpZiAodGhpcy5faGFuZGxlcikge1xuICAgICAgdGhpcy5faHR0cCA9IG5ldyBIdHRwQ2xpZW50KHRoaXMuX2hhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIHByZWZpeCBvZiB0aGUgaW5saW5lIHN2ZyByZXNvdXJjZXMsIHNvIHRoZXkgY291bGQgYmUgZGVwbG95ZWQgZWxzZXdoZXJlLCBsaWtlIENETi5cbiAgICogQHBhcmFtIHByZWZpeFxuICAgKi9cbiAgY2hhbmdlQXNzZXRzU291cmNlKHByZWZpeDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5fYXNzZXRzVXJsUm9vdCA9IHByZWZpeC5lbmRzV2l0aCgnLycpID8gcHJlZml4IDogcHJlZml4ICsgJy8nO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBpY29ucyBwcm92aWRlZCBieSBhbnQgZGVzaWduLlxuICAgKiBAcGFyYW0gaWNvbnNcbiAgICovXG4gIGFkZEljb24oLi4uaWNvbnM6IEljb25EZWZpbml0aW9uW10pOiB2b2lkIHtcbiAgICBpY29ucy5mb3JFYWNoKGljb24gPT4ge1xuICAgICAgdGhpcy5fc3ZnRGVmaW5pdGlvbnMuc2V0KHdpdGhTdWZmaXgoaWNvbi5uYW1lLCBpY29uLnRoZW1lKSwgaWNvbik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gaWNvbi4gTmFtZXNwYWNlIGlzIHJlcXVpcmVkLlxuICAgKiBAcGFyYW0gdHlwZVxuICAgKiBAcGFyYW0gbGl0ZXJhbFxuICAgKi9cbiAgYWRkSWNvbkxpdGVyYWwodHlwZTogc3RyaW5nLCBsaXRlcmFsOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBbIG5hbWUsIG5hbWVzcGFjZSBdID0gZ2V0TmFtZUFuZE5hbWVzcGFjZSh0eXBlKTtcbiAgICBpZiAoIW5hbWVzcGFjZSkge1xuICAgICAgdGhyb3cgTmFtZVNwYWNlSXNOb3RTcGVjaWZ5RXJyb3IoKTtcbiAgICB9XG4gICAgdGhpcy5hZGRJY29uKHsgbmFtZTogdHlwZSwgaWNvbjogbGl0ZXJhbCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGNhY2hlLlxuICAgKi9cbiAgY2xlYXIoKTogdm9pZCB7XG4gICAgdGhpcy5fc3ZnRGVmaW5pdGlvbnMuY2xlYXIoKTtcbiAgICB0aGlzLl9zdmdSZW5kZXJlZERlZmluaXRpb25zLmNsZWFyKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgcmVuZGVyZWQgYFNWR0VsZW1lbnRgLlxuICAgKiBAcGFyYW0gaWNvblxuICAgKiBAcGFyYW0gdHdvVG9uZUNvbG9yXG4gICAqL1xuICBnZXRSZW5kZXJlZENvbnRlbnQoaWNvbjogSWNvbkRlZmluaXRpb24gfCBzdHJpbmcsIHR3b1RvbmVDb2xvcj86IHN0cmluZyk6IE9ic2VydmFibGU8U1ZHRWxlbWVudD4ge1xuICAgIC8vIElmIGBpY29uYCBpcyBhIGBJY29uRGVmaW5pdGlvbmAsIGdvIHRvIHRoZSBuZXh0IHN0ZXAuIElmIG5vdCwgdHJ5IHRvIGZldGNoIGl0IGZyb20gY2FjaGUuXG4gICAgY29uc3QgZGVmaW5pdGlvbjogSWNvbkRlZmluaXRpb24gfCBudWxsIHwgdW5kZWZpbmVkID0gaXNJY29uRGVmaW5pdGlvbihpY29uKSA/IGljb24gYXMgSWNvbkRlZmluaXRpb24gOiB0aGlzLl9zdmdEZWZpbml0aW9ucy5nZXQoaWNvbiBhcyBzdHJpbmcpO1xuXG4gICAgLy8gSWYgYGljb25gIGlzIGEgYEljb25EZWZpbml0aW9uYCBvZiBzdWNjZXNzZnVsbHkgZmV0Y2gsIHdyYXAgaXQgaW4gYW4gYE9ic2VydmFibGVgLiBPdGhlcndpc2UgdHJ5IHRvIGZldGNoIGl0IGZyb20gcmVtb3RlLlxuICAgIGNvbnN0ICRpY29uRGVmaW5pdGlvbiA9IGRlZmluaXRpb24gPyBvYnNlcnZhYmxlT2YoZGVmaW5pdGlvbikgOiB0aGlzLl9nZXRGcm9tUmVtb3RlKGljb24gYXMgc3RyaW5nKTtcblxuICAgIC8vIElmIGZpbmFsbHkgZ2V0IGFuIGBJY29uRGVmaW5pdGlvbmAsIHJlbmRlciBhbmQgcmV0dXJuIGl0LiBPdGhlcndpc2UgdGhyb3cgYW4gZXJyb3IuXG4gICAgcmV0dXJuICRpY29uRGVmaW5pdGlvbi5waXBlKG1hcChpID0+IHtcbiAgICAgIGlmICghaSkgeyB0aHJvdyBJY29uTm90Rm91bmRFcnJvcihpY29uIGFzIHN0cmluZyk7IH1cbiAgICAgIHJldHVybiB0aGlzLl9sb2FkU1ZHRnJvbUNhY2hlT3JDcmVhdGVOZXcoaSwgdHdvVG9uZUNvbG9yKTtcbiAgICB9KSk7XG4gIH1cblxuICBnZXRDYWNoZWRJY29ucygpOiBNYXA8c3RyaW5nLCBJY29uRGVmaW5pdGlvbj4ge1xuICAgIHJldHVybiB0aGlzLl9zdmdEZWZpbml0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcmF3IHN2ZyBhbmQgYXNzZW1ibGUgYSBgSWNvbkRlZmluaXRpb25gIG9iamVjdC5cbiAgICogQHBhcmFtIHR5cGVcbiAgICovXG4gIHByb3RlY3RlZCBfZ2V0RnJvbVJlbW90ZSh0eXBlOiBzdHJpbmcpOiBPYnNlcnZhYmxlPEljb25EZWZpbml0aW9uIHwgbnVsbD4ge1xuICAgIGlmICghdGhpcy5faHR0cCkgeyByZXR1cm4gb2JzZXJ2YWJsZU9mKEh0dHBNb2R1bGVOb3RJbXBvcnQoKSk7IH1cblxuICAgIC8vIElmIG11bHRpIGRpcmVjdGl2ZSBhc2sgZm9yIHRoZSBzYW1lIGljb24gYXQgdGhlIHNhbWUgdGltZSwgaHR0cCByZXF1ZXN0IHNob3VsZCBvbmx5IGJlIGZpcmVkIG9uY2UuXG4gICAgbGV0IGluUHJvZ3Jlc3MgPSB0aGlzLl9pblByb2dyZXNzRmV0Y2hlcy5nZXQodHlwZSk7XG5cbiAgICAvLyBJZiB0aGVyZSdzIG5vIG90aGVyIGRpcmVjdGl2ZSBhc2tpbmcgZm9yIHRoZSBzYW1lIGljb24sIGZpcmUgYSByZXF1ZXN0LlxuICAgIGlmICghaW5Qcm9ncmVzcykge1xuICAgICAgY29uc3QgWyBuYW1lLCBuYW1lc3BhY2UgXSA9IGdldE5hbWVBbmROYW1lc3BhY2UodHlwZSk7XG5cbiAgICAgIC8vIElmIHRoZSBzdHJpbmcgaGFzIGEgbmFtZXNwYWNlIHdpdGhpbiwgY3JlYXRlIGEgc2ltcGxlIGBJY29uRGVmaW5pdGlvbmAuXG4gICAgICBjb25zdCBpY29uOiBJY29uRGVmaW5pdGlvbiA9IG5hbWVzcGFjZVxuICAgICAgICA/IHsgbmFtZTogdHlwZSwgaWNvbjogJycgfVxuICAgICAgICA6IGdldEljb25EZWZpbml0aW9uRnJvbUFiYnIobmFtZSk7XG5cbiAgICAgIGNvbnN0IHVybCA9IG5hbWVzcGFjZVxuICAgICAgICA/IGAke3RoaXMuX2Fzc2V0c1VybFJvb3R9YXNzZXRzLyR7bmFtZXNwYWNlfS8ke25hbWV9LnN2Z2BcbiAgICAgICAgOiBgJHt0aGlzLl9hc3NldHNVcmxSb290fWFzc2V0cy8ke2ljb24udGhlbWV9LyR7aWNvbi5uYW1lfS5zdmdgO1xuXG4gICAgICBjb25zdCBzYWZlVXJsID0gdGhpcy5zYW5pdGl6ZXIuc2FuaXRpemUoU2VjdXJpdHlDb250ZXh0LlVSTCwgdXJsKTtcblxuICAgICAgaWYgKCFzYWZlVXJsKSB7IHRocm93IFVybE5vdFNhZmVFcnJvcih1cmwpOyB9XG5cbiAgICAgIC8vIFdyYXAgYSBgSWNvbkRlZmluaXRpb25gLCBjYWNoZSBpdCwgZGVsZXRlIHRoZSBzaGFyZWQgd29yay5cbiAgICAgIGluUHJvZ3Jlc3MgPSB0aGlzLl9odHRwLmdldChzYWZlVXJsLCB7IHJlc3BvbnNlVHlwZTogJ3RleHQnIH0pLnBpcGUoXG4gICAgICAgIG1hcChsaXRlcmFsID0+ICh7IC4uLmljb24sIGljb246IGxpdGVyYWwgfSkpLFxuICAgICAgICB0YXAoZGVmaW5pdGlvbiA9PiB0aGlzLmFkZEljb24oZGVmaW5pdGlvbikpLFxuICAgICAgICBmaW5hbGl6ZSgoKSA9PiB0aGlzLl9pblByb2dyZXNzRmV0Y2hlcy5kZWxldGUodHlwZSkpLFxuICAgICAgICBjYXRjaEVycm9yKCgpID0+IG9ic2VydmFibGVPZihudWxsKSksXG4gICAgICAgIHNoYXJlKClcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuX2luUHJvZ3Jlc3NGZXRjaGVzLnNldCh0eXBlLCBpblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UganVzdCByZXVzZSBvdGhlciBkaXJlY3RpdmUncyByZXF1ZXN0LlxuICAgIHJldHVybiBpblByb2dyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIG5ldyBgU1ZHRWxlbWVudGAgZm9yIGdpdmVuIGBJY29uRGVmaW5pdGlvbmAsIG9yIG1ha2UgYSBjb3B5IGZyb20gY2FjaGUuXG4gICAqIEBwYXJhbSBpY29uXG4gICAqIEBwYXJhbSB0d29Ub25lQ29sb3JcbiAgICovXG4gIHByb3RlY3RlZCBfbG9hZFNWR0Zyb21DYWNoZU9yQ3JlYXRlTmV3KGljb246IEljb25EZWZpbml0aW9uLCB0d29Ub25lQ29sb3I/OiBzdHJpbmcpOiBTVkdFbGVtZW50IHtcbiAgICBsZXQgc3ZnOiBTVkdFbGVtZW50O1xuXG4gICAgY29uc3QgcHJpID0gdHdvVG9uZUNvbG9yIHx8IHRoaXMuX3R3b1RvbmVDb2xvclBhbGV0dGUucHJpbWFyeUNvbG9yO1xuICAgIGNvbnN0IHNlYyA9IGdldFNlY29uZGFyeUNvbG9yKHByaSkgfHwgdGhpcy5fdHdvVG9uZUNvbG9yUGFsZXR0ZS5zZWNvbmRhcnlDb2xvcjtcbiAgICBjb25zdCBrZXkgPSBpY29uLnRoZW1lID09PSAndHdvdG9uZSdcbiAgICAgID8gd2l0aFN1ZmZpeEFuZENvbG9yKGljb24ubmFtZSwgaWNvbi50aGVtZSwgcHJpLCBzZWMpXG4gICAgICA6IGljb24udGhlbWUgPT09IHVuZGVmaW5lZCA/IGljb24ubmFtZSA6IHdpdGhTdWZmaXgoaWNvbi5uYW1lLCBpY29uLnRoZW1lKTtcblxuICAgIC8vIFRyeSB0byBtYWtlIGEgY29weSBmcm9tIGNhY2hlLlxuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuX3N2Z1JlbmRlcmVkRGVmaW5pdGlvbnMuZ2V0KGtleSk7XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBzdmcgPSBjYWNoZWQuaWNvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3ZnID0gdGhpcy5fc2V0U1ZHQXR0cmlidXRlKHRoaXMuX2NvbG9yaXplU1ZHSWNvbihcbiAgICAgICAgLy8gSWNvbnMgcHJvdmlkZWQgYnkgYW50IGRlc2lnbiBzaG91bGQgYmUgcmVmaW5lZCB0byByZW1vdmUgcHJlc2V0IGNvbG9ycy5cbiAgICAgICAgdGhpcy5fY3JlYXRlU1ZHRWxlbWVudEZyb21TdHJpbmcoaGFzTmFtZXNwYWNlKGljb24ubmFtZSkgPyBpY29uLmljb24gOiByZXBsYWNlRmlsbENvbG9yKGljb24uaWNvbikpLFxuICAgICAgICBpY29uLnRoZW1lID09PSAndHdvdG9uZScsXG4gICAgICAgIHByaSxcbiAgICAgICAgc2VjXG4gICAgICApKTtcbiAgICAgIC8vIENhY2hlIGl0LlxuICAgICAgdGhpcy5fc3ZnUmVuZGVyZWREZWZpbml0aW9ucy5zZXQoa2V5LCB7IC4uLmljb24sIGljb246IHN2ZyB9IGFzIENhY2hlZEljb25EZWZpbml0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmVTVkcoc3ZnKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfY3JlYXRlU1ZHRWxlbWVudEZyb21TdHJpbmcoc3RyOiBzdHJpbmcpOiBTVkdFbGVtZW50IHtcbiAgICBjb25zdCBkaXYgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuaW5uZXJIVE1MID0gc3RyO1xuICAgIGNvbnN0IHN2ZzogU1ZHRWxlbWVudCA9IGRpdi5xdWVyeVNlbGVjdG9yKCdzdmcnKTtcbiAgICBpZiAoIXN2ZykgeyB0aHJvdyBTVkdUYWdOb3RGb3VuZEVycm9yOyB9XG4gICAgcmV0dXJuIHN2ZztcbiAgfVxuXG4gIHByb3RlY3RlZCBfc2V0U1ZHQXR0cmlidXRlKHN2ZzogU1ZHRWxlbWVudCk6IFNWR0VsZW1lbnQge1xuICAgIHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZShzdmcsICd3aWR0aCcsICcxZW0nKTtcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUoc3ZnLCAnaGVpZ2h0JywgJzFlbScpO1xuICAgIHJldHVybiBzdmc7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NvbG9yaXplU1ZHSWNvbihzdmc6IFNWR0VsZW1lbnQsIHR3b3RvbmU6IGJvb2xlYW4sIHByaTogc3RyaW5nLCBzZWM6IHN0cmluZyk6IFNWR0VsZW1lbnQge1xuICAgIGlmICh0d290b25lKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHN2Zy5jaGlsZE5vZGVzO1xuICAgICAgY29uc3QgbGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZDogSFRNTEVsZW1lbnQgPSBjaGlsZHJlblsgaSBdIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICBpZiAoY2hpbGQuZ2V0QXR0cmlidXRlKCdmaWxsJykgPT09ICdzZWNvbmRhcnlDb2xvcicpIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUoY2hpbGQsICdmaWxsJywgc2VjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUoY2hpbGQsICdmaWxsJywgcHJpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUoc3ZnLCAnZmlsbCcsICdjdXJyZW50Q29sb3InKTtcbiAgICByZXR1cm4gc3ZnO1xuICB9XG59XG4iXX0=